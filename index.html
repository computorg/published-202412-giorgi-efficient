<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Daphné Giorgi">
<meta name="author" content="Sarah Kaakai">
<meta name="author" content="Vincent Lemaire">
<meta name="dcterms.date" content="2024-12-01">
<meta name="keywords" content="Individual-based models, stochastic simulation, population dynamics, Poisson measures, thinning method, actuarial science, insurance portfolio simulation">
<meta name="description" content="This document provides a full description of the Stochastic Individual-Based Models (IBMs) that can be implemented in the IBMPopSim package. A unified mathematical and simulation framework is given, with a detailed description of the simulation algorithm. Examples of applications for the package are also provided, showing the performance and flexibility of IBMPopSim.">

<title>Efficient simulation of individual-based population models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="published_202412-giorgi-efficient_files/libs/clipboard/clipboard.min.js"></script>
<script src="published_202412-giorgi-efficient_files/libs/quarto-html/quarto.js"></script>
<script src="published_202412-giorgi-efficient_files/libs/quarto-html/popper.min.js"></script>
<script src="published_202412-giorgi-efficient_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="published_202412-giorgi-efficient_files/libs/quarto-html/anchor.min.js"></script>
<link href="published_202412-giorgi-efficient_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="published_202412-giorgi-efficient_files/libs/quarto-html/quarto-syntax-highlighting-0626ff4d7a71b55c8707dcae1d04a9b6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="published_202412-giorgi-efficient_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="published_202412-giorgi-efficient_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="published_202412-giorgi-efficient_files/libs/bootstrap/bootstrap-0ec49e081fc9fd0a69e64d62137d8a0c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="published_202412-giorgi-efficient_files/libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.js"></script>
<link href="published_202412-giorgi-efficient_files/libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.css" rel="stylesheet">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta name="citation_title" content="Efficient simulation of individual-based population models">
<meta name="citation_abstract" content="The `R` Package `IBMPopSim` facilitates the simulation of the random evolution of heterogeneous populations using stochastic Individual-Based Models (IBMs). The package enables users to simulate population evolution, in which individuals are characterized by their age and some characteristics, and the population is modified by different types of events, including births/arrivals, death/exit events, or changes of characteristics. The frequency at which an event can occur to an individual can depend on their age and characteristics, but also on the characteristics of other individuals (interactions). Such models have a wide range of applications in fields including  actuarial science, biology, ecology or epidemiology. `IBMPopSim` overcomes the limitations of time-consuming IBMs simulations by implementing new efficient algorithms  based on thinning methods, which are compiled using the `Rcpp` package while providing a user-friendly interface.
">
<meta name="citation_keywords" content="Individual-based models,stochastic simulation,population dynamics,Poisson measures,thinning method,actuarial science,insurance portfolio simulation">
<meta name="citation_author" content="Daphné Giorgi">
<meta name="citation_author" content="Sarah Kaakai">
<meta name="citation_author" content="Vincent Lemaire">
<meta name="citation_publication_date" content="2024-12-01">
<meta name="citation_cover_date" content="2024-12-01">
<meta name="citation_year" content="2024">
<meta name="citation_online_date" content="2024-12-01">
<meta name="citation_fulltext_html_url" content="https://computo.sfds.asso.fr/published-202412-giorgi-efficient">
<meta name="citation_doi" content="10.57750/sfxn-1t05">
<meta name="citation_issn" content="2824-7795">
<meta name="citation_language" content="en">
<meta name="citation_journal_title" content="Computo">
<meta name="citation_publisher" content="Société Française de Statistique">
<meta name="citation_reference" content="citation_title=StMoMo: An R Package for Stochastic Mortality Modelling;,citation_author=Andrés M. Villegas;,citation_author=Vladimir K. Kaishev;,citation_author=Pietro Millossovich;,citation_publication_date=2018;,citation_cover_date=2018;,citation_year=2018;,citation_volume=84;,citation_journal_title=Journal of Statistical Software;">
<meta name="citation_reference" content="citation_title=MIC-CORE: A tool for microsimulation;,citation_author=Sabine Zinn;,citation_author=Jutta Gampe;,citation_author=Jan Himmelspach;,citation_author=Adelinde M Uhrmacher;,citation_publication_date=2009;,citation_cover_date=2009;,citation_year=2009;,citation_conference_title=Proceedings of the 2009 winter simulation conference (WSC);,citation_conference=IEEE;">
<meta name="citation_reference" content="citation_title=Rcpp: Seamless r and c++ integration;,citation_author=Dirk Eddelbuettel;,citation_author=Romain Francois;,citation_publication_date=2011;,citation_cover_date=2011;,citation_year=2011;,citation_fulltext_html_url=https://www.jstatsoft.org/index.php/jss/article/view/v040i08;,citation_issue=8;,citation_doi=10.18637/jss.v040.i08;,citation_volume=40;,citation_journal_title=Journal of Statistical Software;">
<meta name="citation_reference" content="citation_title=Understanding, modelling and managing longevity risk: Key issues and main challenges;,citation_author=Pauline Barrieu;,citation_author=Harry Bensusan;,citation_author=Nicole El Karoui;,citation_author=Caroline Hillairet;,citation_author=Stéphane Loisel;,citation_author=Claudia Ravanelli;,citation_author=Yahia Salhi;,citation_publication_date=2012;,citation_cover_date=2012;,citation_year=2012;,citation_issue=3;,citation_volume=2012;,citation_journal_title=Scandinavian actuarial journal;,citation_publisher=Taylor &amp;amp;amp; Francis;">
<meta name="citation_reference" content="citation_title=A rigorous model study of the adaptive dynamics of mendelian diploids;,citation_author=Pierre Collet;,citation_author=Sylvie Méléard;,citation_author=Johan AJ Metz;,citation_publication_date=2013;,citation_cover_date=2013;,citation_year=2013;,citation_volume=67;,citation_journal_title=Journal of Mathematical Biology;,citation_publisher=Springer;">
<meta name="citation_reference" content="citation_title=A stochastic individual-based model for the growth of a stand of japanese knotweed including mowing as a management technique;,citation_author=François Lavallée;,citation_author=Charline Smadi;,citation_author=Isabelle Alvarez;,citation_author=Björn Reineking;,citation_author=François-Marie Martin;,citation_author=Fanny Dommanget;,citation_author=Sophie Martin;,citation_publication_date=2019;,citation_cover_date=2019;,citation_year=2019;,citation_volume=413;,citation_journal_title=Ecological Modelling;,citation_publisher=Elsevier;">
<meta name="citation_reference" content="citation_title=A birth–death model of ageing: From individual-based dynamics to evolutive differential inclusions;,citation_author=Sylvie Méléard;,citation_author=Michael Rera;,citation_author=Tristan Roget;,citation_publication_date=2019;,citation_cover_date=2019;,citation_year=2019;,citation_volume=79;,citation_journal_title=Journal of mathematical biology;,citation_publisher=Springer;">
<meta name="citation_reference" content="citation_title=Stochastic eco-evolutionary model of a prey-predator community;,citation_author=Manon Costa;,citation_author=Céline Hauzy;,citation_author=Nicolas Loeuille;,citation_author=Sylvie Méléard;,citation_publication_date=2016;,citation_cover_date=2016;,citation_year=2016;,citation_volume=72;,citation_journal_title=Journal of mathematical biology;,citation_publisher=Springer;">
<meta name="citation_reference" content="citation_title=The effect of competition and horizontal trait inheritance on invasion, fixation, and polymorphism;,citation_author=Sylvain Billiard;,citation_author=Pierre Collet;,citation_author=Régis Ferrière;,citation_author=Sylvie Méléard;,citation_author=Viet Chi Tran;,citation_publication_date=2016;,citation_cover_date=2016;,citation_year=2016;,citation_volume=411;,citation_journal_title=Journal of theoretical biology;,citation_publisher=Elsevier;">
<meta name="citation_reference" content="citation_title=Unifying evolutionary dynamics: From individual stochastic processes to macroscopic models;,citation_author=Nicolas Champagnat;,citation_author=Régis Ferrière;,citation_author=Sylvie Méléard;,citation_publication_date=2006;,citation_cover_date=2006;,citation_year=2006;,citation_issue=3;,citation_volume=69;,citation_journal_title=Theoretical population biology;,citation_publisher=Elsevier;">
<meta name="citation_reference" content="citation_title=Stability results for a general class of interacting point processes dynamics, and applications;,citation_author=Laurent Massoulié;,citation_publication_date=1998;,citation_cover_date=1998;,citation_year=1998;,citation_fulltext_html_url=https://www.sciencedirect.com/science/article/pii/S0304414998000064;,citation_issue=1;,citation_doi=https://doi.org/10.1016/S0304-4149(98)00006-4;,citation_issn=0304-4149;,citation_volume=75;,citation_journal_title=Stochastic Processes and their Applications;">
<meta name="citation_reference" content="citation_title=Point processes and queues: Martingale dynamics;,citation_author=Pierre Brémaud;,citation_publication_date=1981;,citation_cover_date=1981;,citation_year=1981;,citation_volume=66;">
<meta name="citation_reference" content="citation_title=The MicSim package of R: an entry-level toolkit for continuous-time microsimulation;,citation_author=Sabine Zinn;,citation_publication_date=2014;,citation_cover_date=2014;,citation_year=2014;,citation_issue=3;,citation_volume=7;,citation_journal_title=International Journal of Microsimulation;">
<meta name="citation_reference" content="citation_title=Simulation of nonhomogeneous poisson processes by thinning;,citation_author=Peter Lewis;,citation_author=Gerald Shedler;,citation_publication_date=1979;,citation_cover_date=1979;,citation_year=1979;,citation_issue=3;,citation_volume=26;,citation_journal_title=Naval research logistics quarterly;">
<meta name="citation_reference" content="citation_title=Birth death swap population in random environment and aggregation with two timescales;,citation_author=Sarah Kaakai;,citation_author=Nicole El Karoui;,citation_publication_date=2023;,citation_cover_date=2023;,citation_year=2023;,citation_doi=https://doi.org/10.1016/j.spa.2023.04.017;,citation_issn=0304-4149;,citation_volume=162;,citation_journal_title=Stochastic Processes and their Applications;">
<meta name="citation_reference" content="citation_title=Simulating long-term impacts of mortality shocks: Learning from the cholera pandemic;,citation_author=Nicole El Karoui;,citation_author=Kaouther Hadji;,citation_author=Sarah Kaakai;,citation_publication_date=2021;,citation_cover_date=2021;,citation_year=2021;,citation_journal_title=arXiv preprint arXiv:2111.08338;">
<meta name="citation_reference" content="citation_title=Horizontal gene transfer: Numerical comparison between stochastic and deterministic approaches;,citation_author=Vincent Calvez;,citation_author=Susely Figueroa Iglesias;,citation_author=Hélène Hivert;,citation_author=Sylvie Méléard;,citation_author=Anna Melnykova;,citation_author=Samuel Nordmann;,citation_publication_date=2020;,citation_cover_date=2020;,citation_year=2020;,citation_volume=67;,citation_journal_title=ESAIM: Proceedings and Surveys;,citation_publisher=EDP Sciences;">
<meta name="citation_reference" content="citation_title=A scenario for an evolutionary selection of ageing;,citation_author=T Roget;,citation_author=Claire Macmurray;,citation_author=P Jolivet;,citation_author=S Méléard;,citation_author=Michael Rera;,citation_publication_date=2024;,citation_cover_date=2024;,citation_year=2024;,citation_volume=13;,citation_journal_title=eLife;,citation_publisher=eLife Sciences Publications Limited;">
<meta name="citation_reference" content="citation_title=Modèles particulaires stochastiques pour des problèmes d’évolution adaptative et pour l’approximation de solutions statistiques;,citation_author=Viet Chi Tran;,citation_publication_date=2006;,citation_cover_date=2006;,citation_year=2006;,citation_dissertation_institution=Université de Nanterre - Paris X;">
<meta name="citation_reference" content="citation_title=Interest rate and longevity risk: dynamic model and applications to derivative products and life insurance;,citation_author=Harry Bensusan;,citation_publication_date=2010;,citation_cover_date=2010;,citation_year=2010;,citation_dissertation_institution=Ecole Polytechnique X;">
<meta name="citation_reference" content="citation_title=Stochastic models for structured populations;,citation_author=Vincent Bansaye;,citation_author=Sylvie Méléard;,citation_publication_date=2015;,citation_cover_date=2015;,citation_year=2015;">
<meta name="citation_reference" content="citation_title=IBMPopSim: Individual based model population simulation;,citation_author=Daphné Giorgi;,citation_author=Sarah Kaakai;,citation_author=Vincent Lemaire;,citation_publication_date=2020;,citation_cover_date=2020;,citation_year=2020;">
<meta name="citation_reference" content="citation_title=Probability and Stochastics;,citation_author=Erhan Çinlar;,citation_publication_date=2011;,citation_cover_date=2011;,citation_year=2011;">
<meta name="citation_reference" content="citation_title=How can a cause-of-death reduction be compensated for by the population heterogeneity? A dynamic approach;,citation_author=Sarah Kaakaï;,citation_author=Héloïse Labit Hardy;,citation_author=Séverine Arnold;,citation_author=Nicole El Karoui;,citation_publication_date=2019;,citation_cover_date=2019;,citation_year=2019;,citation_fulltext_html_url=https://www.sciencedirect.com/science/article/pii/S0167668718301409;,citation_doi=https://doi.org/10.1016/j.insmatheco.2019.07.005;,citation_issn=0167-6687;,citation_volume=89;,citation_journal_title=Insurance: Mathematics and Economics;">
<meta name="citation_reference" content="citation_title=Nonuniform random variate generation;,citation_author=Luc Devroye;,citation_publication_date=1986;,citation_cover_date=1986;,citation_year=1986;">
<meta name="citation_reference" content="citation_title=Random measures, theory and applications;,citation_author=Olav Kallenberg;,citation_publication_date=2017;,citation_cover_date=2017;,citation_year=2017;,citation_volume=77;,citation_series_title=Probability theory and stochastic modelling;">
<meta name="citation_reference" content="citation_title=A microscopic probabilistic description of a locally regulated population and macroscopic approximations;,citation_author=Nicolas Fournier;,citation_author=Sylvie Méléard;,citation_publication_date=2004;,citation_cover_date=2004;,citation_year=2004;,citation_issue=4;,citation_volume=14;,citation_journal_title=Ann. Appl. Probab.;">
<meta name="citation_reference" content="citation_title=Stochastic and deterministic models for age-structured populations with genetically variable traits;,citation_author=Régis Ferrière;,citation_author=Viet Chi Tran;,citation_publication_date=2009;,citation_cover_date=2009;,citation_year=2009;,citation_volume=27;,citation_inbook_title=undefined;,citation_series_title=ESAIM proc.;">
<meta name="citation_reference" content="citation_title=The microsimulation tool of the MicMac project;,citation_author=Jutta Gampe;,citation_author=Sabine Zinn;,citation_author=Frans Willekens;,citation_author=Nicole Van Der Gaag;,citation_author=Joop De Beer;,citation_author=Jan Himmelspach;,citation_author=Adelinde Uhrmacher;,citation_publication_date=2009;,citation_cover_date=2009;,citation_year=2009;,citation_conference_title=2nd general conference of the international microsimulation association, ottawa;">
<meta name="citation_reference" content="citation_title=Micro-macro analysis of heterogenous age-structured populations dynamics.Application to self-exciting processes and demography.;,citation_author=Alexandre Boumezoued;,citation_publication_date=2016;,citation_cover_date=2016;,citation_year=2016;,citation_dissertation_institution=Université Pierre et Marie Curie;">
<meta name="citation_reference" content="citation_title=Large population limit and time behaviour of a stochastic particle model describing an age-structured population;,citation_author=Viet Chi Tran;,citation_publication_date=2008;,citation_cover_date=2008;,citation_year=2008;,citation_doi=10.1051/ps:2007052;,citation_volume=12;,citation_journal_title=ESAIM: Probability and Statistics;,citation_publisher=EDP Sciences;">
<meta name="citation_reference" content="citation_title=Trait substitution sequence process and canonical equation for age-structured populations;,citation_author=Sylvie Méléard;,citation_author=Viet Chi Tran;,citation_publication_date=2009;,citation_cover_date=2009;,citation_year=2009;,citation_volume=58;,citation_journal_title=Journal of mathematical biology;,citation_publisher=Springer;">
<meta name="citation_reference" content="citation_title=demography: Forecasting mortality, fertility, migration and population data;,citation_author=Rob Hyndman;,citation_author=Heather Booth Booth;,citation_author=Leonie Tickle Tickle;,citation_author=John Maindonald;,citation_author=Simon Wood Wood;,citation_author=R Core Team;,citation_publication_date=2023;,citation_cover_date=2023;,citation_year=2023;,citation_fulltext_html_url=https://cran.r-project.org/package=demography;">
<meta name="citation_reference" content="citation_title=StMoMo: Stochastic mortality modelling;,citation_author=Andres Villegas;,citation_author=Pietro Millossovich;,citation_author=Vladimir Kaishev Hyndman;,citation_publication_date=2018;,citation_cover_date=2018;,citation_year=2018;,citation_fulltext_html_url=https://cran.r-project.org/package=StMoMo;">
</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Efficient simulation of individual-based population models</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p class="subtitle lead">The <code>R</code> package <code>IBMPopSim</code></p>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
            <div>
        <div class="description">
          <p>This document provides a full description of the Stochastic Individual-Based Models (IBMs) that can be implemented in the IBMPopSim package. A unified mathematical and simulation framework is given, with a detailed description of the simulation algorithm. Examples of applications for the package are also provided, showing the performance and flexibility of IBMPopSim.</p>
        </div>
      </div>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://perso.lpsm.paris/~giorgi/">Daphné Giorgi</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.lpsm.paris/">
                  Sorbonne Université, CNRS
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://perso.univ-lemans.fr/~skaakai/">Sarah Kaakai</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://lmm.univ-lemans.fr/fr/">
                  Le Mans Université
                  </a>
                </p>
              <p class="affiliation">
                  <a href="https://cmap.ip-paris.fr/">
                  Ecole Polytechnique, CNRS
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://perso.lpsm.paris/~vlemaire/">Vincent Lemaire</a> <a href="https://orcid.org/0000-0002-0433-7722" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.lpsm.paris/">
                  Sorbonne Université, CNRS
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 1, 2024</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">December 2, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Individual-based models, stochastic simulation, population dynamics, Poisson measures, thinning method, actuarial science, insurance portfolio simulation</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <a href="https://github.com/computorg/published-202412-giorgi-efficient"><img src="https://github.com/computorg/published-202412-giorgi-efficient/actions/workflows/build.yml/badge.svg" alt="build status"></a>
                    <p class="date"></p>
        <a href="https://github.com/computorg/published-202412-giorgi-efficient/issues?q=is%3Aopen+is%3Aissue+label%3Areview"><img src="https://img.shields.io/badge/reviews-reports-blue" alt="reviews"></a>
            </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>The <code>R</code> Package <code>IBMPopSim</code> facilitates the simulation of the random evolution of heterogeneous populations using stochastic Individual-Based Models (IBMs). The package enables users to simulate population evolution, in which individuals are characterized by their age and some characteristics, and the population is modified by different types of events, including births/arrivals, death/exit events, or changes of characteristics. The frequency at which an event can occur to an individual can depend on their age and characteristics, but also on the characteristics of other individuals (interactions). Such models have a wide range of applications in fields including actuarial science, biology, ecology or epidemiology. <code>IBMPopSim</code> overcomes the limitations of time-consuming IBMs simulations by implementing new efficient algorithms based on thinning methods, which are compiled using the <code>Rcpp</code> package while providing a user-friendly interface.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-overview" id="toc-sec-overview" class="nav-link" data-scroll-target="#sec-overview"><span class="header-section-number">2</span> Brief overview of IBMPopSim</a>
  <ul class="collapse">
  <li><a href="#model-creation" id="toc-model-creation" class="nav-link" data-scroll-target="#model-creation"><span class="header-section-number">2.1</span> Model creation</a></li>
  <li><a href="#simulation" id="toc-simulation" class="nav-link" data-scroll-target="#simulation"><span class="header-section-number">2.2</span> Simulation</a></li>
  </ul></li>
  <li><a href="#sec-math" id="toc-sec-math" class="nav-link" data-scroll-target="#sec-math"><span class="header-section-number">3</span> Mathematical framework</a>
  <ul class="collapse">
  <li><a href="#sec-population" id="toc-sec-population" class="nav-link" data-scroll-target="#sec-population"><span class="header-section-number">3.1</span> Population</a>
  <ul class="collapse">
  <li><a href="#individuals" id="toc-individuals" class="nav-link" data-scroll-target="#individuals"><span class="header-section-number">3.1.1</span> Individuals</a></li>
  <li><a href="#population-process" id="toc-population-process" class="nav-link" data-scroll-target="#population-process"><span class="header-section-number">3.1.2</span> Population process</a></li>
  </ul></li>
  <li><a href="#sec-events" id="toc-sec-events" class="nav-link" data-scroll-target="#sec-events"><span class="header-section-number">3.2</span> Events</a></li>
  <li><a href="#sec-event-intensity" id="toc-sec-event-intensity" class="nav-link" data-scroll-target="#sec-event-intensity"><span class="header-section-number">3.3</span> Events intensity</a>
  <ul class="collapse">
  <li><a href="#events-intensity-bounds" id="toc-events-intensity-bounds" class="nav-link" data-scroll-target="#events-intensity-bounds">Events intensity bounds</a></li>
  </ul></li>
  <li><a href="#pathwise-representation-of-stochastic-ibm" id="toc-pathwise-representation-of-stochastic-ibm" class="nav-link" data-scroll-target="#pathwise-representation-of-stochastic-ibm"><span class="header-section-number">3.4</span> Pathwise representation of stochastic IBM</a>
  <ul class="collapse">
  <li><a href="#non-explosion-criterion" id="toc-non-explosion-criterion" class="nav-link" data-scroll-target="#non-explosion-criterion">Non-explosion criterion</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-simulation" id="toc-sec-simulation" class="nav-link" data-scroll-target="#sec-simulation"><span class="header-section-number">4</span> Population simulation</a>
  <ul class="collapse">
  <li><a href="#sec-thinning" id="toc-sec-thinning" class="nav-link" data-scroll-target="#sec-thinning"><span class="header-section-number">4.1</span> Thinning of Poisson measure</a>
  <ul class="collapse">
  <li><a href="#sec-vector" id="toc-sec-vector" class="nav-link" data-scroll-target="#sec-vector"><span class="header-section-number">4.1.1</span> Multivariate Poisson process</a></li>
  </ul></li>
  <li><a href="#sec-simulation-algo" id="toc-sec-simulation-algo" class="nav-link" data-scroll-target="#sec-simulation-algo"><span class="header-section-number">4.2</span> Simulation algorithm</a>
  <ul class="collapse">
  <li><a href="#first-event-simulation" id="toc-first-event-simulation" class="nav-link" data-scroll-target="#first-event-simulation">First event simulation</a></li>
  </ul></li>
  <li><a href="#sec-simulation-randomized" id="toc-sec-simulation-randomized" class="nav-link" data-scroll-target="#sec-simulation-randomized"><span class="header-section-number">4.3</span> Simulation algorithm with randomization</a></li>
  </ul></li>
  <li><a href="#sec-package" id="toc-sec-package" class="nav-link" data-scroll-target="#sec-package"><span class="header-section-number">5</span> Model creation and simulation with IBMPopSim</a>
  <ul class="collapse">
  <li><a href="#sec-package-population" id="toc-sec-package-population" class="nav-link" data-scroll-target="#sec-package-population"><span class="header-section-number">5.1</span> Population</a></li>
  <li><a href="#sec-package-events" id="toc-sec-package-events" class="nav-link" data-scroll-target="#sec-package-events"><span class="header-section-number">5.2</span> Events</a>
  <ul class="collapse">
  <li><a href="#intensities" id="toc-intensities" class="nav-link" data-scroll-target="#intensities"><span class="header-section-number">5.2.1</span> Intensities</a></li>
  <li><a href="#sec-event-kernel-code" id="toc-sec-event-kernel-code" class="nav-link" data-scroll-target="#sec-event-kernel-code"><span class="header-section-number">5.2.2</span> Event kernel code</a></li>
  </ul></li>
  <li><a href="#sec-model-creation" id="toc-sec-model-creation" class="nav-link" data-scroll-target="#sec-model-creation"><span class="header-section-number">5.3</span> Model creation</a></li>
  <li><a href="#sec-package-simulation" id="toc-sec-package-simulation" class="nav-link" data-scroll-target="#sec-package-simulation"><span class="header-section-number">5.4</span> Simulation</a></li>
  </ul></li>
  <li><a href="#sec-insurance-portfolio" id="toc-sec-insurance-portfolio" class="nav-link" data-scroll-target="#sec-insurance-portfolio"><span class="header-section-number">6</span> Insurance portfolio</a>
  <ul class="collapse">
  <li><a href="#insurance-population" id="toc-insurance-population" class="nav-link" data-scroll-target="#insurance-population"><span class="header-section-number">6.1</span> Population</a></li>
  <li><a href="#insurance-events" id="toc-insurance-events" class="nav-link" data-scroll-target="#insurance-events"><span class="header-section-number">6.2</span> Events</a></li>
  <li><a href="#insurance-simulation" id="toc-insurance-simulation" class="nav-link" data-scroll-target="#insurance-simulation"><span class="header-section-number">6.3</span> Model creation and simulation</a></li>
  <li><a href="#outputs" id="toc-outputs" class="nav-link" data-scroll-target="#outputs"><span class="header-section-number">6.4</span> Outputs</a></li>
  </ul></li>
  <li><a href="#sec-example-interaction" id="toc-sec-example-interaction" class="nav-link" data-scroll-target="#sec-example-interaction"><span class="header-section-number">7</span> Population with genetically variable traits</a>
  <ul class="collapse">
  <li><a href="#population" id="toc-population" class="nav-link" data-scroll-target="#population"><span class="header-section-number">7.1</span> Population</a></li>
  <li><a href="#events" id="toc-events" class="nav-link" data-scroll-target="#events"><span class="header-section-number">7.2</span> Events</a>
  <ul class="collapse">
  <li><a href="#birth-events" id="toc-birth-events" class="nav-link" data-scroll-target="#birth-events"><span class="header-section-number">7.2.1</span> Birth events</a></li>
  <li><a href="#death-events" id="toc-death-events" class="nav-link" data-scroll-target="#death-events"><span class="header-section-number">7.2.2</span> Death events</a></li>
  </ul></li>
  <li><a href="#model-creation-and-simulation" id="toc-model-creation-and-simulation" class="nav-link" data-scroll-target="#model-creation-and-simulation"><span class="header-section-number">7.3</span> Model creation and simulation</a></li>
  </ul></li>
  
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="published_202412-giorgi-efficient.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>In various fields, advances in probability have contributed to the development of a new mathematical framework for so-called individual-based stochastic population dynamics, also called stochastic Individual-Based Models (IBMs). Stochastic IBMs allow the modeling in continuous time of populations dynamics structured by age and/or characteristics. In the field of mathematical biology and ecology, a large community has used this formalism for the study of the evolution of structured populations (see e.g. <span class="citation" data-cites="FerTra09">Ferrière and Tran (<a href="#ref-FerTra09" role="doc-biblioref">2009</a>)</span>; <span class="citation" data-cites="collet2013rigorous">Collet, Méléard, and Metz (<a href="#ref-collet2013rigorous" role="doc-biblioref">2013</a>)</span>; <span class="citation" data-cites="BanMel15">Bansaye and Méléard (<a href="#ref-BanMel15" role="doc-biblioref">2015</a>)</span>; <span class="citation" data-cites="costa2016stochastic">Costa et al. (<a href="#ref-costa2016stochastic" role="doc-biblioref">2016</a>)</span>; <span class="citation" data-cites="billiard2016effect">Billiard et al. (<a href="#ref-billiard2016effect" role="doc-biblioref">2016</a>)</span>; <span class="citation" data-cites="lavallee2019stochastic">Lavallée et al. (<a href="#ref-lavallee2019stochastic" role="doc-biblioref">2019</a>)</span>; <span class="citation" data-cites="meleard2019birth">Méléard, Rera, and Roget (<a href="#ref-meleard2019birth" role="doc-biblioref">2019</a>)</span>; <span class="citation" data-cites="calvez2020horizontal">Calvez et al. (<a href="#ref-calvez2020horizontal" role="doc-biblioref">2020</a>)</span>), after the pioneer works&nbsp;<span class="citation" data-cites="FouMel04 tran_2008 meleard2009trait">(<a href="#ref-FouMel04" role="doc-biblioref">Fournier and Méléard 2004</a>; <a href="#ref-tran_2008" role="doc-biblioref">Tran 2008</a>; <a href="#ref-meleard2009trait" role="doc-biblioref">Méléard and Tran 2009</a>)</span>. IBMs are also useful in demography and actuarial sciences, for the modeling of human populations dynamics (see e.g. <span class="citation" data-cites="Ben10">Bensusan (<a href="#ref-Ben10" role="doc-biblioref">2010</a>)</span>; <span class="citation" data-cites="Bou16">Boumezoued (<a href="#ref-Bou16" role="doc-biblioref">2016</a>)</span>; <span class="citation" data-cites="karoui2021simulating">El Karoui, Hadji, and Kaakai (<a href="#ref-karoui2021simulating" role="doc-biblioref">2021</a>)</span>).</p>
<p>Indeed, they allow the modeling of heterogeneous and complex population dynamics, which can be used to compute demographic indicators or simulate the evolution of insurance portfolios in order to study the basis risk, compute cash flows for annuity products or pension schemes, or for a fine assessment of mortality models <span class="citation" data-cites="barrieu2012understanding">(<a href="#ref-barrieu2012understanding" role="doc-biblioref">Barrieu et al. 2012</a>)</span>. There are other domains in which stochastic IBMs can be used, for example in epidemiology with stochastic compartmental models, neurosciences, cyber risk, or Agent-Based Models (ABMs) in economy and social sciences, which can be seen as IBMs. Many mathematical results have been obtained in the literature cited above, for quantifying the limit behaviors of IBMs over long time scales or in large population. In particular, pathwise representations of IBMs have been introduced in <span class="citation" data-cites="FouMel04">Fournier and Méléard (<a href="#ref-FouMel04" role="doc-biblioref">2004</a>)</span> (and extended to age-structured populations in <span class="citation" data-cites="tran_2008">Tran (<a href="#ref-tran_2008" role="doc-biblioref">2008</a>)</span>; <span class="citation" data-cites="meleard2009trait">Méléard and Tran (<a href="#ref-meleard2009trait" role="doc-biblioref">2009</a>)</span>), as measure-valued pure jumps Markov processes, solutions of SDEs driven by Poisson measures. These pathwise representations are based on the <em>thinning</em> and projection of Poisson random measures defined on extended spaces. However, the simulation of large and interacting populations is often computationally expensive.</p>
<p>The aim of the <code>R</code> package <code>IBMPopSim</code> is to meet the needs of the various communities for efficient tools in order to simulate the evolution of stochastic IBMs. <code>IBMPopSim</code> provides a general framework for the simulation of a wide class of IBMs, where individuals are characterized by their age and/or a set of characteristics. Different types of events can be included in the modeling by users, depending on their needs: births, deaths, entry or exit in/to the population and changes of characteristics (swap events). Furthermore, the various events that can happen to individuals in the population can occur at a non-stationary frequency, depending on the individuals’ characteristics and time, and also including potential interactions between individuals.</p>
<p>We introduce a unified mathematical and simulation framework for this class of IBMs, generalizing the pathwise representation of IBMs by thinning of Poisson measures, as well as the associated population simulation algorithm, based on an acceptance/rejection procedure. In particular, we provide general sufficient conditions on the event intensities under which the simulation of a particular model is possible.</p>
<p>We opted to implement the algorithms of the <code>IBMPopSim</code> package using the <code>Rcpp</code> package, a tool facilitating the seamless integration of high-performance <code>C++</code> code into easily callable <code>R</code> functions <span class="citation" data-cites="JSSv040i08">(<a href="#ref-JSSv040i08" role="doc-biblioref">Eddelbuettel and Francois 2011</a>)</span>. <code>IBMPopSim</code> offers user-friendly R functions for defining and simulating IBMs. Once events and their associated intensities are specified, an automated procedure creates the model. This involves integrating the user’s source code into the primary <code>C++</code> code using a template mechanism. Subsequently, <code>Rcpp</code> is invoked to compile the model so that the model is integrated into the <code>R</code> session and callable with varying parameters, enabling the generation of diverse population evolution scenarios. Combined with the design of the simulation algorithms, the package structure yields very competitive simulation runtimes for IBMs, while staying user-friendly for <code>R</code> users. Several outputs function are also implemented in <code>IBMPopSim</code>. For instance the package allows the construction and visualization of age pyramids, as well as the construction of death and exposures table from the censored individual data, compatible with <code>R</code> packages concerned with mortality modelling, such as <span class="citation" data-cites="Rdemography">Hyndman et al. (<a href="#ref-Rdemography" role="doc-biblioref">2023</a>)</span> or <span class="citation" data-cites="Rstmomo">A. Villegas, Millossovich, and Kaishev Hyndman (<a href="#ref-Rstmomo" role="doc-biblioref">2018</a>)</span>. Several examples are provided in the form of <code>R</code> vignettes on the <a href="https://daphnegiorgi.github.io/IBMPopSim/">website</a>, and in recent works of <span class="citation" data-cites="karoui2021simulating">El Karoui, Hadji, and Kaakai (<a href="#ref-karoui2021simulating" role="doc-biblioref">2021</a>)</span> and <span class="citation" data-cites="roget2022positive">Roget et al. (<a href="#ref-roget2022positive" role="doc-biblioref">2024</a>)</span>.</p>
<p>To the best of our knowledge, there are no other <code>R</code> packages currently available addressing the issue of stochastic IBMs efficient simulation. Another approach for simulating populations is continuous time microsimulation in social sciences, which is implemented in the <code>R</code> package <code>MicSim</code>&nbsp;<span class="citation" data-cites="Zin14">(<a href="#ref-Zin14" role="doc-biblioref">Zinn 2014</a>)</span>. In this framework, individual life-courses are specified by sequences of state transitions (events) and the time spans between these transitions. The state space is usually discrete and finite, which is not necessarily the case in <code>IBMPopSim</code>, where individuals can have continuous characteristics. But most importantly, microsimulation does not allow for interactions between individuals. Indeed, microsimulation produces separately the life courses of all individuals in the populations, based on the computation of the distribution functions of the waiting times in the distinct states of the state space, for each individual <span class="citation" data-cites="Zin14">(<a href="#ref-Zin14" role="doc-biblioref">Zinn 2014</a>)</span>. This can be slow in comparison to the simulation by thinning of event times occurring in the population, which is based on selecting event times among some competing proposed event times. Finally, <code>MicSim</code> simplifies the Mic-Core microsimulation tool implemented in Java <span class="citation" data-cites="zinn2009mic">(<a href="#ref-zinn2009mic" role="doc-biblioref">Zinn et al. 2009</a>)</span>. However, the implementation in <code>R</code> of simulation algorithms yields longer simulation run times than when using <code>Rcpp</code>.</p>
<p>In <a href="#sec-overview" class="quarto-xref">Section&nbsp;2</a>, we give a short description of Stochastic Individual-Based Models (IBMs) and a quick example of model implementation with the <code>IBMPopSim</code> package. In <a href="#sec-math" class="quarto-xref">Section&nbsp;3</a>, we introduce the mathematical framework that characterizes the class of IBMs that can be implemented in the <code>IBMPopSim</code> package. In particular, a general pathwise representation of IBMs is presented. The population dynamics is obtained as the solution of an SDE driven by Poisson measures, for which we obtain existence and uniqueness results in <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a>. In <a href="#sec-simulation" class="quarto-xref">Section&nbsp;4</a> the two main algorithms for simulating the population evolution of an IBM across the interval <span class="math inline">[0, T]</span> are detailed. In <a href="#sec-package" class="quarto-xref">Section&nbsp;5</a> we present the main functions of the <code>IBMPopSim</code> package, which allow for the definition of events and their intensities, the creation of a model, and the simulation of scenarios. Two examples are detailed in <a href="#sec-insurance-portfolio" class="quarto-xref">Section&nbsp;6</a> and <a href="#sec-example-interaction" class="quarto-xref">Section&nbsp;7</a>, featuring applications involving an heterogeneous insurance portfolio characterized by entry and exit events, and an age and size-structured population with intricate interactions.</p>
</section>
<section id="sec-overview" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Brief overview of IBMPopSim</h1>
<p>Stochastic Individual-Based Models (IBMs) represent a broad class of random population dynamics models, allowing the description of population evolution on an individual scale. Informally, an IBM can be summarized by the description of the individuals constituting the population, the various types of events that can occur to these individuals, along with their respective frequencies. In <code>IBMPopSim</code>, individuals can be characterized by their age and/or a collection of discrete or continuous characteristics. Moreover, the package enables users to simulate efficiently populations in which one or more of the following event types may occur:</p>
<ul>
<li><strong>Birth event</strong>: addition of an individual of age 0 to the population.</li>
<li><strong>Death event</strong>: removal of an individual from the population.</li>
<li><strong>Entry event</strong>: arrival of an individual in the population.</li>
<li><strong>Exit (emigration) event</strong>: exit from the population (other than death).</li>
<li><strong>Swap event</strong>: an individual changes characteristics.</li>
</ul>
<p>Each event type is linked to an associated event kernel, describing how the population is modified following the occurrence of the event. For some event types, the event kernel requires explicit specification. This is the case for entry events when a new individual joins the population, which requires to specify the age and characteristics of this new individual. For instance, the characteristics of a new individual in the population can be chosen uniformly in the space of all characteristics, or can depend on the distribution of his parents or those of the other individuals composing the population.</p>
<p>The last component of an IBM are the event intensities. Informally, an event intensity is a function <span class="math inline">\lambda^e_t(I, Z)</span> describing the frequency at which an event <span class="math inline">e</span> can occur to an individual <span class="math inline">I</span> in a population <span class="math inline">Z</span> at a time <span class="math inline">t</span>. Given a history of the population <span class="math inline">(\mathcal{F}_t)</span>, the probability of event <span class="math inline">e</span> occurring to individual <span class="math inline">I</span> during a small interval of time <span class="math inline">(t,t+dt]</span> is proportional to <span class="math inline">\lambda^e(I,t)</span>: <span class="math display">
    \mathbb{P}(\text{event } e \text{ occurring to $I$ during } (t,t+dt] | \mathcal{F}_t) \simeq \lambda^e_t(I, Z)dt.
</span></p>
<p>The intensity function <span class="math inline">\lambda^e</span> can include various dependencies:</p>
<ul>
<li><strong>individual intensity</strong>: <span class="math inline">\lambda^e</span> depends only on the individual’s <span class="math inline">I</span> age and characteristics, and time <span class="math inline">t</span>,</li>
<li><strong>interaction intensity</strong>: in addition <span class="math inline">\lambda^e</span> depends on the population composition <span class="math inline">Z</span>.</li>
</ul>
<p>Prior to providing a detailed description of an Individual-Based Model (IBM), we present a simple model of birth and death in an age-structured <em>human</em> population. We assume no interactions between individuals, and individuals are characterized by their gender, in addition to their age. In this simple model, all individuals, regardless of gender, can give birth when their age falls between 15 and 40 years, with a constant birth rate of 0.05. The death intensity is assumed to follow a Gompertz-type intensity depending on age. The birth and death intensities are then given by<br>
<span class="math display">\begin{equation*}
    \lambda^b(t, I) = 0.05 \times \mathbf{1}_{[15,40]}(a(I,t)), \quad
    \lambda^d(t, I) = \alpha\exp(\beta a(I,t)),
\end{equation*}</span> with <span class="math inline">a(I,t)</span> the age of individual <span class="math inline">I</span> at time <span class="math inline">t</span>. Birth events are also characterized with a kernel determining the gender of the newborn, who is male with probability <span class="math inline">p_{male}</span>.</p>
<section id="model-creation" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="model-creation"><span class="header-section-number">2.1</span> Model creation</h2>
<p>All models in <code>IBMPopSim</code> are created with a call to the <code>mk_model</code> function, which takes the list of events as an argument. In this example, the events are created with the <code>mk_event_individual</code> function, involving a few lines of <code>cpp</code> instructions defining the intensity and, if applicable, the kernel of the event. For a more in depth description of the event creation step and its parameters, we refer to <a href="#sec-package-events" class="quarto-xref">Section&nbsp;5.2</a>.</p>
<p>The events of this simple model are for example defined through the following calls.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>, </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = birth_rate(I.age(t));"</span>,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"newI.male = CUnif(0,1) &lt; p_male;"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha * exp(beta * I.age(t));"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In the <code>cpp</code> codes, the names <code>birth_rate</code>, <code>p_male</code>, <code>alpha</code> and <code>beta</code> refer to the model parameters defined in the following list.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fl">0.008</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">0.02</span>, </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"p_male"</span> <span class="ot">=</span> <span class="fl">0.51</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_rate"</span> <span class="ot">=</span> <span class="fu">stepfun</span>(<span class="fu">c</span>(<span class="dv">15</span>, <span class="dv">40</span>), <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.05</span>, <span class="dv">0</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In a second step, the model is created by calling the function <code>mk_model</code>. A <code>cpp</code> source code is automatically created through a template mechanism based on the events and parameters, subsequently compiled using the <code>sourceCpp</code> function from the <code>Rcpp</code> package.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>birth_death_model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">characteristics =</span> <span class="fu">c</span>(<span class="st">"male"</span> <span class="ot">=</span> <span class="st">"bool"</span>),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">events =</span> <span class="fu">list</span>(death_event, birth_event),</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="simulation" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="simulation"><span class="header-section-number">2.2</span> Simulation</h2>
<p>Once the model is created and compiled, the <code>popsim</code> function is called to simulate the evolution of a population according to this model. To achieve this, an initial population must be defined. In this example, we extract a population from a dataset specified in the package (a sample of <span class="math inline">100\,000</span> individuals based on the population of England and Wales in 2014). It is also necessary to set bounds for the events intensities. In this example, they are obtained by assuming that the maximum age for an individual is 115 years.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>a_max <span class="ot">&lt;-</span> <span class="dv">115</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>events_bounds <span class="ot">=</span> <span class="fu">c</span>(</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> params<span class="sc">$</span>alpha <span class="sc">*</span> <span class="fu">exp</span>(params<span class="sc">$</span>beta <span class="sc">*</span> a_max),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">max</span>(params<span class="sc">$</span>birth_rate))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The function <code>popsim</code> can now be called to simulate the population starting from the initial population <code>population(EW_pop_14$sample)</code> up to time <span class="math inline">T = 30</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  birth_death_model, </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample), </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  events_bounds, </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params, <span class="at">age_max =</span> a_max, </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">time =</span> <span class="dv">30</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The data frame <code>sim_out$population</code> contains the information (birth, death, gender) on individuals who lived in the population over the period <span class="math inline">[0,30]</span>. Functions of the package allows to provide aggregated information on the population.</p>
</section>
</section>
<section id="sec-math" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Mathematical framework</h1>
<p>In this section, we define rigorously the class of IBMs that can be simulated in <code>IBMPopSim</code>, along with the assumptions that are required in order for the population to be simulatable. The representation of age-structured IBMs based on measure-valued processes, as introduced in <span class="citation" data-cites="tran_2008">Tran (<a href="#ref-tran_2008" role="doc-biblioref">2008</a>)</span>, is generalized to a wider class of abstract population dynamics. The modeling differs slightly here, since individuals are <em>kept in the population</em> after their death (or exit), by including the death/exit date as an individual trait.</p>
<p>In the remainder of the paper, the filtered probability space is denoted by <span class="math inline">(\Omega,\{\mathcal{F}_t \},{\mathbb{P}})</span>, under the usual assumptions. All processes are assumed to be càdlàg and adapted to the filtration <span class="math inline">\{\mathcal{F}_t \}</span> (for instance the history of the population) on a time interval <span class="math inline">[0,T]</span>. For a càdlàg process <span class="math inline">X</span>, we denote <span class="math inline">X_{t^-} := \lim_{\genfrac{}{}{0pt}{2}{s\to t}{s&lt;t}} X_s</span>.</p>
<section id="sec-population" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-population"><span class="header-section-number">3.1</span> Population</h2>
<p>As mentioned in <a href="#sec-overview" class="quarto-xref">Section&nbsp;2</a> a population is a collection of individuals whose evolution defines the population process.</p>
<section id="individuals" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="individuals"><span class="header-section-number">3.1.1</span> Individuals</h3>
<p>An individual is represented by a triplet <span class="math inline">I = (\tau^b, \tau^d, x) \in \mathcal{I}= {\mathbb{R}}\times \bar {\mathbb{R}}\times {\mathcal{X}}</span> with:</p>
<ul>
<li><span class="math inline">\tau^b \in {\mathbb{R}}</span> the date of birth,</li>
<li><span class="math inline">\tau^d \in \bar {\mathbb{R}}</span> the death date, with <span class="math inline">\tau^d = \infty</span> if the individual is still alive,</li>
<li>a collection <span class="math inline">x \in {\mathcal{X}}</span> of characteristics where <span class="math inline">{\mathcal{X}}</span> is the space of characteristics.</li>
</ul>
<p>Note that in IBMs, individuals are usually characterized by their age <span class="math inline">a(t) =t-\tau^b</span> instead of their date of birth <span class="math inline">\tau^b</span>. However, using the latter is actually easier for the simulation, as it remains constant over time.</p>
</section>
<section id="population-process" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="population-process"><span class="header-section-number">3.1.2</span> Population process</h3>
<p>The population at a given time <span class="math inline">t</span> is a random set <span class="math display">
    Z_t=\{ I_k \in \mathcal{I}; \; k= 1,\dots, N_t\},
</span> composed of all individuals (alive or dead) who have lived in the population before time <span class="math inline">t</span>. As a random set, <span class="math inline">Z_t</span> can be represented by a random counting measure on <span class="math inline">\mathcal{I}</span> , that is an integer-valued measure <span class="math inline">Z: \Omega \times \mathcal{I}\to \bar {\mathbb{N}}</span> where for <span class="math inline">A \in \mathcal{I}</span>, <span class="math inline">Z(A)</span> is the (random) number of individuals <span class="math inline">I</span> in the subset <span class="math inline">A</span>. With this representation: <span id="eq-popZ"><span class="math display">
\begin{aligned}
    Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} \delta_{I_k} (\tau^b, \tau^d,x),  \\
    \text{ with }  \int_{\mathcal{I}} f(\tau^b, \tau^d, x) Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} f(I_k).
\end{aligned}
\tag{1}</span></span></p>
<p>The number of individuals present in the population <em>before time</em> <span class="math inline">t</span> is obtained by taking <span class="math inline">f\equiv 1</span>: <span class="math display">
    N_t =  \int_{\mathcal{I}}  Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \mathbf{1}_{\mathcal{I}} (I_k).
</span> Note that <span class="math inline">(N_t)_{t\geq 0}</span> is an increasing process since dead/exited individuals are kept in the population <span class="math inline">Z</span>. The number of alive individuals in the population at time <span class="math inline">t</span> is: <span id="eq-Nta"><span class="math display">
    N_t^a =  \int_{\mathcal{I}}  \mathbf{1}_{\{\tau^d &gt; t \} }Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \mathbf{1}_{\{\tau^d_k &gt; t \} }.
\tag{2}</span></span> Another example is the number of alive individuals of age over <span class="math inline">a</span> is <span class="math display">
    N_t([a,+\infty)) :=  \int_{\mathcal{I}}  \mathbf{1}_{[a,+\infty)}(t-\tau^b)\mathbf{1}_{]t,\infty]}(\tau^d) Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t}  \mathbf{1}_{\{ t -\tau_k^b \geq a \}}\mathbf{1}_{\{\tau^d_k \geq t \} }.
</span></p>
</section>
</section>
<section id="sec-events" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-events"><span class="header-section-number">3.2</span> Events</h2>
<p>The population composition changes at random dates following different types of events. <code>IBMPopSim</code> allows the simulation of IBMs with the following events types:</p>
<ul>
<li><p>A <strong>birth</strong> event at time <span class="math inline">t</span> is the addition of a new individual <span class="math inline">I'=(t,\infty, X)</span> of age <span class="math inline">0</span> to the population. Their date of birth is <span class="math inline">\tau^b =t</span>, and characteristics is <span class="math inline">X</span>, a random variable of distribution defined by the birth kernel <span class="math inline">k^b(t,I,\mathrm{d}x)</span> on <span class="math inline">{\mathcal{X}}</span>, depending on <span class="math inline">t</span> and its parent <span class="math inline">I</span>. The population size becomes <span class="math inline">N_t = N_{t^-} + 1</span>, and the population composition after the event is <span class="math display">Z_t  = Z_{t^-} +  \delta_{(t,\infty, X)}.</span></p></li>
<li><p>An <strong>entry</strong> event at time <span class="math inline">t</span> is also the addition of an individual <span class="math inline">I'</span> in the population. However, this individual is not of age <span class="math inline">0</span>. The date of birth and characteristics of the new individual <span class="math inline">I'= (\tau^b, \infty, X)</span> are random variables of probability distribution defined by the entry kernel <span class="math inline">k^{en}(t, \mathrm{d}s, \mathrm{d}x)</span> on <span class="math inline">{\mathbb{R}}\times {\mathcal{X}}</span>. The population size becomes <span class="math inline">N_t = N_{t^-} + 1</span>, and the population composition after the event is: <span class="math display">
  Z_t  = Z_{t^-} +  \delta_{(\tau^b, \infty, X)}.
</span></p></li>
<li><p>A <strong>death</strong> or <strong>exit</strong> event of an individual <span class="math inline">I= (\tau^b,\infty, x)\in Z_{t^-}</span> at time <span class="math inline">t</span> is the modification of its death date <span class="math inline">\tau^d</span> from <span class="math inline">+\infty</span> to <span class="math inline">t</span>. This event results in the simultaneous addition of the individual <span class="math inline">(\tau^b,t,x)</span> and removal of the individual <span class="math inline">I</span> from the population. The population size is not modified, and the population composition after the event is <span class="math display">
  Z_t  = Z_{t^-} +\delta_{(\tau^b,t,x)}- \delta_{I}.
</span></p></li>
<li><p>A <strong>swap</strong> event (change of characteristics) results in the simultaneous addition and removal of an individual. If an individual <span class="math inline">I= (\tau^b,\infty, x) \in Z_{t^-}</span> changes of characteristics at time <span class="math inline">t</span>, then it is removed from the population and replaced by <span class="math inline">I' = (\tau^b,\infty, X)</span>. The new characteristics <span class="math inline">X</span> is a random variable of distribution <span class="math inline">k^s(t, I,\mathrm{d}x)</span> on <span class="math inline">{\mathcal{X}}</span>, depending on time, the individual’s age and previous characteristics <span class="math inline">x</span>. In this case, the population size is not modified and the population becomes: <span class="math display">
  Z_t  = Z_{t^-}   +  \delta_{(\tau^b,  \infty, X)} -  \delta_{(\tau^b, \infty, x)}.
</span></p></li>
</ul>
<p>To summarize, the space of event types is <span class="math inline">E = \{ b, en, d, s \}</span>, and the jump <span class="math inline">\Delta Z_t = Z_t - Z_{t^-}</span> (change in the population composition) generated by an event of type <span class="math inline">e \in \{ b, en, d, s \}</span> is denoted by <span class="math inline">\phi^e(t, I)</span>. We thus have the following rules summarized in <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>.</p>
<div id="tbl-event-action" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-event-action-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Action in the population for a given event type
</figcaption>
<div aria-describedby="tbl-event-action-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<colgroup>
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 37%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Event</th>
<th style="text-align: center;">Type</th>
<th><span class="math inline">\phi^e(t, I)</span></th>
<th>New individual</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Birth</td>
<td style="text-align: center;"><span class="math inline">b</span></td>
<td><span class="math inline">\delta_{(t, \infty,  X)}</span></td>
<td><span class="math inline">\tau^b =t, \; X \sim k^b(t,I,\mathrm{d}x)</span></td>
</tr>
<tr class="even">
<td>Entry</td>
<td style="text-align: center;"><span class="math inline">en</span></td>
<td><span class="math inline">\delta_{(\tau^b, \infty,  X)}</span></td>
<td><span class="math inline">(\tau^b, X) \sim k^{en}(t,\mathrm{d}s, \mathrm{d}x)</span></td>
</tr>
<tr class="odd">
<td>Death/Exit</td>
<td style="text-align: center;"><span class="math inline">d</span></td>
<td><span class="math inline">\delta_{(\tau^b, t,x)} - \delta_{(\tau^b, \infty, x)}</span></td>
<td><span class="math inline">\tau^d = t</span></td>
</tr>
<tr class="even">
<td>Swap</td>
<td style="text-align: center;"><span class="math inline">s</span></td>
<td><span class="math inline">\delta_{(\tau^b, \infty , X)} - \delta_{(\tau^b, \infty, x)}</span></td>
<td><span class="math inline">X \sim k^s(t,I,\mathrm{d}x)</span></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<div id="rem-popfinale" class="proof remark">
<p><span class="proof-title"><em>Remark 1</em> (Composition of the population). </span></p>
<ul>
<li>At time <span class="math inline">T</span>, the population <span class="math inline">Z_T</span> contains all individuals who lived in the population before <span class="math inline">T</span>, including dead/exited individuals. If there are no swap events, or entries, the population state <span class="math inline">Z_t</span> for any time <span class="math inline">t\leq T</span> can be obtained from <span class="math inline">Z_T</span>. Indeed, if <span class="math inline">Z_T = \sum_{k=1}^{N_T}  \delta_{I_k}</span>, then the population at time <span class="math inline">t\leq T</span> is simply composed of the individuals born before <span class="math inline">t</span>: <span class="math display">
  Z_t = \sum_{k=1}^{N_T} \mathbf{1}_{\{\tau^b_k \leq t \}} \delta_{I_k}.
</span></li>
<li>In the presence of entries (open population), a characteristic <span class="math inline">x</span> can track the individuals’ entry dates. Then, the previous equation can be easily modified in order to obtain the population <span class="math inline">Z_t</span> at time <span class="math inline">t\leq T</span> from <span class="math inline">Z_T</span>.</li>
</ul>
</div>
</section>
<section id="sec-event-intensity" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-event-intensity"><span class="header-section-number">3.3</span> Events intensity</h2>
<p>Once the different event types have been defined in the population model, the frequency at which each event <span class="math inline">e</span> occurs in the population has to be specified. Informally, the intensity <span class="math inline">\Lambda^e_t(Z_t)</span> at which an event <span class="math inline">e</span> can occur is defined by <span class="math display">
    \mathbb P\big( \text{event } e \text { occurs in the population }  Z_t  \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \Lambda^e_t (Z_t)\mathrm{d}t.
</span> For a more formal definition of stochastic intensities, we refer to <span class="citation" data-cites="bremaud1981point">Brémaud (<a href="#ref-bremaud1981point" role="doc-biblioref">1981</a>)</span> or <span class="citation" data-cites="KaaElK20">Kaakai and El Karoui (<a href="#ref-KaaElK20" role="doc-biblioref">2023</a>)</span>. The form of the intensity function <span class="math inline">(\Lambda^e_t (Z_t))</span> determines the population simulation algorithm in <code>IBMPopSim</code>:</p>
<ul>
<li>When the event intensity does not depend on the population state, <span id="eq-poisson-intensity"><span class="math display">
  \big(\Lambda^e_t (Z_t)\big)_{t\in [0,T]} = \big(\mu^e(t)\big)_{t \in [0,T]},
\tag{3}</span></span> with <span class="math inline">\mu^e</span> a deterministic function, the events of type <span class="math inline">e</span> occur at the jump times of an inhomogeneous Poisson process of intensity function <span class="math inline">(\mu^e(t))_{t \in [0,T]}</span>. This is particularly useful when entry events occur with intensities influenced by environmental processes and/or exhibit seasonal variations. When such an event occurs, the individual to whom the event happens is drawn uniformly from the living individuals in the population. In a given model, the set of events <span class="math inline">e\in E</span> with Poisson intensities will be denoted by <span class="math inline">\mathcal{P}</span>.</li>
<li>Otherwise, we assume that the global intensity <span class="math inline">\Lambda^e_t(Z_t)</span> at which the events of type <span class="math inline">e</span> occur in the population can be written as the sum of individual intensities <span class="math inline">\lambda^e_t(I,Z_t)</span>: <span id="eq-global-intensity"><span class="math display">
\begin{aligned}
  &amp;\Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e_t ( I_k,Z_t),  \\
  &amp;  \text{with } \mathbb P\big( \text{event } e \text { occurs to an individual } I \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \lambda^e_t (I,Z_t)\mathrm{d}t.
\end{aligned}
\tag{4}</span></span></li>
</ul>
<p>Obviously, nothing can happen to dead or exited individuals, i.e.&nbsp;individuals <span class="math inline">I= (\tau^b, \tau^d, x)</span> with <span class="math inline">\tau^d \leq t</span>. Thus, individual event intensities are assumed to be null for dead/exited individuals: <span class="math display">
    \lambda^e_t ( I,Z_t) = 0, \text{ if }\tau^d \leq t, \text{ so that } \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t^a} \lambda^e_t ( I_k,Z_t),
</span> with <span class="math inline">N^a_t</span> the number of alive individuals at time <span class="math inline">t</span>.</p>
<p>The event’s individual intensity <span class="math inline">\lambda^e_t (I,Z_t)</span> can depend on time (for instance when there is a mortality reduction over time), on the individual’s age <span class="math inline">t-\tau^b</span> and characteristics, but also on the population composition <span class="math inline">Z_t</span>. The dependence of <span class="math inline">\lambda^e</span> on the population <span class="math inline">Z</span> models interactions between individuals in the populations. Hence, two types of individual intensity functions can be implemented in <code>IBMPopSim</code>:</p>
<ol type="1">
<li><p><em>No interactions:</em> The intensity function <span class="math inline">\lambda^e</span> does not depend on the population composition. The intensity at which an event of type <span class="math inline">e</span> occurs to an individual <span class="math inline">I</span> only depends on its date of birth and characteristics: <span id="eq-intensity-no-interaction"><span class="math display">
\lambda^e_t (I,Z_t) = \lambda^e(t, I),
\tag{5}</span></span> where <span class="math inline">\lambda^e: \mathbb{R}_+ \times \mathcal{I}\to {\mathbb{R}}^+</span> is a deterministic function. In a given model, we denote by <span class="math inline">\mathcal{E}</span> the set of event types with individual intensity <a href="#eq-intensity-no-interaction" class="quarto-xref">Equation&nbsp;5</a>.</p></li>
<li><p><em>“Quadratic” interactions:</em> The intensity at which an event of type <span class="math inline">e</span> occurs to an individual <span class="math inline">I</span> depends on <span class="math inline">I</span> and on the population composition, through an interaction function <span class="math inline">W^e</span>. The quantity <span class="math inline">W^e(t, I,J)</span> describes the intensity of interactions between two alive individuals <span class="math inline">I</span> and <span class="math inline">J</span> at time <span class="math inline">t</span>, for instance in the presence of competition or cooperation. In this case, we have <span id="eq-intensity-interaction"><span class="math display">
\lambda^e_t(I,Z_t)=\sum_{j=1}^{N_t} W^e(t, I, I_j) = \int_{\mathcal{I}} W^e(t, I, (\tau^b,\tau^d,x)) Z_t (\mathrm{d}\tau^b,\mathrm{d}\tau^d, \mathrm{d}x),
\tag{6}</span></span> where <span class="math inline">W^e(t, I, (\tau^b,\tau^d,x))  = 0</span> if the individual <span class="math inline">J =(\tau^b,\tau^d,x)</span> is dead, i.e.&nbsp;<span class="math inline">\tau^d \leq t</span>.&nbsp;In a given model, we denote by <span class="math inline">\mathcal{E}_W</span> the set of event types with individual intensity <a href="#eq-intensity-interaction" class="quarto-xref">Equation&nbsp;6</a>.</p></li>
</ol>
<p>To summarize, an individual intensity in IBMPopSim can be written as: <span id="eq-individual-intensity"><span class="math display">
    \lambda^e_t(I,Z_t) = \lambda^e(t, I) \mathbf{1}_{\{e \in \mathcal{E}\}} + \biggl( \sum_{j=1}^{N_t} W^e(t, I, I_j) \biggr) \mathbf{1}_{\{e \in \mathcal{E}_W\}}.
\tag{7}</span></span></p>
<div id="exm-popfinale" class="theorem example">
<p><span class="theorem-title"><strong>Example 1</strong></span> &nbsp;</p>
<ol type="1">
<li><p>An example of death intensity without interaction for an individual <span class="math inline">I=(\tau^b, \tau^d, x)</span> alive at time <span class="math inline">t</span>, <span class="math inline">t &lt; \tau^d</span>, is: <span class="math display">
\lambda^d(t,I) =  \alpha_x \exp(\beta_x a(I,t)), \text{ where }  a(I,t) = t-\tau^b
</span> is the age of the individual <span class="math inline">I</span> at time <span class="math inline">t</span>. In this standard case, the death rate of an individual <span class="math inline">I</span> is an exponential (Gompertz) function of the individual’s age, with coefficients depending on the individual’s characteristics <span class="math inline">x</span>.</p></li>
<li><p>In the presence of competition between individuals, the death intensity of an individual <span class="math inline">I</span> also depends on other individuals <span class="math inline">J</span> in the population. For example, if <span class="math inline">I=(\tau^b,\tau^d, x)</span>, with its size <span class="math inline">x</span>, then we have: <span id="eq-ex-interaction"><span class="math display">
W^d(t,I,J) = (x_J - x)^+ \mathbf{1}_{\{\tau^d_J &gt; t\}}, \quad \forall \; J=(\tau^b_J,\tau^d_J , x_J).
\tag{8}</span></span> This can be interpreted as follows: if the individual <span class="math inline">I</span> meets randomly an individual <span class="math inline">J</span> alive at time <span class="math inline">t</span>, and of bigger size <span class="math inline">x_J &gt; x</span>, then he can die at the intensity <span class="math inline">x_J-x</span>. If <span class="math inline">J</span> is smaller than <span class="math inline">I</span>, then it cannot kill <span class="math inline">I</span>. The bigger is the size <span class="math inline">x</span> of <span class="math inline">I</span>, the lower is its death intensity <span class="math inline">\lambda^d_t(I,Z_t)</span> defined by <span class="math display">
\lambda^d_t(I,Z_t) = \sum_{\genfrac{}{}{0pt}{2}{J\in Z_t,}{x_J &gt; x}} (x_J -x)\mathbf{1}_{\{\tau^d_J &gt; t\}}.
</span></p></li>
<li><p><code>IBMPopSim</code> can simulate IBMs that include intensities expressed as a sum of Poisson intensities and individual intensities of the form <span class="math inline">\Lambda^e(Z_t) =\mu^e_t + \sum_{k=1}^{N_t} \lambda^e(I_k, Z_t)</span>. Other examples are provided in <a href="#sec-insurance-portfolio" class="quarto-xref">Section&nbsp;6</a> and <a href="#sec-example-interaction" class="quarto-xref">Section&nbsp;7</a>.</p></li>
</ol>
<p>Finally, the global intensity at which an event can occur in the population is defined by: <span id="eq-global-ev-intensity"><span class="math display">
    \Lambda_t(Z_t) = \sum_{e\in \mathcal{P}} \mu^e(t) + \sum_{e \in \mathcal E} \Big(\sum_{k=1}^{N_t} \lambda^e(t, I_k)\Big) + \sum_{e \in \mathcal E_W} \Big(\sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)\Big).
\tag{9}</span></span> An important point is that for events <span class="math inline">e \in \mathcal E</span> without interactions, the global event intensity <span class="math inline">\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I_k)</span> is <em>of order</em> <span class="math inline">N_t^a</span> defined in <a href="#eq-Nta" class="quarto-xref">Equation&nbsp;2</a> (number of alive individuals at time <span class="math inline">t</span>). On the other hand, for events <span class="math inline">e \in \mathcal{E}_W</span> with interactions, <span class="math inline">\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)</span> is of order <span class="math inline">(N_t^a)^2</span>. Informally, this means that when the population size increases, events with interaction are more costly to simulate. Furthermore, the numerous computations of the interaction kernel <span class="math inline">W^e</span> can also be computationally costly. The randomized <a href="#alg-randomized" class="quarto-xref">Algorithm 3</a>, detailed in <a href="#sec-simulation-randomized" class="quarto-xref">Section&nbsp;4.3</a>, allows us to overcome these limitations.</p>
</div>
<section id="events-intensity-bounds" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="events-intensity-bounds">Events intensity bounds</h3>
<p>The simulation algorithms implemented in <code>IBMPopSim</code> are based on an acceptance/rejection procedure, which requires the user to specify bounds for the various events intensities <span class="math inline">\Lambda^e_t(Z_t)</span>. These bounds are defined differently depending on the expression of the intensity.</p>
<div id="cnj-intensity-poisson" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 1</strong></span> For all events <span class="math inline">e \in \mathcal{P}</span> with Poisson intensity (<a href="#eq-poisson-intensity" class="quarto-xref">Equation&nbsp;3</a>), the intensity is assumed to be bounded on <span class="math inline">[0,T]</span>: <span class="math display">
    \forall t \in [0,T], \quad \Lambda^e_t(Z_t) = \mu^e(t) \leq \bar \mu^e.
</span></p>
</div>
<p>When <span class="math inline">e \in \mathcal{E} \cup \mathcal{E}_W</span>, <span class="math inline">\Lambda^e_t(Z_t) =\sum_{k=1}^{N_t} \lambda^e_t(I_k,Z_t)</span>, assuming that <span class="math inline">\Lambda^e_t(Z_t)</span> is uniformly bounded is too restrictive since the event intensity depends on the population size. In this case, the assumption is made on the individual intensity <span class="math inline">\lambda^e</span> or on the interaction function <span class="math inline">W^e</span>, depending on the situation.</p>
<div id="cnj-intensity1" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 2</strong></span> For all event types <span class="math inline">e \in \mathcal{E}</span>, the associated individual event intensity <span class="math inline">\lambda^e</span> with no interactions (<a href="#eq-intensity-no-interaction" class="quarto-xref">Equation&nbsp;5</a>) is assumed to be uniformly bounded: <span class="math display">
    \lambda^e(t, I) \leq \bar \lambda^e, \quad \forall \;  t\in [0, T],  \;   I \in \mathcal{I}.
</span> In particular, <span id="eq-def-bar-Lambda"><span class="math display">
    \forall t \in [0,T], \quad \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I) \leq \bar \lambda^e  N_t .
\tag{10}</span></span></p>
</div>
<div id="cnj-intensity2" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 3</strong></span> For all event types <span class="math inline">e \in \mathcal{E}_W</span>, the associated interaction function <span class="math inline">W^e</span> is assumed to be uniformly bounded: <span class="math display">
    W^e(t, I, J) \leq \bar W^e, \quad \forall \; t\in [0,T], \;   I, J \in \mathcal{I}.
</span> In particular, <span class="math inline">\forall t \in [0,T]</span>, <span class="math display">
    \lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I, I_j)  \leq  \bar W^e N_t, \quad \text{and} \quad \Lambda^e_t (Z_t) \leq \bar W^e (N_t)^2.
</span></p>
</div>
<p><a href="#cnj-intensity-poisson" class="quarto-xref">Assumption&nbsp;1</a>, <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a> yield that events in the population occur with the global event intensity&nbsp;<span class="math inline">\Lambda_t(Z_t)</span>, given in <a href="#eq-global-ev-intensity" class="quarto-xref">Equation&nbsp;9</a>, which is dominated by a polynomial function in the population size: <span id="eq-def-bar-Lambda"><span class="math display">
    \Lambda_t(Z_t) \leq \bar \Lambda(N_t), \quad \text{with }  \bar \Lambda (n) = \sum_{e \in \mathcal{P}} \bar \mu^e + \sum_{e\in \mathcal{E}}\bar \lambda^e  n + \sum_{e \in \mathcal E_W} \bar W^e n^2.
\tag{11}</span></span> This bound is linear in the population size if there are no interactions, and quadratic if there at least is an event including interactions. This assumption is the key to the algorithms implemented in <code>IBMPopSim</code>. Before presenting the simulation algorithm, we close this section with a rigorous definition of an IBM, based on the pathwise representation of its dynamics as a Stochastic Differential Equation (SDE) driven by Poisson random measures.</p>
</section>
</section>
<section id="pathwise-representation-of-stochastic-ibm" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="pathwise-representation-of-stochastic-ibm"><span class="header-section-number">3.4</span> Pathwise representation of stochastic IBM</h2>
<p>Since the seminal paper of <span class="citation" data-cites="FouMel04">Fournier and Méléard (<a href="#ref-FouMel04" role="doc-biblioref">2004</a>)</span>, it has been shown that a stochastic IBM dynamics can be defined rigorously as the unique solution of an SDE driven by Poisson measures, under reasonable non explosion conditions. This representation has actually been proved only in particular case, for various models. We provide here a general mathematical framework.<br>
Some recalls on Poisson random measures are presented in the Appendix <a href="#sec-recall-poisson" class="quarto-xref">Section&nbsp;8.1</a>, and for more details on these representations of particular examples, we refer to the abundant literature on the subject (see <span class="citation" data-cites="bremaud1981point">Çinlar (<a href="#ref-Cin11" role="doc-biblioref">2011</a>)</span> and the references therein).</p>
<p>In the following we consider an individual-based stochastic population <span class="math inline">(Z_t)_{t\in [0,T]}</span>, keeping the notations introduced in <a href="#sec-events" class="quarto-xref">Section&nbsp;3.2</a> and <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;3.3</a> for the events and their intensities. In particular, the set of events types that define the population evolution is denoted by <span class="math inline">\mathcal{P} \cup \mathcal{E} \cup \mathcal{E}_W \subset E</span>, with <span class="math inline">\mathcal{P}\,</span> the set of events types with Poisson intensity verifying <a href="#cnj-intensity-poisson" class="quarto-xref">Assumption&nbsp;1</a>, <span class="math inline">\mathcal{E}</span> the set of events types with individual intensity and no interaction, verifying <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and finally <span class="math inline">\mathcal{E}_W</span> the set of event types with interactions, verifying <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>.</p>
<section id="non-explosion-criterion" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="non-explosion-criterion">Non-explosion criterion</h3>
<p>First, one has to ensure that the number of events occurring in the population will not explode in finite time, leading to an infinite simulation time. <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a> are not sufficient to guarantee the non explosion of the event number, due to the potential explosion of the population size in the presence of interactions. An example is the case when only birth events occur, with an intensity <span class="math inline">\Lambda^b_t(Z_t) = C_b (N_t^a)^2</span> (i.e.&nbsp;when <span class="math inline">W^b(t, I,J) =C_b</span>). Then, the number of alive individuals <span class="math inline">(N_t^a)_{t\geq 0}</span> is a well-known pure birth process of intensity function <span class="math inline">g(n) = C_b n^2</span> (intensity of moving from state <span class="math inline">n</span> to <span class="math inline">n+1</span>). This process explodes in finite time, since <span class="math inline">g</span> does not verify the necessary and sufficient non explosion criterion for pure birth Markov processes: <span class="math inline">\sum_{n=1}^\infty \frac{1}{g(n)} = \infty</span> (see e.g.&nbsp;Theorem 2.2 in <span class="citation" data-cites="BanMel15">(<a href="#ref-BanMel15" role="doc-biblioref">Bansaye and Méléard 2015</a>)</span>). There is thus an explosion in finite time of birth events.</p>
<p>This example shows that the important point for non explosion is to control the population size. We give below a general sufficient condition on birth and entry event intensities, in order for the population size to stay finite in finite time. This ensures that the number of events does not explode in finite time. Informally, the idea is to control the intensities by a pure birth intensity function verifying the non-explosion criterion.</p>
<div id="cnj-non-explosion" class="theorem conjecture">
<p><span class="theorem-title"><strong>Assumption 4</strong></span> Let <span class="math inline">e\in\{b, en\}</span> a birth or entry event type. If the intensity at which the events of type <span class="math inline">e</span> occur in the population are not Poissonian, i.e.&nbsp;<span class="math inline">e \in \mathcal{E} \cup \mathcal{E}_W</span>, then there exists a function <span class="math inline">f^e : {\mathbb{N}}\to (0, +\infty)</span>, such that <span class="math display">
    \sum_{n=1}^{\infty} \frac{1}{nf^e(n)} = \infty,
</span> and for all individual <span class="math inline">I \in \mathcal{I}</span> and population measure <span class="math inline">Z = \sum_{k=1}^{n} \delta_{I_k}</span> of size <span class="math inline">n</span>, <span class="math display">
    \lambda^e_t (I, Z) \leq f^e(n), \; \forall \; 0\leq t \leq T.
</span></p>
</div>
<div id="rem">
<p>If <span class="math inline">e \in \mathcal{E}</span>, <span class="math inline">\lambda_t^e(I,Z) = \lambda^e(t,I) \leq \bar{\lambda}^e</span> by the domination <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>, then <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> is always verified with <span class="math inline">f^e(n) = \bar{\lambda}^e</span>.</p>
</div>
<p><a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> yields that the global intensity <span class="math inline">\Lambda_t^e(\cdot)</span> of event <span class="math inline">e</span> is bounded by a function <span class="math inline">g^e</span> only depending on the population size: <span class="math display">
    \Lambda_t^e (Z) \leq g^e(n) := nf^e(n), \quad \text{with }\sum_{n=1}^{\infty} \frac{1}{g^e(n)} = \infty.
</span> If <span class="math inline">e\in \mathcal{P}\,</span> has a Poisson intensity, then <span class="math inline">\Lambda_t^e(Z) =\mu^e_t</span> always verifies the previous equation with <span class="math inline">g^e(n) = \bar \mu^e</span>.</p>
<p>Before introducing the IBM SDE, let us give an idea of the equation construction. Between two successive events, the population composition <span class="math inline">Z_t</span> stays constant, since the population process <span class="math inline">(Z_t)_{t \geq 0}</span> is a pure jump process. Furthermore, since each event type is characterized by an intensity function, the jumps occurring in the population can be represented by restriction and projection of a Poisson measure defined on a larger state space. More precisely, we introduce a random Poisson measure <span class="math inline">Q</span> on <span class="math inline">\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+</span>, with <span class="math inline">\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)</span>. <span class="math inline">Q</span> is composed of random quadruplets <span class="math inline">(\tau, k , e, \theta)</span>, where <span class="math inline">\tau</span> represents a potential event time for an individual <span class="math inline">I_k</span> and event type <span class="math inline">e</span>. The last variable <span class="math inline">\theta</span> is used to accept/reject this proposed event, depending on the event intensity. Hence, the Poisson measure is restricted to a certain random set and then projected on the space of interest <span class="math inline">{\mathbb{R}}^+ \times \mathcal{J}</span>. If the event is accepted, then a jump <span class="math inline">\phi^e(\tau,I_k)</span> occurs.</p>
<div id="thm-eq-Z" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (Pathwise representation)</strong></span> Let <span class="math inline">T\in {\mathbb{R}}^+</span> and <span class="math inline">\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)</span>. Let <span class="math inline">Q</span> be a random Poisson measure on <span class="math inline">\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+</span>, of intensity <span class="math inline">\mathrm{d}t \delta_{\mathcal{J}}(\mathrm{d}k,\mathrm{d}e)  (\theta)\mathrm{d}\theta</span>, with <span class="math inline">\delta_{\mathcal{J}}</span> the counting measure on <span class="math inline">\mathcal{J}</span>. Finally, let <span class="math inline">Q^{\mathcal P}</span> be a random Poisson measure on <span class="math inline">\mathbb R^+ \times \mathcal{P}  \times \mathbb{R}^+</span>, of intensity <span class="math inline">\mathrm{d}t \delta_{\cal P}(\mathrm{d}e)\mathrm{d}\theta</span>, and <span class="math inline">Z_0= \sum_{k=1}^{N_0} \delta_{I_k}</span> an initial population. Then, under <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> , there exists a unique measure-valued population process <span class="math inline">Z</span>, strong solution on the following SDE driven by the Poisson measure <span class="math inline">Q</span>: <span id="eq-sde-eq-Z"><span class="math display">
    \begin{aligned}
    Z_t = Z_0 &amp;+ \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-})\}} Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ) \\
    &amp;+   \int_0^t \int_{\mathcal{P} \times \mathbb R^+}  \phi^e(s, I_{s^-}) \mathbf{1}_{\{\theta \leq \mu^e(s) \}} Q^{\mathcal{P}} (\mathrm{d}s ,\mathrm{d}e,  \mathrm{d}\theta),  \qquad \forall  0 \leq t \leq T,
\end{aligned}
\tag{12}</span></span> and where <span class="math inline">I_{s^-}</span> is an individual, chosen uniformly among alive individuals in the population <span class="math inline">Z_{s^-}</span>.</p>
</div>
<p>The proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a> is detailed in the Appendix, <a href="#sec-prf-thm-eq-Z" class="quarto-xref">Section&nbsp;8.2.1</a>. Note that <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> is an SDE describing the evolution of the IBM, the intensity of the events in the right hand side of the equation depending on the population process <span class="math inline">Z</span> itself. The main idea of the proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a> is to use the non explosion property of <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a>, and to write the r.h.s of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> as a sum of simple equations between two successive events, solved by induction.</p>
<div id="lem-non-explosion" class="theorem lemma">
<p><span class="theorem-title"><strong>Lemma 1</strong></span> Let <span class="math inline">Z</span> be a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">{\mathbb{R}}^+</span>, with <span class="math inline">(T_n)_{n\geq 0}</span> its jump times, <span class="math inline">T_0 = 0</span>. If <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a> is satisfied, then <span class="math display">
    \lim_{n \to \infty} T_n = \infty, \quad {\mathbb{P}}\text{-a.s.}
</span></p>
</div>
<p>The proof of <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a>, detailed in Appendix <a href="#sec-prf-lem-non-explosion" class="quarto-xref">Section&nbsp;8.2.2</a> is more technical and relies on a pathwise comparison result, generalizing those obtained in <span class="citation" data-cites="KaaElK20">(<a href="#ref-KaaElK20" role="doc-biblioref">Kaakai and El Karoui 2023</a>)</span>. An alternative pathwise representation of the population process, inspired by the randomized <a href="#alg-randomized" class="quarto-xref">Algorithm 3</a> is given as well in <a href="#prp-randomized" class="quarto-xref">Proposition&nbsp;3</a>.</p>
</section>
</section>
</section>
<section id="sec-simulation" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Population simulation</h1>
<p>We now present the main algorithm for simulating the evolution of an IBM over <span class="math inline">[0,T]</span>. The algorithm implemented in <code>IBMPopSim</code> allows the exact simulation of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>, based on an acceptance/reject algorithm for simulating random times called <em>thinning</em>. The exact simulation of event times with this acceptance/reject procedure is closely related to the simulations of inhomogeneous Poisson processes by the so-called thinning algorithm, often attributed to <span class="citation" data-cites="LewShe79">Lewis and Shedler (<a href="#ref-LewShe79" role="doc-biblioref">1979</a>)</span>. The simulation methods for inhomogeneous Poisson processes can be adapted to IBMs, and we introduce in this section a general algorithm extending those by <span class="citation" data-cites="FouMel04">Fournier and Méléard (<a href="#ref-FouMel04" role="doc-biblioref">2004</a>)</span> (see also <span class="citation" data-cites="FerTra09">Ferrière and Tran (<a href="#ref-FerTra09" role="doc-biblioref">2009</a>)</span>, <span class="citation" data-cites="Ben10">Bensusan (<a href="#ref-Ben10" role="doc-biblioref">2010</a>)</span>).</p>
<p>It can be noted that under appropriate rescaling and when the population size goes to infinity, an IBM can be approximated by a non linear transport PDE, structured by age and trait. A central limit theorem can also be obtained under appropriate assumptions <span class="citation" data-cites="tran_2008">(<a href="#ref-tran_2008" role="doc-biblioref">Tran 2008</a>)</span>. In the presence of interactions as in <a href="#sec-example-interaction" class="quarto-xref">Section&nbsp;7</a> for instance, the IBM goes almost surely to extinction in finite time, which is not the case for the limit PDE. In this case, simulating the microscopic process can be quite useful for approximating the distribution of the extinction time. Other applications of IBM simulations can include the simulation of multiscale population evolution, strongly heterogeneous populations, or small populations with strong interactions.</p>
<p>The algorithm is based on exponential “candidate” event times, chosen with a (constant) intensity which must be greater than the global event intensity <span class="math inline">\Lambda_t(Z_t)</span> (<a href="#eq-global-intensity" class="quarto-xref">Equation&nbsp;4</a>). Starting from time <span class="math inline">t</span>, once a candidate event time <span class="math inline">t + \bar T_\ell</span> has been proposed, a candidate event type <span class="math inline">e</span> (birth, death,...) is chosen with a probability <span class="math inline">p^e</span> depending on the event intensity bounds <span class="math inline">\bar \mu^e</span>, <span class="math inline">\bar \lambda^e</span> and <span class="math inline">\bar W^e</span>, as defined in <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>. An individual <span class="math inline">I</span> is then drawn from the population. Finally, it remains to accept or reject the candidate event with a probability <span class="math inline">q^e(t,I,Z_t)</span> depending on the true event intensity. If the candidate event time is accepted, then the event <span class="math inline">e</span> occurs at time <span class="math inline">t + \bar T_\ell</span> to the individual <span class="math inline">I</span>. The main idea of the implemented algorithm can be summarized as follows:</p>
<ol type="1">
<li>Draw a candidate time <span class="math inline">t + \bar T_\ell</span> and candidate event type <span class="math inline">e</span>.</li>
<li>Draw a uniform variable <span class="math inline">\theta \sim \mathcal{U}([0, 1])</span> and individual <span class="math inline">I</span>.</li>
<li><strong>If</strong> <span class="math inline">\theta \leq q^e(t,I,Z_t)</span> <strong>then</strong> event <span class="math inline">e</span> occur to individual <span class="math inline">I</span>, <strong>else</strong> Do nothing and start again from <span class="math inline">t + \bar T_\ell</span>.</li>
</ol>
<p>Before introducing the main algorithms in more details, we recall briefly the thinning procedure for simulating inhomogeneous Poisson processes, as well as the links with pathwise representations. Some recalls on Poisson random measures are presented in <a href="#sec-recall-poisson" class="quarto-xref">Section&nbsp;8.1</a>. For a more general presentation of thinning of a Poisson random measure, see <span class="citation" data-cites="Dev86 Cin11 Kal17">(<a href="#ref-Dev86" role="doc-biblioref">Devroye 1986</a>; <a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>; <a href="#ref-Kal17" role="doc-biblioref">Kallenberg 2017</a>)</span>.</p>
<section id="sec-thinning" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sec-thinning"><span class="header-section-number">4.1</span> Thinning of Poisson measure</h2>
<p>Let us start with the simulation and pathwise representation of an inhomogeneous Poisson process on <span class="math inline">[0,T]</span> with intensity <span class="math inline">(\Lambda(t))_{t\in [0,T]}</span>. The thinning procedure is based on the fundamental assumption that <span class="math inline">\Lambda(t) \leq  \bar \Lambda</span> is bounded on <span class="math inline">[0,T]</span>. In this case, the inhomogeneous Poisson can be obtained from an homogeneous Poisson process of intensity <span class="math inline">\bar \Lambda</span>, which can be simulated easily.</p>
<p>First, the Poisson process can be extended to a Marked Poisson measure <span class="math inline">\bar Q:= \sum_{\ell \ge 1} \delta_{(\bar T_\ell, \bar \Theta_\ell)}</span> on <span class="math inline">(\mathbb{R}^+)^2</span>, defined as follow:</p>
<ul>
<li><p>The jump times of <span class="math inline">(\bar T_\ell)_{\ell \ge 1}</span> of <span class="math inline">\bar Q</span> are the jump times of a Poisson process of intensity <span class="math inline">\bar \Lambda</span>.</p></li>
<li><p>The marks <span class="math inline">(\bar \Theta_\ell)_{\ell \ge 1}</span> are <em>i.i.d.</em> random variables, uniformly distributed on <span class="math inline">[0, \bar \Lambda]</span>.</p></li>
</ul>
<p>By <a href="#prp-marked-poisson" class="quarto-xref">Proposition&nbsp;6</a> , <span class="math inline">\bar{Q}</span> is a Poisson random measure with mean measure <span class="math display">
    \bar \mu(\mathrm{d}t, \mathrm{d}\theta): = \bar \Lambda \mathrm{d}t
    \frac{\mathbf{1}_{[0, \bar \Lambda]}(\theta)}{\bar \Lambda} \mathrm{d}\theta= \mathrm{d}t  \mathbf{1}_{[0, \bar \Lambda]}(\theta) \mathrm{d}\theta.
</span> In particular, the average number of atoms <span class="math inline">(\bar T_\ell, \bar \Theta_\ell)</span> in <span class="math inline">[0,t]\times [0,h]</span> is <span class="math display">
    \mathbb{E}[Q([0,t]\times [0,h])]={\mathbb{E}}[\sum_{\ell} \mathbf{1}_{[0,t]\times [0,h]} (\bar T_\ell, \bar \Theta_{\ell})]  = \int_{(\mathbb{R}^+)^2}  \bar \mu(\mathrm{d}t, \mathrm{d}\theta)  = t (\bar \Lambda \wedge h).
</span> The thinning is based on the restriction property for Poisson measure: for a measurable set <span class="math inline">\Delta\subset {\mathbb{R}}^+\times {\mathbb{R}}^+</span>, the restriction <span class="math inline">Q^\Delta:= \mathbf{1}_{\Delta}\bar Q</span> of <span class="math inline">\bar Q</span> to <span class="math inline">\Delta</span> (by taking only atoms in <span class="math inline">\Delta</span>) is also a Poisson random measure of mean measure <span class="math inline">\mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta)  = \mathbf{1}_{\Delta}(t,\theta) \bar \mu(\mathrm{d}t, \mathrm{d}\theta).</span></p>
<p>In order to obtain an inhomogeneous Poisson measure of intensity <span class="math inline">(\Lambda(t))</span>, the “good” choice of <span class="math inline">\Delta</span> is the hypograph of <span class="math inline">\Lambda</span>: <span class="math inline">\Delta =\{ (t,\theta) \in [0,T]\times [0,\bar \Lambda] ; \; \theta \leq \Lambda(t)\}</span> (see <a href="#fig-thinning" class="quarto-xref">Figure&nbsp;1</a>). Then, <span class="math display">
    Q^\Delta = \sum_{\ell \ge 1} \mathbf{1}_{\left\{\bar \Theta_\ell \le \Lambda(\bar T_\ell)\right\}} \delta_{(\bar T_\ell, \bar \Theta_\ell)},
</span> and since <span class="math inline">\Lambda(t) \leq \bar \Lambda</span>, on <span class="math inline">[0,T]</span>: <span class="math display">
\begin{aligned}
    \mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta) &amp; = \mathbf{1}_{\{ \theta \leq \Lambda(t)\}}  \mathrm{d}t
\mathbf{1}_{[0, \bar \Lambda]}(\theta)\mathrm{d}\theta = \mathbf{1}_{\{\theta \leq \Lambda(t)\}} \mathrm{d}t \mathrm{d}\theta.
\end{aligned}
</span></p>
<div id="fig-thinning" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-thinning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<embed src="img/plot_thinning.tex" class="img-fluid">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-thinning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Realization of a Marked Poisson measure <span class="math inline">\bar Q</span> on <span class="math inline">[0,T]</span> with mean measure <span class="math inline">\bar \mu(\mathrm{d} t, \mathrm{d} \theta) = \mathrm{d} t \mathbf{1}_{[0, \bar \Lambda]}(\theta) \mathrm{d} \theta</span> (red crosses), and realization of the restriction <span class="math inline">\bar Q^\Delta</span> where <span class="math inline">\Delta = \{ (t,\theta)\in [0,T]\times[0, \bar \Lambda], \theta \leq \Lambda(t) \}</span> (blue circles). The projection of <span class="math inline">\bar Q^\Delta</span> on first component is an inhomogeneous Poisson process on <span class="math inline">[0,T]</span> of intensity <span class="math inline">(\Lambda(t))</span> and jump times <span class="math inline">(T_k)_{k \ge 1}</span>.
</figcaption>
</figure>
</div>
<p>Finally, the inhomogeneous Poisson process is obtained by the projection <a href="#prp-proj-poisson-measure" class="quarto-xref">Proposition&nbsp;5</a>, which states that the jump times of <span class="math inline">Q^\Delta</span> are the jump times of an inhomogeneous Poisson process of intensity <span class="math inline">(\Lambda(t))</span>.</p>
<div id="prp-thinning" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1</strong></span> The counting process <span class="math inline">N^\Lambda</span>, projection of <span class="math inline">Q^{\Delta}</span> on the time component and defined by, <span id="eq-thinning-inhomogeneous-poisson"><span class="math display">
    N^{\Lambda}_t := Q^{\Delta}( [0,t] \times {\mathbb{R}}^+) = \int_0^t \int_{{\mathbb{R}}^+} \mathbf{1}_{\{\theta \leq \Lambda(s)\}} \bar Q(\mathrm{d}s, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathbf{1}_{\{ \bar T_\ell \leq t \}} \mathbf{1}_{\{\bar \Theta_\ell \leq  \Lambda(\bar T_\ell) \}},  \quad \forall t \in [0,T],
\tag{13}</span></span> is an inhomogeneous Poisson process on <span class="math inline">[0,T]</span> of intensity function <span class="math inline">(\Lambda(t))_{t\in [0,T]}</span>. The thinning <a href="#eq-thinning-inhomogeneous-poisson" class="quarto-xref">Equation&nbsp;13</a> is a pathwise representation of <span class="math inline">N^\Lambda</span> by <em>restriction and projection</em> of the Poisson measure <span class="math inline">Q</span> on <span class="math inline">[0,T]</span>.</p>
</div>
<p>The previous proposition yields a straightforward thinning algorithm to simulate the jump times <span class="math inline">(T_k)_{k \ge 1}</span> of an inhomogeneous Poisson process of intensity <span class="math inline">\Lambda(t)</span>, by selecting jump times <span class="math inline">\bar T_\ell</span> such that <span class="math inline">\bar \Theta_\ell \le \Lambda(\bar T_\ell)</span>.</p>
<section id="sec-vector" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="sec-vector"><span class="header-section-number">4.1.1</span> Multivariate Poisson process</h3>
<p>This can be extended to the simulation of multivariate inhomogeneous Poisson processes, which is an important example before tackling the simulation of an IBM.</p>
<p>Let <span class="math inline">(N^j)_{j \in \mathcal{J}}</span> be a (inhomogeneous) multivariate Poisson process indexed by a finite set <span class="math inline">\mathcal{J}</span>, such that <span class="math inline">\forall j \in \mathcal{J}</span>, the intensity <span class="math inline">(\lambda_j(t))_{t\in [0,T]}</span> of <span class="math inline">N_j</span> is bounded on <span class="math inline">[0,T]</span>: <span class="math display">
    \sup_{t\in[0,T]} \lambda_j(t) \le \bar \lambda_j, \text{ and let }
    \bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j.
</span> Recall that such multivariate counting process can be rewritten as a Poisson random measure <span class="math inline">N= \sum_{k\geq 1} \delta_{(T_k,J_k)}</span> on <span class="math inline">{\mathbb{R}}^+\times \mathcal{J}</span> (see e.g.&nbsp;Sec. 2 of Chapter 6 in&nbsp;<span class="citation" data-cites="Cin11">(<a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>)</span>), where <span class="math inline">T_k</span> is <span class="math inline">k</span>th jump time of <span class="math inline">\sum_{j\in \mathcal{J}} N^j</span> and <span class="math inline">J_k</span> corresponds to the component of the the vector which jumps. In particular, <span class="math inline">N^j_t = N([0,t]\times \{j\})</span>.</p>
<p>Once again the simulation of such process can be obtained from the simulation of a (homogeneous) multivariate Poisson process of intensity vector <span class="math inline">(\bar{\lambda}_j)_{j \in \mathcal{J}}</span>, extended into a Poisson measures by adding marks on <span class="math inline">{\mathbb{R}}^+</span>. Thus, we introduce the Marked Poisson measure <span class="math inline">\bar Q = \sum \delta_{(\bar T_\ell, \bar J_\ell, \bar \Theta_\ell)}</span> on <span class="math inline">{\mathbb{R}}^+  \times \mathcal{J}\times {\mathbb{R}}^+</span>, such that:</p>
<ul>
<li>The jump times <span class="math inline">(\bar T_\ell)</span> of <span class="math inline">\bar Q</span> are the jump times of a Poisson measure of intensity <span class="math inline">\bar \Lambda</span>.</li>
<li>The variables <span class="math inline">(\bar J_\ell)</span> are <em>i.i.d.</em> random variables on <span class="math inline">\mathcal{J}</span>, with <span class="math inline">\displaystyle p_j= {\mathbb{P}}(\bar J_1 = j)= \bar \lambda_j/\bar \Lambda</span> and representing the component of the vector which jumps.</li>
<li>The marks <span class="math inline">(\bar \Theta_\ell)</span> are independent variables with <span class="math inline">\bar \Theta_\ell</span> a uniform random variable on <span class="math inline">[0,\bar \lambda_{{\bar J}_\ell}]</span>, <span class="math inline">\forall \ell \geq 1</span>.</li>
</ul>
<p>By <a href="#prp-marked-poisson" class="quarto-xref">Proposition&nbsp;6</a> and <a href="#prp-proj-poisson-measure" class="quarto-xref">Proposition&nbsp;5</a>, each measure <span class="math inline">\bar Q_j (\mathrm{d}t, \mathrm{d}\theta) = \bar Q(\mathrm{d}t, \{j\}, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathbf{1}_{\{\bar J_\ell=j \}} \delta_{(\bar T_\ell, \bar \Theta_\ell)}</span> is a marked Poisson measure of intensity <span class="math display">
    \bar \mu_j ( \mathrm{d}t  ,\mathrm{d}\theta) = \bar{\Lambda}p_j \mathrm{d}t  \frac{\mathbf{1}_{\{\theta \leq \bar \lambda_{j}\}}(\theta)}{\bar \lambda_{j}} \mathrm{d}\theta = \mathrm{d}t  \mathbf{1}_{\{\theta \leq \bar \lambda_{j}\}}(\theta) \mathrm{d}\theta.
</span> As a direct application of <a href="#prp-thinning" class="quarto-xref">Proposition&nbsp;1</a> , the inhomogeneous multivariate Poisson process is obtained by restriction of each measures <span class="math inline">\bar Q_j</span> to <span class="math inline">\Delta_j = \{ (t, \theta) \in [0,T] \times [0,\bar \lambda_j] ;\; \theta \leq \lambda_j(t) \}</span> and projection.</p>
<div id="prp-thinning-vector" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2</strong></span> The multivariate counting process <span class="math inline">(N^j)_{j \in \mathcal{J}}</span>, defined for all <span class="math inline">j \in \mathcal{J}</span> and <span class="math inline">t \in [0,T]</span> by thinning and projection of <span class="math inline">\bar Q</span>: <span class="math display">
    N^j_t  := \int_0^t \int_{ {\mathbb{R}}^+} \mathbf{1}_{\{\theta \leq \lambda_j(s)\}} \bar{Q}(\mathrm{d}s, \{j\}, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathbf{1}_{\{ \bar T_\ell \leq t \}}\mathbf{1}_{\{\bar J_\ell = j\}} \mathbf{1}_{\{\bar \Theta_\ell \leq  \lambda_j (\bar T_\ell ) \}},
</span> is an inhomogeneous Poisson process of intensity vector <span class="math inline">(\lambda_j(t))_{j\in\mathcal{J}}</span> on <span class="math inline">[0,T]</span>.</p>
</div>
<p><a href="#prp-thinning-vector" class="quarto-xref">Proposition&nbsp;2</a> yields the following simulation <a href="#alg-thinning2" class="quarto-xref">Algorithm 1</a> for multivariate Poisson processes.</p>
<div id="alg-thinning2" class="pseudocode-container quarto-float" data-caption-prefix="Algorithm" data-line-number-punc=":" data-comment-delimiter="//" data-pseudocode-number="1" data-no-end="false" data-line-number="true" data-indent-size="1.2em">
<div class="pseudocode">
\begin{algorithm} \caption{Thinning algorithm for multivariate inhomogeneous Poisson processes.} \begin{algorithmic} \State \textbf{Input:} Functions and bounds $(\lambda_j, \bar \lambda_j)$, $\lambda_j: [0,T] \to [0,\bar \lambda_j]$ and $\bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j$ \State \textbf{Output:} Points $(T_k, J_k)$ of Poisson measure $N$ on $[0,T] \times \mathcal{J}$ \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ \While{$T_k &lt; T$} \Repeat \State increment iterative variable $\ell \longleftarrow \ell+1$ \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + S_\ell$ with $S_\ell \sim \mathcal{E}(\bar \Lambda)$ \State draw $\bar J_\ell \sim \mathcal{U}\big\{ \bar \lambda_j / \bar \Lambda, j \in \mathcal{J} \big\}$ i.e. $\mathbb{P}(\bar J_\ell = j) = \bar \lambda_j / \bar \Lambda$ \State draw $\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda_{\bar J_\ell}])$ \Until{accepted event $\bar \Theta_\ell \le \lambda_{\bar J_\ell}(\bar T_{\ell})$} \State record $(T_k, J_k) \longleftarrow (\bar T_{\ell}, \bar J_\ell)$ as accepted point \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="rem-alternate-thinning" class="proof remark">
<p><span class="proof-title"><em>Remark 2</em>. </span>The acceptance/rejection <a href="#alg-thinning2" class="quarto-xref">Algorithm 1</a> can be efficient when the functions <span class="math inline">\lambda_j</span> are of different order, and thus bounded by different <span class="math inline">\bar \lambda_j</span>. However, it is important to note that the simulation of the discrete random variables <span class="math inline">(\bar J_\ell)</span> can be costly (compared to a uniform law) when <span class="math inline">\mathcal{J}</span> is large, for instance when an individual is drawn from a large population. In this case, an alternative is to choose the same bound <span class="math inline">\bar \lambda_j= \bar \lambda</span> for all <span class="math inline">j \in \mathcal{J}</span>. Then the marks <span class="math inline">(\bar J_\ell, \bar \Theta_\ell)</span> are <em>i.i.d.</em> uniform variables on <span class="math inline">\mathcal{J}\times [0,\bar \lambda]</span>, faster to simulate.</p>
</div>
</section>
</section>
<section id="sec-simulation-algo" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sec-simulation-algo"><span class="header-section-number">4.2</span> Simulation algorithm</h2>
<p>Let us now come back to the simulation of the IBM introduced in <a href="#sec-overview" class="quarto-xref">Section&nbsp;2</a>. For ease of notations, we assume that there are no event with Poisson intensity (<span class="math inline">\mathcal{P} =\emptyset</span>), so that all events that occur are of type <span class="math inline">e \in \mathcal{E} \cup \mathcal{E}_W</span>, with individual intensity <span class="math inline">\lambda_t^e(I,Z_t)</span> depending on the population composition <span class="math inline">Z_t</span> (<span class="math inline">e \in \mathcal{E}_W</span>) or not (<span class="math inline">e \in \mathcal{E}</span>), as defined in <a href="#eq-individual-intensity" class="quarto-xref">Equation&nbsp;7</a> and verifying either <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> or <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>. The global intensity <a href="#eq-global-ev-intensity" class="quarto-xref">Equation&nbsp;9</a> at time <span class="math inline">t \in [0,T]</span> is thus <span id="eq-def-intensity"><span class="math display">
    \Lambda_t(Z_t) = \sum_{e \in \mathcal{E}} \Big( \sum_{k=1}^{N_t} \lambda^e(t, I_k) \Big)
    + \sum_{e \in \mathcal{E}_W} \Big( \sum_{k=1}^{N_t} \sum_{j=1}^{N_t} W^e(t, I_k, I_j) \Big) \leq \bar \Lambda(N_t),
\tag{14}</span></span> with <span class="math inline">\bar \Lambda(n) = \big(\sum_{e \in \mathcal{E}} \bar \lambda^e \big) n + \big( \sum_{e \in \mathcal{E}_W} \bar W^e \big) n^2</span>.</p>
<p>One of the main difficulty is that the intensity of events is not deterministic as in the case of inhomogeneous Poisson processes, but a function <span class="math inline">\Lambda_t(Z_t)</span> of the population state, bounded by a function which also depends on the population size. However, the <a href="#alg-thinning2" class="quarto-xref">Algorithm 1</a> can be adapted to simulate the IBM. The construction is done by induction, by conditioning on the state of the population <span class="math inline">Z_{T_k}</span> at the <span class="math inline">k</span>th event time <span class="math inline">T_k</span> (<span class="math inline">T_0 = 0</span>).</p>
<p>We first present the construction of the first event at time <span class="math inline">T_1</span>.</p>
<section id="first-event-simulation" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="first-event-simulation">First event simulation</h3>
<p>Before the first event time, on <span class="math inline">\{ t &lt; T_1 \}</span>, the population composition is constant : <span class="math inline">Z_t = Z_0 = \{ I_1, \dots, I_{N_0}\}</span>. For each type of event <span class="math inline">e</span> and individual <span class="math inline">I_k</span>, <span class="math inline">k \in \{1,\dots N_0\}</span>, we denote by <span class="math inline">N^{k,e}</span> the counting process of intensity <span class="math inline">\lambda_t^e (I_k,Z_t)</span>, counting the occurrences of the events of type <span class="math inline">e</span> happening to the individual <span class="math inline">I_k</span>. Then, the first event <span class="math inline">T_1</span> is the first jump time of the multivariate counting vector <span class="math inline">(N^{(k,e)})_{ (k,e) \in \mathcal{J}_0}</span>, with <span class="math inline">\mathcal{J}_0 = \{1,\dots , N_0\}\times \big(\mathcal{E} \cup \mathcal{E}_W \big)</span>.</p>
<p>Since the population composition is constant before the first event time, each counting process <span class="math inline">N^{j}</span> with <span class="math inline">j=(k,e) \in \mathcal{J}_0</span> coincides on <span class="math inline">[0,T_1[</span> with an inhomogeneous Poisson process, of intensity <span class="math inline">\lambda_t^e (I_k,Z_0)</span>. Thus (conditionally to <span class="math inline">Z_0</span>), <span class="math inline">T_1</span> is also the first jump time of an inhomogeneous multivariate Poisson process <span class="math inline">N^0 = (N^{0,j})_{j \in \mathcal{J}_0}</span> of intensity function <span class="math inline">(\lambda_j)_{j\in \mathcal J_0}</span>, defined for all <span class="math inline">j = (k,e) \in \mathcal{J}_0</span> by: <span class="math display">
    \lambda_j(t) = \lambda^e_t(I_k,Z_0) \le \bar \lambda^e_0 \quad \text{with} \quad \bar \lambda^e_0 = \bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_0 \mathbf{1}_{e \in \mathcal{E}_W},
</span> by <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>. In particular, the jump times of <span class="math inline">N^0</span> occur at the intensity <span class="math display">
    \Lambda(t) =\sum_{j \in \mathcal{J}_0} \lambda_j(t)  =\sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \sum_{k=1}^{N_0}  \lambda^e_t(I_k,Z_0) \leq \bar \Lambda(N_0)=N_0 \sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \bar \lambda^e_0.
</span> By <a href="#prp-thinning-vector" class="quarto-xref">Proposition&nbsp;2</a>, <span class="math inline">N^0</span> can be obtained by thinning of the marked Poisson measure <span class="math inline">\bar Q^0 = \sum_{\ell \geq 1} \delta_{(\bar T_\ell , (\bar{K}_\ell, \bar E_\ell), \bar \Theta_\ell)}</span> on <span class="math inline">{\mathbb{R}}^+\times\mathcal{J}_0 \times {\mathbb{R}}^+</span>, with:</p>
<ul>
<li><span class="math inline">(\bar T_\ell)_{\ell \in {\mathbb{N}}^*}</span> the jump times of a Poisson process of rate <span class="math inline">\bar \Lambda(N_0)</span>.</li>
<li><span class="math inline">(\bar{K}_\ell, \bar E_\ell)_{\ell \in {\mathbb{N}}^*}</span> discrete <em>i.i.d.</em> random variables on <span class="math inline">\mathcal{J}_0 = \{1,\dots , N_0\}\times \big(\mathcal{E} \cup \mathcal{E}_W \big)</span>, with <span class="math inline">K_\ell</span> representing the index of the chosen individual and <span class="math inline">E_\ell</span> the event type for the proposed event, such that: <span class="math display">
  \mathbb{P}( \bar  K_1 = k, \bar E_1 = e)
  = \frac{\bar \lambda^e_0 }{\bar \Lambda(N_0)}
  = \frac{1}{N_0} \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)},
</span> i.e.&nbsp;<span class="math inline">(\bar K_1, \bar E_1)</span> are distributed as independent random variables where <span class="math inline">\bar K_1 \sim \mathcal U(\{1,\dots, N_0\})</span> and <span class="math inline">\bar E_1</span> such that <span class="math display">
  p_e := \mathbb{P}( \bar E_1 = e)
      = \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)}.
</span></li>
<li><span class="math inline">(\bar \Theta_\ell)_{\ell \in {\mathbb{N}}^*}</span> are independent uniform random variables, with <span class="math inline">\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda^{\bar E_\ell}]).</span></li>
</ul>
<p>Since the first event is the first jump of <span class="math inline">N^0</span>, by <a href="#prp-thinning-vector" class="quarto-xref">Proposition&nbsp;2</a> and <a href="#alg-thinning2" class="quarto-xref">Algorithm 1</a>, the first event time <span class="math inline">T_1</span> is the first jump time <span class="math inline">\bar T_\ell</span> of <span class="math inline">\bar Q^0</span> such that <span class="math inline">\bar \Theta_\ell \leq \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell}, Z_0)</span>.</p>
<p>At <span class="math inline">T_1 =\bar T_{\ell}</span>, the event <span class="math inline">\bar E_\ell</span> occurs to the individual <span class="math inline">I_{\bar K_\ell} = (\tau^b, \infty, x)</span>. For instance, if <span class="math inline">\bar E_\ell =d</span>, a death/exit event occurs, so that <span class="math inline">Z_{T_1} = Z_{0} + \delta_{(\tau^b, T_1, x)} - \delta_{I_{\bar K_\ell}}</span> and <span class="math inline">N_{T_1} = N_{0}</span>. If <span class="math inline">\bar E_\ell =b</span> or <span class="math inline">en</span>, a birth or entry event occurs, so that <span class="math inline">N_{T_1} = N_{0} + 1</span>, and a new individual <span class="math inline">I_{N_0+1}</span> is added to the population, chosen as described in <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>. Finally, if <span class="math inline">\bar E_\ell=s</span>, a swap event occurs, the population size stays constant and <span class="math inline">I_{\bar K_\ell}</span> is replaced by an individual <span class="math inline">I_{\bar K_\ell}'</span>, chosen as described in <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>.</p>
<p>The steps for simulating the first event in the population can be iterated in order to simulate the population. At the <span class="math inline">k</span>th step, the same procedure is repeated to simulate the <span class="math inline">k</span>th event, starting from a population <span class="math inline">Z_{T_{k-1}}</span> of size <span class="math inline">N_{T_{k-1}}</span>. The algorithm is summarized in <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a>.</p>
<div id="alg-interaction" class="pseudocode-container quarto-float" data-caption-prefix="Algorithm" data-line-number-punc=":" data-comment-delimiter="//" data-pseudocode-number="2" data-no-end="false" data-line-number="true" data-indent-size="1.2em">
<div class="pseudocode">
\begin{algorithm} \caption{IBM simulation algorithm (without events of Poissonian intensity)} \begin{algorithmic} \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by: \State - Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$ and $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ \State - Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W$ \State \textbf{Output:} Population $Z_T$ \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ \While{$T_k &lt; T$} \Repeat \State increment iterative variable $\ell \longleftarrow \ell+1$ \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$ \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_{T_k} \mathbf{1}_{e \in \mathcal{E}_W}}{\sum_{e \in \mathcal{E}} \bar \lambda^e + \sum_{e \in \mathcal{E}_W} \bar W^e N_{T_k}}$ \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$ \State draw $\bar \Theta_\ell \sim \mathcal{U}([0, \bar \lambda^{\bar E_\ell}])$ if $\bar E_\ell \in \mathcal{E}$ or $\bar \Theta_\ell \sim \mathcal{U}([0, \bar W^{\bar E_\ell} N_{T_k}])$ if $\bar E_\ell \in \mathcal{E}_W$ \Until{accepted event $\bar \Theta_\ell \le \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell},Z_{T_{k}})$} \State increment iterative variable $k \longleftarrow k+1$ \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell, I_{\bar K_\ell})$ as accepted time, event and individual \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$ \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="thm-interaction" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2</strong></span> A population process <span class="math inline">(Z_t)_{t \in [0,T]}</span> simulated by the <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a> is an exact solution of the SDE <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>.</p>
</div>
<p>The proof of <a href="#thm-interaction" class="quarto-xref">Theorem&nbsp;2</a> is detailed in the Appendix <a href="#sec-prf-thm-interaction" class="quarto-xref">Section&nbsp;8.3</a>.</p>
<div id="rem-remvoval-dead" class="proof remark">
<p><span class="proof-title"><em>Remark 3</em>. </span>The population <span class="math inline">Z_{T_k}</span> includes dead/exited individuals before the event time <span class="math inline">T_k</span>. Thus, <span class="math inline">N_{T_k} &gt; N_{T_k}^a</span> is greater than the number of alive individuals at time <span class="math inline">T_k</span>. When a dead individual <span class="math inline">I_{\bar K_l}</span> is drawn from the population during the rejection/acceptance phase of the algorithm, the proposed event <span class="math inline">(\bar T_{\ell}, \bar E_\ell,  I_{\bar K_\ell})</span> is automatically rejected since the event intensity is <span class="math inline">\lambda^{\bar E_\ell}_{T_\ell}(I_{\bar K_\ell}, Z_{T_k}) = 0</span> (nothing can happen to a dead individual). This can slow down the algorithm, especially when the proportion of dead/exited individuals in the population increases. However, the computational cost of keeping dead/exited individuals in the population is much lower than the cost of removing an individual from the population at each death/exit event, which is linear in the population size.</p>
<p>Actually, dead/exited individuals are regularly removed from the population in the <code>IBMPopSim</code> algorithm, in order to optimize the trade-off between having to many dead individuals and removing dead individuals from the population too often. The frequency at which dead individuals are “removed from the population” can be chosen by the user, as an optional argument of the main function <code>popsim</code> (see details in <a href="#sec-simulation" class="quarto-xref">Section&nbsp;4</a>).</p>
</div>
<div id="rem-sharp-bounds" class="proof remark">
<p><span class="proof-title"><em>Remark 4</em>. </span>In practice, the bounds <span class="math inline">\bar \lambda^e</span> and <span class="math inline">\bar W^e</span> should be chosen as sharp as possible. It is easy to see that conditionally to <span class="math inline">\{\bar E_\ell = e, \bar T_\ell = t, \bar K_\ell = l \}</span> the probability of accepting the event is, depending if there are interactions, <span class="math display">
    \mathbb{P}\big(\bar \Theta_\ell \le \lambda^e_t(I_l,Z_{T_k})| \mathcal{F}_{T_k}\big)
    = \frac{\lambda^e(t, I_l)}{\bar \lambda^e} \mathbf{1}_{e \in \mathcal{E}} +  \frac{\sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j)}{\bar W^e N_{T_k}} \mathbf{1}_{e \in \mathcal{E}_W}.
</span> The sharper the bounds <span class="math inline">\bar \lambda^e</span> and <span class="math inline">\bar W^e</span> are, the higher is the acceptance rate. For even sharper bounds, an alternative is to define bounds <span class="math inline">\bar \lambda^e(I_l)</span> and <span class="math inline">\bar W^e(I_l)</span> depending on the individuals’ characteristics. However, the algorithm is modified and the individual <span class="math inline">I_l</span> is not chosen uniformly in the population anymore. Due to the population size, this is way more costly than choosing uniform bounds, as explained in <a href="#rem-alternate-thinning" class="quarto-xref">Remark&nbsp;2</a>.</p>
</div>
</section>
</section>
<section id="sec-simulation-randomized" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="sec-simulation-randomized"><span class="header-section-number">4.3</span> Simulation algorithm with randomization</h2>
<p>Let <span class="math inline">e \in \cal E_W</span> be an event with interactions. In order to evaluate the individual intensity <span class="math inline">\lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I,I_j)</span> one must compute <span class="math inline">W^e(t, I_l, I_j)</span> for all individuals in the population. This step can be computationally costly, especially for large populations. One way to avoid this summation is to use randomization (see also&nbsp;<span class="citation" data-cites="FouMel04">Fournier and Méléard (<a href="#ref-FouMel04" role="doc-biblioref">2004</a>)</span> in a model without age). The randomization consists in replacing the summation by an evaluation of the interaction function <span class="math inline">W^e</span> using an individual <span class="math inline">J</span> drawn uniformly from the population.</p>
<p>More precisely, if <span class="math inline">J \sim \mathcal{U}(\{1, \dots, N_{T_k}\})</span> is independent of <span class="math inline">\bar \Theta_\ell</span>, we have <span id="eq-randomized-event"><span class="math display">
    \mathbb{P}\Big(\bar \Theta_\ell \le
    \sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j) | \mathcal{F}_{T_k} \Big)
    = \mathbb{P}\big(\bar \Theta_\ell
    \le N_{T_k} W^e(t, I_l, I_J) | \mathcal{F}_{T_k}\big).
\tag{15}</span></span> Equivalently, we can write this probability as <span class="math inline">\mathbb{P}\big(\tilde \Theta_\ell \le W^e(t, I_l, I_J) \big)</span> where <span class="math inline">\tilde \Theta_\ell  = \frac{\bar \Theta_\ell}{N_{T_k}}\sim \mathcal{U}([0, \bar W^e])</span> is independent of <span class="math inline">J \sim \mathcal{U}(\{1, \dots, N_{T_k}\})</span>.</p>
<div id="rem">
<p>The efficiency of the randomization procedure increases with the population homogeneity. If the function <span class="math inline">W^e</span> varies little according to the individuals in the population, the randomization approach is very efficient in practice, especially when the population is large.</p>
</div>
<p>We now present the main <a href="#alg-randomized" class="quarto-xref">Algorithm 3</a> implemented in the <code>popsim</code> function of the <code>IBMPopSim</code> package in the case where events arrive with individual intensities, but also with interactions (using randomization) and Poisson intensities. In this general case, <span class="math inline">\bar \Lambda(n)</span> is defined by <a href="#eq-def-bar-Lambda" class="quarto-xref">Equation&nbsp;11</a>.</p>
<div id="alg-randomized" class="pseudocode-container quarto-float" data-caption-prefix="Algorithm" data-line-number-punc=":" data-comment-delimiter="//" data-pseudocode-number="3" data-no-end="false" data-line-number="true" data-indent-size="1.2em">
<div class="pseudocode">
\begin{algorithm} \caption{Randomized IBM simulation algorithm.} \begin{algorithmic} \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by \State Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$, $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ and $(\mu^e, \bar \mu^e)$ for $e \in \mathcal{P}$ \State Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W \cup \mathcal{P}$ \State \textbf{Output:} Population $Z_T$ \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ \While{$T_k &lt; T$} \Repeat \State increment iterative variable $\ell \longleftarrow \ell+1$ \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$ \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$ \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \mu^e \mathbf{1}_{e \in \mathcal{P}} + \bar \lambda^e N_{T_k}\mathbf{1}_{e \in \mathcal{E}} + \bar W^e (N_{T_k})^2 \mathbf{1}_{e \in \mathcal{E}_W}}{\bar \Lambda(N_{T_k})}$ \If{$\bar E_\ell \in \mathcal{E}$ (without interaction)} \State draw $\bar \Theta_\ell \sim \mathcal{U}\big([0, \bar \lambda^{\bar E_\ell}] \big)$ \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le \lambda^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell})$ \EndIf \If{$\bar E_\ell \in \mathcal{E}_W$ (with interaction)} \State draw $(\bar \Theta_\ell, J_\ell) \sim \mathcal{U}\big([0, \bar W^{\bar E_\ell}] \times \{1, \dots, N_{T_k}\} \big)$ \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le W^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell}, I_{J_\ell})$ \EndIf \If{$\bar E_\ell \in \mathcal{P}$ (Poissonian intensity)} \State draw $\bar \Theta_\ell \sim \mathcal{U}\big([0, \bar \mu^{\bar E_\ell}] \big)$ \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le \mu^{\bar E_\ell}(\bar T_\ell)$ \EndIf \Until{accepted} \State increment iterative variable $k \longleftarrow k+1$ \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell, \bar I_{\bar K_\ell})$ as accepted time, event and individual \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$ \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="prp-randomized" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3</strong></span> The population processes <span class="math inline">(Z_t)_{t\in [0,T]}</span> simulated by the <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a> and <a href="#alg-randomized" class="quarto-xref">Algorithm 3</a> have the same law.</p>
</div>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>The only difference between <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a> and <a href="#alg-randomized" class="quarto-xref">Algorithm 3</a> is in the acceptance/rejection step of proposed events, in the presence of interactions. In <a href="#alg-randomized" class="quarto-xref">Algorithm 3</a> , a proposed event <span class="math inline">(\bar T_\ell, \bar E_\ell, \bar K_\ell)</span>, with <span class="math inline">\bar E_l \in \mathcal{E}_W</span> (an event with interaction), is accepted as a true event in the population if <span class="math display">
    \bar \Theta_\ell \le W^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell}, I_{\bar J_\ell}), \text{ with } (\bar \Theta_\ell, \bar J_\ell) \sim  \mathcal{U}\big([0, \bar W^{\bar E_\ell}] \times \{1, \dots, N_{T_k}\} \big).
</span> By <a href="#eq-randomized-event" class="quarto-xref">Equation&nbsp;15</a>, the probability of accepting this event is the same than in <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a>, which achieves the proof.</p>
</div>
</section>
</section>
<section id="sec-package" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Model creation and simulation with IBMPopSim</h1>
<p>The use of the <code>IBMPopSim</code> package is mainly done in two steps: a first model creation followed by the simulation of the population evolution. The creation of a model is itself based on two steps: the description of the population <span class="math inline">Z_t</span>, as introduced in <a href="#sec-population" class="quarto-xref">Section&nbsp;3.1</a>, and the description of the events types, along with their associated intensities, as detailed in <a href="#sec-events" class="quarto-xref">Section&nbsp;3.2</a> and <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;3.3</a>. A model is compiled by calling the <code>mk_model</code> function, which internally uses a template mechanism to automatically generate the source code describing the model, which is subsequently compiled using the <code>Rcpp</code> package to produce the object code.</p>
<p>After the compilation of the model, the simulations are launched by calling the <code>popsim</code> function. This function depends on the previously compiled model and simulates a random trajectory of the population evolution based on an initial population and on parameter values, which can change from a call to another.</p>
<p>In this section, we take a closer look at each component of a model in <code>IBMPopSim</code>. We also refer to the <a href="https://daphnegiorgi.github.io/IBMPopSim/">IBMPopSim website</a> and to the <code>vignettes</code> of the package for more details on the package and various examples of model creation.</p>
<section id="sec-package-population" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="sec-package-population"><span class="header-section-number">5.1</span> Population</h2>
<p>A population <span class="math inline">Z</span> is represented by an object of class <code>population</code> containing a data frame where each row corresponds to an individual <span class="math inline">I=(\tau^b, \tau^d, x)</span>, and which has at least two columns, <code>birth</code> and <code>death</code>, corresponding to the birth date <span class="math inline">\tau^b</span> and death/exit date <span class="math inline">\tau^d</span> (<span class="math inline">\tau^d</span> is set to <code>NA</code> for alive individuals). The data frame can contain more than two columns if individuals are described by additional characteristics <span class="math inline">x= (x_1,\dots x_n)</span>.</p>
<p>If entry events can occur in the population, the population will contain a characteristic named <code>entry</code>. This can be done by setting the flag <code>entry=TRUE</code> in the <code>population</code> function, or by calling the <code>add_characteristic</code> function on an existing population. During the simulation, the date at which an individual enters the population is automatically recorded in the variable <code>I.entry</code>. If exit events can occur, the population shall contain a characteristic named <code>out</code>. This can be done by setting the flag <code>out=TRUE</code> in the <code>population</code> function, or by calling the <code>add_characteristic</code> function. When an individual <code>I</code> exits the population during the simulation, <code>I.out</code> is set to <code>TRUE</code> and its exit time is recorded as a “death” date.</p>
<p>In the example below, individuals are described by their birth and death dates, as well a Boolean characteristics called male, and the <code>entry</code> characteristic. For instance, the first individual is a female whose age at <span class="math inline">t_0=0</span> is <span class="math inline">107</span> and who was originally in the population.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample, <span class="at">entry=</span><span class="cn">TRUE</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(pop_init)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Classes 'population' and 'data.frame':  100000 obs. of  4 variables:
 $ birth: num  -107 -107 -105 -104 -104 ...
 $ death: num  NA NA NA NA NA NA NA NA NA NA ...
 $ male : logi  FALSE FALSE TRUE FALSE FALSE FALSE ...
 $ entry: logi  NA NA NA NA NA NA ...</code></pre>
</div>
</div>
<p><em>Individual</em> In the <code>C++</code> model which is automatically generated and compiled, an individual <code>I</code> is an object of an internal class containing some attributes (<code>birth_date</code>, <code>death_date</code> and the characteristics), and some methods including:</p>
<ul>
<li><code>I.age(t)</code>: a <code>const</code> method returning the age of an individual <code>I</code> at time <code>t</code>,</li>
<li><code>I.set_age(a, t)</code>: a method to set the age <code>a</code> at time <code>t</code> of an individual <code>I</code> (set <code>birth_date</code> at <code>t-a</code>),</li>
<li><code>I.is_dead(t)</code>: a <code>const</code> method returning <code>true</code> if the individual <code>I</code> is dead at time <code>t</code>.</li>
</ul>
<div id="rem-characteristics" class="proof remark">
<p><span class="proof-title"><em>Remark 5</em>. </span>A characteristic <span class="math inline">x_i</span> must be of atomic type: <code>logical</code>, <code>integer</code>, <code>double</code> or <code>character</code>. The function <code>get_characteristic</code> allows to easily get characteristics names and their types from a population data frame. We draw the attention to the fact that some names for characteristics are forbidden, or reserved to specific cases : this is the case for <code>birth</code>, <code>death</code>, <code>entry</code>, <code>out</code>, <code>id</code>.</p>
</div>
</section>
<section id="sec-package-events" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="sec-package-events"><span class="header-section-number">5.2</span> Events</h2>
<p>The most important step of the model creation is the events creation. The call to the function creating an event is of form</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_CLASS</span>(<span class="at">type=</span><span class="st">"TYPE"</span>, <span class="at">name=</span><span class="st">"NAME"</span>, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>where <code>CLASS</code> is replaced by the class of the event intensity, described in <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;3.3</a> , and <code>type</code> corresponds to the event type, described in <a href="#sec-events" class="quarto-xref">Section&nbsp;3.2</a>. <a href="#tbl-intensity-classes" class="quarto-xref">Table&nbsp;2 (a)</a> and <a href="#tbl-event-types" class="quarto-xref">Table&nbsp;2 (b)</a> summarize the different possible choices for intensity classes and types of event. The optional argument <code>name</code> gives a name to the event. If not specified, the name of the event is its type, for instance <code>death</code>. However, a name must be specified if the model is composed of several events with the same type (for instance when there are multiple death events corresponding to different causes of death). The other arguments depend on the intensity class and on the event type.</p>
<div id="tbl-panel" class="quarto-layout-panel anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-panel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Choices of <code>CLASS</code> and <code>TYPE</code> arguments for an event creation.
</figcaption>
<div aria-describedby="tbl-panel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<div id="tbl-intensity-classes" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-tbl figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-tbl" id="tbl-intensity-classes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Intensity Classes
</figcaption>
<div aria-describedby="tbl-intensity-classes-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Intensity class</th>
<th style="text-align: left;">Set</th>
<th style="text-align: left;"><code>CLASS</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Individual</td>
<td style="text-align: left;"><span class="math inline">\mathcal{E}</span></td>
<td style="text-align: left;"><code>individual</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Interaction</td>
<td style="text-align: left;"><span class="math inline">\mathcal{E}_W</span></td>
<td style="text-align: left;"><code>interaction</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Poisson</td>
<td style="text-align: left;"><span class="math inline">\mathcal{P}</span></td>
<td style="text-align: left;"><code>poisson</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Inhomogeneous Poisson</td>
<td style="text-align: left;"><span class="math inline">\mathcal{P}</span></td>
<td style="text-align: left;"><code>inhomogeneous_poisson</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="tbl-panel" style="flex-basis: 50.0%;justify-content: center;">
<div id="tbl-event-types" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-tbl figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-tbl" id="tbl-event-types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Event Types
</figcaption>
<div aria-describedby="tbl-event-types-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Event type</th>
<th style="text-align: left;"><code>TYPE</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Birth</td>
<td style="text-align: left;"><code>birth</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Death</td>
<td style="text-align: left;"><code>death</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Entry</td>
<td style="text-align: left;"><code>entry</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Exit</td>
<td style="text-align: left;"><code>exit</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Swap</td>
<td style="text-align: left;"><code>swap</code></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</div>
</div>
</div>
</figure>
</div>
<p>The intensity function and the kernel of an event are defined through arguments of the function <code>mk_event_CLASS</code>. These arguments are strings composed of few lines of code. Since the model is compiled using <code>Rcpp</code>, the code should be written in <code>C++</code>. However, thanks to the functions/variables of the package, even the non-experienced <code>C++</code> user can define a model quite easily. To facilitate the implementation, the user can also define a list of <strong>model parameters</strong>, which can be used in the event and intensity definitions. These parameters are stored in a named list and can be of various types: atomic type, numeric vector or matrix, predefined function of one variable (<code>stepfun</code>, <code>linfun</code>, <code>gompertz</code>, <code>weibull</code>, <code>piecewise_x</code>), piecewise functions of two variables (<code>piecewise_xy</code>). We refer to the <code>vignette(IBMPopSim_cpp)</code> for more details on parameters types and basic <code>C++</code> tools. Another advantage of the model parameters is that their value can be modified from a simulation to another without changing the model.</p>
<section id="intensities" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="intensities"><span class="header-section-number">5.2.1</span> Intensities</h3>
<p>In <code>IBMPopSim</code>, the intensity of an event can belong to three classes <a href="#sec-event-intensity" class="quarto-xref">Section&nbsp;3.3</a>: individual intensities without interaction between individuals, corresponding to events <span class="math inline">e\in\mathcal{E}</span>, individual intensities with interaction, corresponding to events <span class="math inline">e\in\mathcal{E}_W</span>, and Poisson intensities (homogeneous and inhomogeneous), corresponding to events <span class="math inline">e\in\mathcal{P}</span>.</p>
<p><em>Event creation with individual intensity</em></p>
<p>An event <span class="math inline">e\in \mathcal{E}</span> (see <a href="#eq-intensity-no-interaction" class="quarto-xref">Equation&nbsp;5</a>) has an intensity of the form <span class="math inline">\lambda^e(t, I)</span> which depends only on the individual <code>I</code> and time. Events with such intensity are created using the function</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_individual</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>, </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                    <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                    <span class="at">intensity_code =</span> <span class="st">"INTENSITY"</span>, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <code>intensity_code</code> argument is a character string containing few lines of <code>C++</code> code describing the intensity function <span class="math inline">\lambda^e(t, I)</span>. The intensity value has to be stored in a variable called <code>result</code> and the available variables for the intensity code are given in <a href="#tbl-intensity-variables" class="quarto-xref">Table&nbsp;3</a>.</p>
<div id="tbl-intensity-variables" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-intensity-variables-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3: <code>C++</code> variables available for intensity code
</figcaption>
<div aria-describedby="tbl-intensity-variables-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Variable</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Variable</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>I</code></td>
<td style="text-align: left;">Current individual</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>J</code></td>
<td style="text-align: left;">Another individual in the population (only for interaction)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>t</code></td>
<td style="text-align: left;">Current time</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Model parameters</td>
<td style="text-align: left;">Depends on the model</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>For instance, the intensity code below corresponds to an individual death intensity <span class="math inline">\lambda^d(t,I)</span> equal to <span class="math inline">d_1(a(I,t)) = \alpha_1 \exp(\beta_1 a(I,t))</span> for males and <span class="math inline">d_2(a(I,t)) = \alpha_2 \exp(\beta_2 a(I,t))</span> for females, where <span class="math inline">a(I,t)=t-\tau^b</span> is the age of the individual <span class="math inline">I=(\tau^b, \tau^d,x)</span> at time <span class="math inline">t</span>. In this case, the intensity function depends on the individuals’ age, gender, and on the model parameters <span class="math inline">\alpha = (\alpha_1, \alpha_2)</span> and <span class="math inline">\beta = (\beta_1, \beta_2)</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>death_intensity <span class="ot">&lt;-</span> <span class="st">"</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="st">    if (I.male) result = alpha_1 * exp(beta_1 * I.age(t));</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="st">    else result = alpha_2 * exp(beta_2 * I.age(t));</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="st">"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><em>Event creation with interaction intensity</em></p>
<p>An event <span class="math inline">e\in \mathcal{E}_W</span> is an event which occurs to an individual at a frequency which is the result of interactions with other members of the population (see <a href="#eq-intensity-interaction" class="quarto-xref">Equation&nbsp;6</a>), and which can be written as <span class="math inline">\lambda^e_t(I, Z_t)=\sum_{J\in Z_t} W^e(t, I, J)</span> where <span class="math inline">W^e(t, I, J)</span> is the intensity of the interaction between individual <span class="math inline">I</span> and individual <span class="math inline">J</span>.</p>
<p>An event <span class="math inline">e\in \mathcal{E}_W</span> with such intensity is created by calling the function</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_interaction</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>,</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>                     <span class="at">interaction_code =</span> <span class="st">"INTERACTION_CODE"</span>,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>                     <span class="at">interaction_type =</span> <span class="st">"random"</span>, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The <code>interaction_code</code> argument contains few lines of <code>C++</code> code describing the interaction function <span class="math inline">W^e(t, I, J)</span>. The interaction function value has to be stored in a variable called <code>result</code> and the available variables for the intensity code are given in <a href="#tbl-intensity-variables" class="quarto-xref">Table&nbsp;3</a>. For example, if we set</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>death_interaction_code <span class="ot">&lt;-</span> <span class="st">"result = max(J.size - I.size, 0.);"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>the death intensity of an individual <code>I</code> is the result of the competition between individuals, depending on a characteristic named <code>size</code>, as defined in <a href="#eq-ex-interaction" class="quarto-xref">Equation&nbsp;8</a>.</p>
<p>The argument <code>interaction_type</code>, set by default at <code>random</code>, is the algorithm choice for simulating the model. When <code>interaction_type=full</code>, the simulation follows <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a>, <code>interaction_type=random</code> it follows <a href="#alg-randomized" class="quarto-xref">Algorithm 3</a>. In most cases, the <code>random</code> algorithm is much faster than the <code>full</code> algorithm. For instance in the example of <a href="#sec-example-interaction" class="quarto-xref">Section&nbsp;7</a> the <code>random</code> algorithm is 40 times faster on average than the <code>full</code> algorithm, on a set of standard parameters. This allows in particular to explore larger parameter sets and population sizes, while avoiding the explosion of computation time.</p>
<p><em>Events creation with Poisson and Inhomogeneous Poisson intensity</em></p>
<p>For events <span class="math inline">e\in \mathcal{P}\,</span> with an intensity <span class="math inline">\mu^e(t)</span> which does not depend on the population, the event intensity is of class <code>inhomogeneous_poisson</code> or <code>poisson</code> depending on whether or not the intensity depends on time (in the second case the intensity is constant).</p>
<p>For Poisson (constant) intensities the events are created with the function</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_poisson</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>,</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>                 <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">intensity =</span> <span class="st">"CONSTANT"</span>, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The following example creates a death event, where individuals die at a constant intensity <code>lambda</code> (which has to be in the list of model parameters):</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_poisson</span>(<span class="at">type =</span> <span class="st">"death,</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="st">                 intensity = "</span>lambda<span class="st">")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>When the intensity <span class="math inline">(\mu^e(t))</span> depends on time, the event can be created similarly by using the function</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_inhomogeneous_poisson</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>,</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                               <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>                               <span class="at">intensity =</span> <span class="st">"INTENSITY"</span>, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-event-kernel-code" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="sec-event-kernel-code"><span class="header-section-number">5.2.2</span> Event kernel code</h3>
<p>When an event occurs, the events kernels <span class="math inline">k^e</span> specify how the event modifies the population. The events kernels are defined in the <code>kernel_code</code> parameter of the <code>mk_event_CLASS(type = "TYPE", name ="NAME", ...)</code> function. The <code>kernel_code</code> is <code>NULL</code> by default and doesn’t have to be specified for death, exit events and birth events, but mandatory for entry and swap events. Recall that the <code>kernel_code</code> argument is a string composed of a few lines of <code>C++</code> code, characterizing the individual characteristics following the event. <a href="#tbl-events-variables" class="quarto-xref">Table&nbsp;4</a> summarizes the list of available variables that can be used in the <code>kernel_code</code>.</p>
<ul>
<li><p><strong>Death/Exit event</strong> If the user defines a death event, the death date of the current individual <code>I</code> is set automatically to the current time <code>t</code>. Similarly, when an individual <code>I</code> exits the population, <code>I.out</code> is set automatically to <code>TRUE</code> and his exit time is recorded as a <em>death</em> date. For these events types, the <code>kernel_code</code> doesn’t have to be specified by the user.</p></li>
<li><p><strong>Birth event</strong> The default generated event kernel is that an individual <code>I</code> gives birth to a new individual <code>newI</code> of age 0 at the current time <code>t</code>, with same characteristics than the parent <code>I</code>. If no kernel is specified, the default generated <code>C++</code> code for a birth event is:</p></li>
</ul>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>individual newI <span class="ot">=</span> I;</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>newI.birth_date <span class="ot">=</span> t;</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="fu">pop.add</span>(newI);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The user can modify the birth kernel, by specifying the argument <code>kernel_code</code> of <code>mk_event_CLASS</code>. In this case, the generated code is</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>individual newI <span class="ot">=</span> I;</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>newI.birth_date <span class="ot">=</span> t;</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>_KERNEL_CODE_</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fu">pop.add</span>(newI);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>where <code>_KERNEL_CODE_</code> is replaced by the content of the <code>kernel_code</code> argument.</p>
<ul>
<li><strong>Entry event</strong> When an individual <code>I</code> enters the population, <code>I.entry</code> is set automatically as the date at which the individual enters the population. When an entry occurs the individual entering the population is not of age <span class="math inline">0</span>. In this case, the user must specify the <code>kernel_code</code> argument indicating how the age and characteristics of the new individual are chosen. For instance, the code below creates an event of type <code>entry</code>, named <code>ev_example</code>, where individuals enter the population at a Poisson constant intensity. When an individual <code>newI</code> enters the population at time <code>t</code>, its age is chosen as a normally distributed random variable, with mean 20 and variance 4.</li>
</ul>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_poisson</span>(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"entry"</span>, </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">name =</span> <span class="st">"ev_example"</span>, </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity =</span> <span class="st">"lambda"</span>, </span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">kernel_code =</span> <span class="st">"</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="st">        double a_I = max(CNorm(20, 2), 0.); </span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="st">        newI.set_age(a_I, t);</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="st">    "</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<ul>
<li><strong>Swap event</strong> The user must specify the <code>kernel_code</code> argument indicating how the characteristics of an individual are modified following a swap.</li>
</ul>
<div id="tbl-events-variables" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-events-variables-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4: <code>C++</code> variables available for events kernel code
</figcaption>
<div aria-describedby="tbl-events-variables-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">Variable</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Variable</td>
<td style="text-align: left;">Description</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>I</code></td>
<td style="text-align: left;">Current individual</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>J</code></td>
<td style="text-align: left;">Another individual in the population (only for interaction)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>t</code></td>
<td style="text-align: left;">Current time</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>pop</code></td>
<td style="text-align: left;">Current population (vector)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>newI</code></td>
<td style="text-align: left;">Available only for birth and entry events.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Model parameters</td>
<td style="text-align: left;">Depends on the model</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<div id="rem">
<p>When there are several events of the same type, the user can identify which events generated a particular event by adding a characteristic to the population recording the event name/id when it occurs. See e.g.&nbsp;<code>vignette(IBMPopSim_human_pop)</code> for an example with different causes of death.</p>
</div>
</section>
</section>
<section id="sec-model-creation" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="sec-model-creation"><span class="header-section-number">5.3</span> Model creation</h2>
<p>Once the population, the events, and model parameters are defined, the IBM model is created using the function <code>mk_model</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(<span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">event =</span> events_list,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>                  <span class="at">parameters =</span> model_params)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>During this step which can take a few seconds, the model is created and compiled using the <code>Rcpp</code> package. The model structure in <code>IBMPopSim</code> is that the model depends only on the population characteristics’ and parameters names and types, rather than their values. This means that once the model has been created, various simulations can be done with different initial populations and different parameters values.</p>
<div id="exm-model-creation" class="theorem example">
<p><span class="theorem-title"><strong>Example 2</strong></span> Here is an example of model with a population structured by age and gender, with birth and death events. The death intensity of an individual of age <span class="math inline">a</span> is <span class="math inline">d(a) = \alpha \exp(\beta a),</span> and females between 15 and 40 can give birth with birth intensity <span class="math inline">b(a) = \bar \lambda^b \mathbf{1}_{[15,40]}.</span> The newborn is a male with probability <span class="math inline">p_{male}</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"p_male"</span><span class="ot">=</span> <span class="fl">0.51</span>,</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>               <span class="st">"birth_rate"</span> <span class="ot">=</span> <span class="fu">stepfun</span>(<span class="fu">c</span>(<span class="dv">15</span>,<span class="dv">40</span>),<span class="fu">c</span>(<span class="dv">0</span>,<span class="fl">0.05</span>,<span class="dv">0</span>)),</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>               <span class="st">"death_rate"</span> <span class="ot">=</span> <span class="fu">gompertz</span>(<span class="fl">0.008</span>,<span class="fl">0.02</span>))</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(<span class="at">type =</span> <span class="st">"death"</span>, <span class="at">name=</span> <span class="st">"my_death_event"</span>,</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>                  <span class="at">intensity_code =</span> <span class="st">"result = death_rate(age(I,t));"</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>( <span class="at">type =</span> <span class="st">"birth"</span>,</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>                  <span class="at">intensity_code =</span> <span class="st">"if (I.male)</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="st">                                        result = 0;</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="st">                                    else</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="st">                                        result=birth_rate(age(I,t));"</span>,</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>                  <span class="at">kernel_code =</span> <span class="st">"newI.male = CUnif(0, 1) &lt; p_male;"</span>)</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>pop <span class="ot">&lt;-</span> <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(<span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop),</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>                  <span class="at">events =</span> <span class="fu">list</span>(death_event,birth_event),</span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>                  <span class="at">parameters =</span> params)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</section>
<section id="sec-package-simulation" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="sec-package-simulation"><span class="header-section-number">5.4</span> Simulation</h2>
<p>The simulation of the IBM is based on the algorithms presented in <a href="#sec-simulation-algo" class="quarto-xref">Section&nbsp;4.2</a> and <a href="#sec-simulation-randomized" class="quarto-xref">Section&nbsp;4.3</a>. The user has first to specify bounds for the intensity or interaction functions of each event type. The random evolution of the population can then be simulated over a period of time <span class="math inline">[0,T]</span> by calling the function <code>popsim</code>.</p>
<p><em>Events bounds</em></p>
<p>Since the IBM simulation algorithm is based on an acceptance-rejection method for simulating random times, the user has to specify bounds for the intensity (or interaction) functions of each event (see <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>). These bounds should be stored in a named vector, where for event <span class="math inline">e</span>, the name corresponding to the event bound <span class="math inline">\bar{\mu}^e</span>, <span class="math inline">\bar{\lambda}^e</span> or <span class="math inline">\bar{W}^e</span> is the event <code>name</code> defined during the event creation step.</p>
<p>In <a href="#exm-model-creation" class="quarto-xref">Example&nbsp;2</a> from previous section the intensity bound for birth events is <span class="math inline">\bar\lambda_b</span>. Since the death intensity function is not bounded, the user will have to specify a maximum age <span class="math inline">a_{\max}</span> in <code>popsim</code> (all individuals above <span class="math inline">a_{\max}</span> die automatically). Then, the bound for death events is <span class="math inline">\bar \lambda_d = \alpha\exp(\beta a_{\max}).</span> In the example, the death event has been named <code>my_death_event</code>. No name has been specified for the birth event which thus has the default name <code>birth</code>. Then,</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>a_max <span class="ot">&lt;-</span> <span class="dv">120</span> <span class="co"># maximum age</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>events_bounds <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"my_death_event"</span> <span class="ot">=</span> params<span class="sc">$</span><span class="fu">death_rate</span>(a_max),</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>                   <span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">max</span>(params<span class="sc">$</span>birth_rate))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Once the model and events bounds have been defined, a random trajectory of the population can be simulated by calling</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(model, pop, events_bounds, params,</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">age_max =</span> a_max, <span class="at">time =</span> <span class="dv">30</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><em>Optional parameters</em></p>
<p>If there are no events with intensity of class <code>interaction</code>, then the simulation can be parallelized easily by setting the optional parameter <code>multithreading</code> (<code>FALSE</code> by default) to <code>TRUE</code>. By default, the number of threads is the number of concurrent threads supported by the available hardware implementation. The number of threads can be set manually with the optional argument <code>num_threads</code>. By default, when the proportion of dead individuals in the population exceeds <span class="math inline">10\%</span>, dead individuals are removed from the current population used in the algorithm (see <a href="#rem-remvoval-dead" class="quarto-xref">Remark&nbsp;3</a>). The user can modify this ratio using the optional argument <code>clean_ratio</code>, or by removing dead individuals from the population with a certain frequency, given by the <code>clean_step</code> argument. Finally, the user can also define the seed of the random number generator stored in the argument <code>seed</code>.</p>
<p><em>Outputs and treatment of swap events</em></p>
<p>The output of the <code>popsim</code> function is a list containing three elements: a data frame <code>population</code> containing the output population <span class="math inline">Z_T</span> (or a list of populations <span class="math inline">(Z_{t_1}, \dots Z_{t_n})</span> if <code>time</code> is a vector of times), a numeric vector <code>logs</code> of variables related to the simulation algorithm (including the simulation time and number of proposed/accepted events), and the list <code>arguments</code> of the simulation inputs, including the initial population, parameters and event bounds used for the simulation.</p>
<p>When there are no swap events (individuals don’t change of characteristics), the evolution of the population over the period <span class="math inline">[0,T]</span> is recorded in a single data frame <code>sim_out$population</code> where each line contains the information of an individual who lived in the population over the period <span class="math inline">[0,T]</span> (see <a href="#rem-popfinale" class="quarto-xref">Remark&nbsp;1</a>).</p>
<p>When there are swap events (individuals can change of characteristics), recording the dates of swap events and changes of characteristics following each swap event and for each individual in the population is a memory intensive and computationally costly process. To maintain efficient simulations in the presence of swap events, the argument <code>time</code> of <code>popsim</code> can be defined as a vector of dates <span class="math inline">(t_0,\dots, t_n)</span>. In this case, <code>popsim</code> returns in the object <code>population</code> a list of <span class="math inline">n</span> populations representing the population at time <span class="math inline">t_1,\dots t_n</span>, simulated from the initial time <span class="math inline">t_0</span>. For <span class="math inline">i=1\dots n</span>, the <span class="math inline">i</span>th data frame is the population <span class="math inline">Z_{t_i}</span>, i.e. individuals who lived in the population during the period <span class="math inline">[t_0,t_i]</span>, with their characteristics at time <span class="math inline">t_i</span>.</p>
<p>It is also possible to isolate the individuals’ life course, by adding an <code>id</code> column to the population, which can be done by setting <code>id=TRUE</code> in the population construction, or by calling the <code>add_characteristic</code> function to an existing population, in order to identify each individual with a unique integer.</p>
<p>Base functions to study the simulation outputs are provided in the package. For instance, the population age pyramid can computed at a given time, as well as death and exposure tables. Several illustrations of the outputs functions are given in the example <a href="#sec-insurance-portfolio" class="quarto-xref">Section&nbsp;6</a> and <a href="#sec-example-interaction" class="quarto-xref">Section&nbsp;7</a>.</p>
</section>
</section>
<section id="sec-insurance-portfolio" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Insurance portfolio</h1>
<p>This section provides an example of how to use the <code>IBMPopSim</code> package to simulate a heterogeneous life insurance portfolio (see also&nbsp;<a href="https://daphnegiorgi.github.io/IBMPopSim/articles/IBMPopSim_insurance_portfolio.html"><code>vignette(IBMPopSim_insurance_portfolio)</code></a>).</p>
<p>We consider an insurance portfolio consisting of male policyholders, of age greater than 65. These policyholders are characterized by their age, assumed to be less than <span class="math inline">a_{\max} = 110</span>, and risk class <span class="math inline">x \in \mathcal X = \{1, 2\}</span>.</p>
<p><strong>Entries in the portfolio</strong> New policyholders enter the population at a constant Poisson rate <span class="math inline">\mu^{en}=\lambda</span>, which means that on average, <span class="math inline">\lambda</span> individuals enter the portfolio each year. A new individual enters the population at an age a that is uniformly distributed between 65 and 70, and is in risk class 1 with probability <span class="math inline">p</span>.</p>
<p><strong>Death events</strong> A baseline age and time specific death rate is first calibrated on “England and Wales (EW)” males mortality historic data (source: Human Mortality Database&nbsp;<a href="https://www.mortality.org/" class="uri">https://www.mortality.org/</a>), and projected for 30 years using the Lee-Carter model with the package <code>StMoMo</code> (see&nbsp;<span class="citation" data-cites="stmomo">A. M. Villegas, Kaishev, and Millossovich (<a href="#ref-stmomo" role="doc-biblioref">2018</a>)</span>). The forecasted baseline death intensity is denoted by <span class="math inline">d(t,a)</span>, defined by: <span id="eq-insurance-baseline"><span class="math display">
d(t,a) = \sum_{k=0}^{29}\mathbf{1}_{\{k\leq t &lt; k+1\}} d_k(a), \quad \forall \; t\in [0,30] \text{ and } a \in [65, a_{\max}],
\tag{16}</span></span> with <span class="math inline">d_k(a)</span> the point estimate of the forecasted mortality rate for age <span class="math inline">a</span> and year <span class="math inline">k</span>.<br>
Individuals in risk class 1 are assumed to have mortality rates that are 20% higher than the baseline mortality (for instance, the risk class could refer to smokers), while individuals in risk class 2 are assumed to have mortality rates that are 20% lower than the baseline (non smokers). The death intensity of an individual <span class="math inline">I= (\tau_b, \infty, x)</span>, of age <span class="math inline">a(I,t) = t - \tau_b</span> at time <span class="math inline">t</span> and in risk class <span class="math inline">x \in \{1, 2\}</span> is thus the function <span class="math display">
\lambda^d(t,I) = \alpha_x d(t,a(I,t)), \quad \alpha_1 = 1.2, \quad \alpha_2 = 0.8.
</span> In particular, the death intensity verifies <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a> since: <span id="eq-insurance-bound-deathrates"><span class="math display">
\lambda^d(t,I) \leq \bar d : = \alpha_1 \sup_{t \in [0,30]} d(t,a_{\max}).
\tag{17}</span></span></p>
<p><strong>Exits from the portfolio</strong> Individuals exit the portfolio at a constant (individual) rate <span class="math inline">\lambda^{ex}(t,I) = \mu^{i}</span> only depending on their risk class <span class="math inline">i\in \{1,2\}</span>.</p>
<section id="insurance-population" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="insurance-population"><span class="header-section-number">6.1</span> Population</h2>
<p>We start with an initial population of <span class="math inline">30\,000</span> males of age 65, distributed uniformly in each risk class. The population data frame has thus the two (mandatory) columns <code>birth</code> (here the initial time is <span class="math inline">t_0=0</span>) and <code>death</code> (<code>NA</code> if alive), and an additional column <code>risk_cls</code> corresponding to the policyholders risk class. Since there are entry and exit events, the <code>entry</code> and <code>out</code> flags of the population constructor are set to <code>TRUE</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">30000</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>pop_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">rep</span>(<span class="sc">-</span><span class="dv">65</span>,N), <span class="st">"death"</span> <span class="ot">=</span> <span class="fu">rep</span>(<span class="cn">NA</span>,N),</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>                     <span class="st">"risk_cls"</span> <span class="ot">=</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>,<span class="at">each=</span>N<span class="sc">/</span><span class="dv">2</span>))</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(pop_df, <span class="at">entry=</span><span class="cn">TRUE</span>, <span class="at">out=</span><span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="insurance-events" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="insurance-events"><span class="header-section-number">6.2</span> Events</h2>
<p><strong>Entry events</strong> The age of the new individual is determined by the <code>kernel_code</code> argument in the <code>mk_event_poisson</code> function.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>entry_params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"lambda"</span> <span class="ot">=</span> <span class="dv">30000</span>, <span class="st">"p"</span> <span class="ot">=</span> <span class="fl">0.5</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>entry_event <span class="ot">&lt;-</span> <span class="fu">mk_event_poisson</span>(</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"entry"</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity =</span> <span class="st">"lambda"</span>,</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">kernel_code =</span> <span class="st">"if (CUnif() &lt; p) newI.risk_cls =1;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="st">                   else newI.risk_cls= 2;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="st">                   double a = CUnif(65, 70);</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.set_age(a, t);"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Note that the variables <code>newI</code> and <code>t</code>, as well as the function <code>CUnif()</code>, are implicitly defined and usable in the <code>kernel_code</code>. The field <code>risk_cls</code> comes from the names of characteristics of individuals in the population. The names <code>lambda</code> and <code>p</code> are parameter names that will be specified in the <code>R</code> named list <code>params</code>.</p>
<p>Here we use a constant <span class="math inline">\lambda</span> as the event intensity, but we could also use a rate <span class="math inline">\lambda(t)</span> that depends on time, using the function <code>mk_event_poisson_inhomogeneous</code>.</p>
<p><strong>Death and exit events</strong> The baseline death intensity defined in <a href="#eq-insurance-baseline" class="quarto-xref">Equation&nbsp;16</a> and obtained with the package <code>StMoMo</code> is stored in the variable <code>death_male</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># StMoMo death rates</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">'StMoMo'</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(<span class="st">'reshape2'</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>EWStMoMoMale <span class="ot">&lt;-</span> <span class="fu">StMoMoData</span>(EWdata_hmd, <span class="at">series =</span> <span class="st">"male"</span>)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>LC <span class="ot">&lt;-</span> <span class="fu">lc</span>()</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>ages.fit <span class="ot">&lt;-</span> <span class="dv">65</span><span class="sc">:</span><span class="dv">100</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>years.fit <span class="ot">&lt;-</span> <span class="dv">1950</span><span class="sc">:</span><span class="dv">2016</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>LCfitMale <span class="ot">&lt;-</span> <span class="fu">fit</span>(LC, <span class="at">data =</span> EWStMoMoMale, <span class="at">ages.fit =</span> ages.fit, <span class="at">years.fit =</span> years.fit)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>t <span class="ot">&lt;-</span> <span class="dv">30</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>LCforecastMale <span class="ot">&lt;-</span> <span class="fu">forecast</span>(LCfitMale, <span class="at">h =</span> t)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>d_k <span class="ot">&lt;-</span> <span class="fu">apply</span>(LCforecastMale<span class="sc">$</span>rates, <span class="dv">2</span>, <span class="cf">function</span>(x) <span class="fu">stepfun</span>(<span class="dv">66</span><span class="sc">:</span><span class="dv">100</span>, x))</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>breaks <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">29</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>death_male <span class="ot">&lt;-</span> <span class="fu">piecewise_xy</span>(breaks,d_k)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The death and exit intensities are of class <code>individual</code> (see <a href="#tbl-intensity-classes" class="quarto-xref">Table&nbsp;2 (a)</a>). Hence, the death and exit events are created with the <code>mk_event_individual</code> function.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>death_params <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"death_male"</span> <span class="ot">=</span> death_male, <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">1.2</span>, <span class="fl">0.8</span>))</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity_code =</span> <span class="st">"result = alpha[I.risk_cls-1] * death_male(t, I.age(t));"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>exit_params <span class="ot">=</span> <span class="fu">list</span>(<span class="st">"mu"</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.001</span>, <span class="fl">0.06</span>))</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>exit_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">type =</span> <span class="st">"exit"</span>,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">intensity_code =</span> <span class="st">"result = mu[I.risk_cls-1]; "</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="insurance-simulation" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="insurance-simulation"><span class="header-section-number">6.3</span> Model creation and simulation</h2>
<p>The model is created from all the previously defined building blocks, by calling the <code>mk_model</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">events =</span> <span class="fu">list</span>(entry_event, death_event, exit_event),</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(entry_params, death_params, exit_params))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Once the model is compiled, it can be used with different parameters and run simulations for various scenarios. Similarly, the initial population (here <code>pop_df</code>) can be modified without rerunning the <code>mk_model</code> function. The bounds for entry events is simply the intensity <span class="math inline">\lambda</span>. For death events, the bound is given by <span class="math inline">\bar{d}</span> defined in <a href="#eq-insurance-bound-deathrates" class="quarto-xref">Equation&nbsp;17</a>, which is stored in the <code>death_max</code> variable.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>death_max <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">sapply</span>(d_k, <span class="cf">function</span>(x) { <span class="fu">max</span>(x) }))</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>bounds <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"entry"</span> <span class="ot">=</span> entry_params<span class="sc">$</span>lambda,</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>            <span class="st">"death"</span> <span class="ot">=</span> death_max,</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>            <span class="st">"exit"</span> <span class="ot">=</span> <span class="fu">max</span>(exit_params<span class="sc">$</span>mu))</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">model =</span> model,</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">initial_population =</span> pop_init,</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">events_bounds =</span> bounds,</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(entry_params, death_params, exit_params),</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">time =</span> <span class="dv">30</span>,</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">age_max =</span> <span class="dv">110</span>,</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">multithreading =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="outputs" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="outputs"><span class="header-section-number">6.4</span> Outputs</h2>
<p>The data frame <code>sim_out$population</code> consists of all individuals present in the portfolio during the period of <span class="math inline">[0, 30]</span>, including the individuals in the initial population and those who entered the portfolio. Each row represents an individual, with their date of birth, date of death (<code>NA</code> if still alive at the end of the simulation), risk class, and characteristics <code>entry</code> and <code>out</code>. Recall that if an individual enters the population at time <span class="math inline">t</span>, his <code>entry</code> characteristic is automatically set up to be equal to <span class="math inline">t</span>. The characteristics <code>out</code> is set to <code>TRUE</code> for individuals who left the portfolio due to an exit event.</p>
<p>In this example, the simulation time over 30 years, starting from an initial population of 30 000 individuals is very fast (see below), for an acceptance rate of proposed event of approximately 25%. At the end of the simulation, the number of alive individuals is approximately 430 000.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Number of alive individuals in the population at final time T=30 : 428217"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Execution time : 0.83s"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Proportion of effective events and proposed events : 0.25"</code></pre>
</div>
</div>
<p>Initially in the portfolio (at <span class="math inline">t=0</span>), there is the same number of 65 years old policyholders in each risk class. However, policyholders in the risk class 2 with lower mortality rates leave the portfolio at higher rate than policyholders in the risk class 1 : <span class="math inline">\mu^2 &gt; \mu^1</span>. Therefore, the heterogeneous portfolio composition changes with time, including more and more individuals in risk class 1 with higher mortality rates, but with variations across age classes. To illustrate the composition of the total population at the end of the simulation (<span class="math inline">t=30</span>), we present in <a href="#fig-insur-a" class="quarto-xref">Figure&nbsp;2</a> the age pyramid of the final composition of the portfolio obtained with the <code>age_pyramid</code> and <code>plot</code> functions of the <code>pyramid</code> class.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-insur-a" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="H">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-insur-a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published_202412-giorgi-efficient_files/figure-html/fig-insur-a-1.svg" class="img-fluid figure-img" data-fig-pos="H">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-insur-a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Portfolio age pyramid at t = 30 for individuals in risk class 1 (blue) and 2 (red).
</figcaption>
</figure>
</div>
</div>
</div>
<p><code>IBMPopSim</code> also allows the fast computation of exact life tables from truncated and censored individual data (due to entry and exit events), using the functions <code>death_table</code> and <code>exposure_table</code>. These function are particularly efficient, since the computations are made using the <code>Rccp</code> library.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>age_grp <span class="ot">&lt;-</span> <span class="dv">65</span><span class="sc">:</span><span class="dv">95</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>Dx_pop <span class="ot">&lt;-</span> <span class="fu">death_table</span>(sim_out<span class="sc">$</span>population, <span class="at">ages =</span> age_grp, <span class="at">period =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">30</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>Ex_pop <span class="ot">&lt;-</span> <span class="fu">exposure_table</span>(sim_out<span class="sc">$</span>population, <span class="at">ages =</span> age_grp, <span class="at">period =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">30</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>mx_pop <span class="ot">&lt;-</span> Dx_pop<span class="sc">/</span>Ex_pop</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In <a href="#fig-insur-b" class="quarto-xref">Figure&nbsp;3</a>, we illustrate the central death rates in the simulated portfolio at final time. Due to the mortality differential between risk class 1 and 2, one would expect to observe more individuals in risk class 2 at higher ages. However, due to exit events, a higher proportion of individuals in risk class 1 exit the portfolio over time, resulting in a greater proportion of individuals in risk class 1 at higher ages than what would be expected in the absence of exit events. Consequently, the mortality rates in the portfolio are more aligned with those of risk class 1 at higher ages. This is a simple example of how composition changes in the portfolio can impact aggregated mortality rates and potentially compensate or reduce an overall mortality reduction (see also <span class="citation" data-cites="KAAKAI201916">(<a href="#ref-KAAKAI201916" role="doc-biblioref">Kaakaï et al. 2019</a>)</span>).</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-insur-b" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-insur-b-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published_202412-giorgi-efficient_files/figure-html/fig-insur-b-1.svg" class="img-fluid figure-img" data-fig-pos="h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-insur-b-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Portfolio central death rates at t = 30 (black).
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-example-interaction" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Population with genetically variable traits</h1>
<p>This section provides an example of how to use the <code>IBMPopSim</code> package to simulate an age-structured population with interactions, based on the model proposed in Example 1 of <span class="citation" data-cites="FerTra09">Ferrière and Tran (<a href="#ref-FerTra09" role="doc-biblioref">2009</a>)</span> (see also <span class="citation" data-cites="meleard2009trait">Méléard and Tran (<a href="#ref-meleard2009trait" role="doc-biblioref">2009</a>)</span>).</p>
<p>In this model, individuals are characterized by their body size at birth <span class="math inline">x_0 \in [0,4]</span> and by their physical age <span class="math inline">a \in [0,2]</span>. The body size of an individual <span class="math inline">I=(\tau^b,\infty, x_0)</span> at time <span class="math inline">t</span> is a linear function of its age <span class="math inline">a(I,t) = t-\tau^b</span>: <span class="math display">x(t)= x_0 + ga(I,t),</span> where <span class="math inline">g</span> is a constant growth rate assumed to be identical for all individuals.</p>
<p><strong>Birth events</strong> The birth intensity of each individual <span class="math inline">I=(\tau^b, \infty, x_0)</span> depends on a parameter <span class="math inline">\alpha &gt; 0</span> and on its initial size, as given by the equation <span id="eq-interaction-birth-intensity"><span class="math display">
\lambda^b(t,I) = \alpha (4 - x_0) \leq \bar \lambda^b = 4\alpha.
\tag{18}</span></span> Thus, smaller individuals have a higher birth intensity. When a birth occurs, the new individual inherits the same birth size <span class="math inline">x_0</span> as its parent with high probability <span class="math inline">1-p</span>, or a mutation can occur with probability <span class="math inline">p</span>, resulting in a birth size given by <span id="eq-interaction-birth-kernel"><span class="math display">
    x_0' = \min(\max(0, x_0 + G), 4),
\tag{19}</span></span> where <span class="math inline">G</span> is a Gaussian random variable with mean 0 and variance <span class="math inline">\sigma^2</span>.</p>
<p><strong>Death events</strong> Due to competition between individuals, the death intensity of an individual depends on the size of other individuals in the population. Bigger individuals have a better chance of survival. If an individual <span class="math inline">I= (\tau^b, \infty, x_0)</span> of size <span class="math inline">x(t)= x_0 +ga(I,t)</span> encounters an individual <span class="math inline">J= (\tau^{b}_J, \infty, x_0')</span> of size <span class="math inline">x'(t) = x_0'+ ga(J,t)</span>, then it can die with the intensity <span class="math display">W(t, I,J) = U(x(t),x'(t)),</span> where the interaction function <span class="math inline">U</span> is defined by <span id="eq-interaction-death-intensity"><span class="math display">
    U(x,y) = \beta \left(1- \frac{1}{1+ c\exp(-4(x-y))}\right) \leq \bar W = \beta.
\tag{20}</span></span> The death intensity of an individual <span class="math inline">I</span> at time <span class="math inline">t</span> and in a population <span class="math inline">Z</span> is the result of interactions with all individuals in the population, including itself, and is given by <span class="math display">\lambda^d_t(I,Z) = \sum_{J = (\tau^b,\infty, x_0') \in Z}  W (x_0 + g a(I,t), x_0' + g a(J,t)),</span></p>
<section id="population" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="population"><span class="header-section-number">7.1</span> Population</h2>
<p>We use an initial population of 900 living individuals, all of whom have the same size and ages uniformly distributed between 0 and 2 years.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">900</span> </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>x0 <span class="ot">&lt;-</span> <span class="fl">1.06</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>agemin <span class="ot">&lt;-</span> <span class="fl">0.</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>agemax <span class="ot">&lt;-</span> <span class="fl">2.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>pop_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="sc">-</span><span class="fu">runif</span>(N, agemin, agemax), <span class="co"># Uniform age in [0,2]</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> <span class="fu">as.double</span>(<span class="cn">NA</span>), <span class="co"># All individuals are alive</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_size"</span> <span class="ot">=</span> x0) <span class="co"># All individuals have the same initial birth size x0</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(pop_df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="events" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="events"><span class="header-section-number">7.2</span> Events</h2>
<section id="birth-events" class="level3" data-number="7.2.1">
<h3 data-number="7.2.1" class="anchored" data-anchor-id="birth-events"><span class="header-section-number">7.2.1</span> Birth events</h3>
<p>The parameters involved in a birth event are the probability of mutation <span class="math inline">p</span>, the variance of the Gaussian random variable and the coefficient <span class="math inline">\alpha</span> of the intensity.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>params_birth <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"p"</span> <span class="ot">=</span> <span class="fl">0.03</span>, <span class="st">"sigma"</span> <span class="ot">=</span> <span class="fu">sqrt</span>(<span class="fl">0.01</span>), <span class="st">"alpha"</span> <span class="ot">=</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The birth intensity <a href="#eq-interaction-birth-intensity" class="quarto-xref">Equation&nbsp;18</a> is of class <code>individual</code>. Hence, the event is created by calling the <code>mk_event_individual</code> function. The size of the new individual is given in the kernel following <a href="#eq-interaction-birth-kernel" class="quarto-xref">Equation&nbsp;19</a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>( </span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>,</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha*(4 - I.birth_size);"</span>,</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"if (CUnif() &lt; p)</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.birth_size = min(max(0.,CNorm(I.birth_size,sigma)),4.);</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="st">                 else</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.birth_size = I.birth_size;"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="death-events" class="level3" data-number="7.2.2">
<h3 data-number="7.2.2" class="anchored" data-anchor-id="death-events"><span class="header-section-number">7.2.2</span> Death events</h3>
<p>The death intensity <a href="#eq-interaction-death-intensity" class="quarto-xref">Equation&nbsp;20</a> is of class <code>interaction</code>. Hence, the event is created by calling the <code>mk_event_interaction</code> function. The parameters used for this event are the growth rate <span class="math inline">g</span>, the amplitude of the interaction function <span class="math inline">\beta</span>, and the strength of competition <span class="math inline">c</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>params_death <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"g"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">2.</span><span class="sc">/</span><span class="fl">300.</span>, <span class="st">"c"</span> <span class="ot">=</span> <span class="fl">1.2</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_interaction</span>(</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">interaction_code =</span> <span class="st">"double x_I = I.birth_size + g * age(I,t);</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="st">                      double x_J = J.birth_size + g * age(J,t);</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="st">                      result = beta*(1.-1./(1.+c*exp(-4.*(x_I-x_J))));"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="model-creation-and-simulation" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="model-creation-and-simulation"><span class="header-section-number">7.3</span> Model creation and simulation</h2>
<p>The model is created using the <code>mk_model</code> function.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">events =</span> <span class="fu">list</span>(birth_event, death_event),</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The simulation of one scenario can then be launched with the call of the <code>popsim</code> function, after computing the events bounds <span class="math inline">\bar \lambda^b=4 \alpha</span> and <span class="math inline">\bar W= \beta</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(<span class="at">model =</span> model,</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">initial_population =</span> pop_init,</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">events_bounds =</span> <span class="fu">c</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="dv">4</span> <span class="sc">*</span> params_birth<span class="sc">$</span>alpha, </span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>                      <span class="st">"death"</span> <span class="ot">=</span> params_death<span class="sc">$</span>beta),</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death),</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">age_max =</span> <span class="dv">2</span>,</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">time =</span> <span class="dv">500</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Based on the results of a simulation, we can reproduce the numerical results of <span class="citation" data-cites="FerTra09">Ferrière and Tran (<a href="#ref-FerTra09" role="doc-biblioref">2009</a>)</span>. In <a href="#fig-birth-size" class="quarto-xref">Figure&nbsp;4</a>, we draw a line for each individual in the population to represent their birth size during their lifetime.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-birth-size" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-pos="h">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-birth-size-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="published_202412-giorgi-efficient_files/figure-html/fig-birth-size-1.png" class="img-fluid figure-img" data-fig-pos="h">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-birth-size-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Evolution of birth size
</figcaption>
</figure>
</div>
</div>
</div>
<p>In this example, the randomized <a href="#alg-randomized" class="quarto-xref">Algorithm 3</a> allows for much faster computation times than the model implemented below with <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a> (“full” algorithm):</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>death_event_full <span class="ot">&lt;-</span> <span class="fu">mk_event_interaction</span>(<span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">interaction_type=</span> <span class="st">"full"</span>,</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">interaction_code =</span> <span class="st">"double x_I = I.birth_size + g * age(I,t);</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="st">                        double x_J = J.birth_size + g * age(J,t);</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="st">                        result = beta * ( 1.- 1./(1. + c * exp(-4. * (x_I-x_J))));"</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>model_full <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(<span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">events =</span> <span class="fu">list</span>(birth_event, death_event_full),</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death))</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>sim_out_full <span class="ot">&lt;-</span> <span class="fu">popsim</span>(<span class="at">model =</span> model_full,</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">initial_population =</span> pop_init,</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">events_bounds =</span><span class="fu">c</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="dv">4</span> <span class="sc">*</span> params_birth<span class="sc">$</span>alpha, <span class="st">"death"</span> <span class="ot">=</span> params_death<span class="sc">$</span>beta),</span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death),</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">age_max =</span> <span class="dv">2</span>,</span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">time =</span> <span class="dv">500</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "The full algorithm is 16 times slower than the randomized version"</code></pre>
</div>
</div>
<p>In <a href="#fig-fullvsrandom" class="quarto-xref">Figure&nbsp;5</a>, the two algorithms are compared for different population sizes. We progressively decrease the value of the mortality rate parameter <span class="math inline">\beta</span> and increase the birth rate parameter <span class="math inline">\alpha</span>. Starting with the values provided in&nbsp;<span class="citation" data-cites="FerTra09">Ferrière and Tran (<a href="#ref-FerTra09" role="doc-biblioref">2009</a>)</span>, <span class="math inline">\alpha=1</span> and <span class="math inline">\beta=2/300</span>, resulting in a stationary population size of approximately <span class="math inline">N=360</span> individuals for a sample of 50 simulations, we can easily increase the stationary population size to approximately <span class="math inline">N=2600</span> individuals with <span class="math inline">\alpha=2</span> and <span class="math inline">\beta=1/300</span>.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> In the log-scaled figure, we can observe the trend of computation time as a function of the population size <span class="math inline">N</span>, which is linear for the randomized algorithm and quadratic for the full one ( <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a>). We can also see that the randomized version of the algorithm is between 17 to 100 times faster than the full one in this example, taking only 2 seconds in average for the randomized version versus 211 seconds for <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a> for the biggest population size (<span class="math inline">N=2600</span>) and <span class="math inline">T=500</span>.</p>
<div id="fig-fullvsrandom" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-fullvsrandom-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="img/time_pop_size.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-fullvsrandom-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Full vs random algorithm computation time
</figcaption>
</figure>
</div>
</section>
</section>

<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-BanMel15" class="csl-entry" role="listitem">
Bansaye, Vincent, and Sylvie Méléard. 2015. <em>Stochastic Models for Structured Populations</em>. Springer International Publishing.
</div>
<div id="ref-barrieu2012understanding" class="csl-entry" role="listitem">
Barrieu, Pauline, Harry Bensusan, Nicole El Karoui, Caroline Hillairet, Stéphane Loisel, Claudia Ravanelli, and Yahia Salhi. 2012. <span>“Understanding, Modelling and Managing Longevity Risk: Key Issues and Main Challenges.”</span> <em>Scandinavian Actuarial Journal</em> 2012 (3): 203–31.
</div>
<div id="ref-Ben10" class="csl-entry" role="listitem">
Bensusan, Harry. 2010. <span>“<span class="nocase">Interest rate and longevity risk: dynamic model and applications to derivative products and life insurance</span>.”</span> Theses, <span>Ecole Polytechnique X</span>.
</div>
<div id="ref-billiard2016effect" class="csl-entry" role="listitem">
Billiard, Sylvain, Pierre Collet, Régis Ferrière, Sylvie Méléard, and Viet Chi Tran. 2016. <span>“The Effect of Competition and Horizontal Trait Inheritance on Invasion, Fixation, and Polymorphism.”</span> <em>Journal of Theoretical Biology</em> 411: 48–58.
</div>
<div id="ref-Bou16" class="csl-entry" role="listitem">
Boumezoued, Alexandre. 2016. <span>“<span class="nocase">Micro-macro analysis of heterogenous age-structured populations dynamics.Application to self-exciting processes and demography.</span>”</span> Theses, <span>Universit<span>é</span> Pierre et Marie Curie</span>.
</div>
<div id="ref-bremaud1981point" class="csl-entry" role="listitem">
Brémaud, Pierre. 1981. <em>Point Processes and Queues: Martingale Dynamics</em>. Vol. 66. Springer.
</div>
<div id="ref-calvez2020horizontal" class="csl-entry" role="listitem">
Calvez, Vincent, Susely Figueroa Iglesias, Hélène Hivert, Sylvie Méléard, Anna Melnykova, and Samuel Nordmann. 2020. <span>“Horizontal Gene Transfer: Numerical Comparison Between Stochastic and Deterministic Approaches.”</span> <em>ESAIM: Proceedings and Surveys</em> 67: 135–60.
</div>
<div id="ref-Cin11" class="csl-entry" role="listitem">
Çinlar, Erhan. 2011. <em><span class="nocase">Probability and Stochastics</span></em>. Springer New York.
</div>
<div id="ref-collet2013rigorous" class="csl-entry" role="listitem">
Collet, Pierre, Sylvie Méléard, and Johan AJ Metz. 2013. <span>“A Rigorous Model Study of the Adaptive Dynamics of Mendelian Diploids.”</span> <em>Journal of Mathematical Biology</em> 67: 569–607.
</div>
<div id="ref-costa2016stochastic" class="csl-entry" role="listitem">
Costa, Manon, Céline Hauzy, Nicolas Loeuille, and Sylvie Méléard. 2016. <span>“Stochastic Eco-Evolutionary Model of a Prey-Predator Community.”</span> <em>Journal of Mathematical Biology</em> 72: 573–622.
</div>
<div id="ref-Dev86" class="csl-entry" role="listitem">
Devroye, Luc. 1986. <em>Nonuniform Random Variate Generation</em>. Springer-Verlag, New York.
</div>
<div id="ref-JSSv040i08" class="csl-entry" role="listitem">
Eddelbuettel, Dirk, and Romain Francois. 2011. <span>“Rcpp: Seamless r and c++ Integration.”</span> <em>Journal of Statistical Software</em> 40 (8): 1–18. <a href="https://doi.org/10.18637/jss.v040.i08">https://doi.org/10.18637/jss.v040.i08</a>.
</div>
<div id="ref-karoui2021simulating" class="csl-entry" role="listitem">
El Karoui, Nicole, Kaouther Hadji, and Sarah Kaakai. 2021. <span>“Simulating Long-Term Impacts of Mortality Shocks: Learning from the Cholera Pandemic.”</span> <em>arXiv Preprint arXiv:2111.08338</em>.
</div>
<div id="ref-FerTra09" class="csl-entry" role="listitem">
Ferrière, Régis, and Viet Chi Tran. 2009. <span>“Stochastic and Deterministic Models for Age-Structured Populations with Genetically Variable Traits.”</span> In, 27:289–310. ESAIM Proc. EDP Sci., Les Ulis.
</div>
<div id="ref-FouMel04" class="csl-entry" role="listitem">
Fournier, Nicolas, and Sylvie Méléard. 2004. <span>“A Microscopic Probabilistic Description of a Locally Regulated Population and Macroscopic Approximations.”</span> <em>Ann. Appl. Probab.</em> 14 (4): 1880–1919.
</div>
<div id="ref-Rdemography" class="csl-entry" role="listitem">
Hyndman, Rob, Heather Booth Booth, Leonie Tickle Tickle, John Maindonald, Simon Wood Wood, and R Core Team. 2023. <em><span class="nocase">demography</span>: Forecasting Mortality, Fertility, Migration and Population Data</em>. <a href="https://cran.r-project.org/package=demography">https://cran.r-project.org/package=demography</a>.
</div>
<div id="ref-KaaElK20" class="csl-entry" role="listitem">
Kaakai, Sarah, and Nicole El Karoui. 2023. <span>“Birth Death Swap Population in Random Environment and Aggregation with Two Timescales.”</span> <em>Stochastic Processes and Their Applications</em> 162: 218–48. https://doi.org/<a href="https://doi.org/10.1016/j.spa.2023.04.017">https://doi.org/10.1016/j.spa.2023.04.017</a>.
</div>
<div id="ref-KAAKAI201916" class="csl-entry" role="listitem">
Kaakaï, Sarah, Héloïse Labit Hardy, Séverine Arnold, and Nicole El Karoui. 2019. <span>“How Can a Cause-of-Death Reduction Be Compensated for by the Population Heterogeneity? A Dynamic Approach.”</span> <em>Insurance: Mathematics and Economics</em> 89: 16–37. https://doi.org/<a href="https://doi.org/10.1016/j.insmatheco.2019.07.005">https://doi.org/10.1016/j.insmatheco.2019.07.005</a>.
</div>
<div id="ref-Kal17" class="csl-entry" role="listitem">
Kallenberg, Olav. 2017. <em>Random Measures, Theory and Applications</em>. Vol. 77. Probability Theory and Stochastic Modelling. Springer, Cham.
</div>
<div id="ref-lavallee2019stochastic" class="csl-entry" role="listitem">
Lavallée, François, Charline Smadi, Isabelle Alvarez, Björn Reineking, François-Marie Martin, Fanny Dommanget, and Sophie Martin. 2019. <span>“A Stochastic Individual-Based Model for the Growth of a Stand of Japanese Knotweed Including Mowing as a Management Technique.”</span> <em>Ecological Modelling</em> 413: 108828.
</div>
<div id="ref-LewShe79" class="csl-entry" role="listitem">
Lewis, Peter, and Gerald Shedler. 1979. <span>“Simulation of Nonhomogeneous Poisson Processes by Thinning.”</span> <em>Naval Research Logistics Quarterly</em> 26 (3): 403–13.
</div>
<div id="ref-meleard2019birth" class="csl-entry" role="listitem">
Méléard, Sylvie, Michael Rera, and Tristan Roget. 2019. <span>“A Birth–Death Model of Ageing: From Individual-Based Dynamics to Evolutive Differential Inclusions.”</span> <em>Journal of Mathematical Biology</em> 79: 901–39.
</div>
<div id="ref-meleard2009trait" class="csl-entry" role="listitem">
Méléard, Sylvie, and Viet Chi Tran. 2009. <span>“Trait Substitution Sequence Process and Canonical Equation for Age-Structured Populations.”</span> <em>Journal of Mathematical Biology</em> 58: 881–921.
</div>
<div id="ref-roget2022positive" class="csl-entry" role="listitem">
Roget, T, Claire Macmurray, P Jolivet, S Méléard, and Michael Rera. 2024. <span>“A Scenario for an Evolutionary Selection of Ageing.”</span> <em>eLife</em> 13.
</div>
<div id="ref-tran_2008" class="csl-entry" role="listitem">
Tran, Viet Chi. 2008. <span>“Large Population Limit and Time Behaviour of a Stochastic Particle Model Describing an Age-Structured Population.”</span> <em>ESAIM: Probability and Statistics</em> 12: 345–86. <a href="https://doi.org/10.1051/ps:2007052">https://doi.org/10.1051/ps:2007052</a>.
</div>
<div id="ref-stmomo" class="csl-entry" role="listitem">
Villegas, Andrés M., Vladimir K. Kaishev, and Pietro Millossovich. 2018. <span>“<span class="nocase">StMoMo: An R Package for Stochastic Mortality Modelling</span>.”</span> <em>Journal of Statistical Software</em> 84: 1–38.
</div>
<div id="ref-Rstmomo" class="csl-entry" role="listitem">
Villegas, Andres, Pietro Millossovich, and Vladimir Kaishev Hyndman. 2018. <em><span>StMoMo</span>: Stochastic Mortality Modelling</em>. <a href="https://cran.r-project.org/package=StMoMo">https://cran.r-project.org/package=StMoMo</a>.
</div>
<div id="ref-Zin14" class="csl-entry" role="listitem">
Zinn, Sabine. 2014. <span>“<span class="nocase">The MicSim package of R: an entry-level toolkit for continuous-time microsimulation</span>.”</span> <em>International Journal of Microsimulation</em> 7 (3): 3–32.
</div>
<div id="ref-zinn2009mic" class="csl-entry" role="listitem">
Zinn, Sabine, Jutta Gampe, Jan Himmelspach, and Adelinde M Uhrmacher. 2009. <span>“MIC-CORE: A Tool for Microsimulation.”</span> In <em>Proceedings of the 2009 Winter Simulation Conference (WSC)</em>, 992–1002. IEEE.
</div>
</div>
</section>



<div id="quarto-appendix" class="default"><section id="appendix" class="level1 appendix" data-number="8"><h2 class="anchored quarto-appendix-heading"><span class="header-section-number">8</span> Appendix</h2><div class="quarto-appendix-contents">


<section id="sec-pathwise-representation" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="sec-pathwise-representation"><span class="header-section-number">8.2</span> Pathwise representation of IBMs</h2>
<p><strong>Notation reminder</strong> The population’s evolution is described by the measure valued process <span class="math inline">(Z_t)_{t\geq 0}</span>. Several types of events <span class="math inline">e</span> can occur to individuals denoted by <span class="math inline">I</span>. If an event of type <span class="math inline">e</span> occur to the individual <span class="math inline">I</span> at time <span class="math inline">t</span>, then the population state <span class="math inline">Z_{t^-}</span> is modified by <span class="math inline">\phi^e(t,I)</span>. If <span class="math inline">e\in \mathcal{E} \cup \mathcal{E}_W</span>, then events of type <span class="math inline">e</span> occur with an intensity <span class="math inline">\sum_{k=1}^{N_t} \lambda_t^e(I,Z_t)</span>, with <span class="math inline">\lambda_t^e(I,Z_t)</span> defined by <a href="#eq-individual-intensity" class="quarto-xref">Equation&nbsp;7</a>. If <span class="math inline">e \in \mathcal{P}</span>, then events of type <span class="math inline">e</span> occur in the population at a Poisson intensity of <span class="math inline">(\mu^e_t)</span>.</p>
<section id="sec-prf-thm-eq-Z" class="level3" data-number="8.2.1">
<h3 data-number="8.2.1" class="anchored" data-anchor-id="sec-prf-thm-eq-Z"><span class="header-section-number">8.2.1</span> Proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a></h3>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>For ease of notation, we prove the case when <span class="math inline">\mathcal{P} =\emptyset</span> (there are no events with Poisson intensity).</p>
<ul>
<li>Step 1. The existence of a solution to <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> is obtained by induction. Let <span class="math inline">Z^1</span> be the unique solution the thinning equation: <span class="math display">
  Z_t^1 = Z_0 + \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{0}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{0})\}} Q (\mathrm{d}s,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ), \quad \forall  0 \leq t \leq T.
</span> Let <span class="math inline">T_1</span> be the first jump time of <span class="math inline">Z^1</span>. Since <span class="math inline">Z_{s^-}^1 = Z_{0}</span> and <span class="math inline">N_{s^-}=N_{0}</span> on <span class="math inline">[0, T_1]</span>, <span class="math inline">Z^1</span> is solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T_1]</span>.</li>
</ul>
<p>Let us now assume that <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> admits a solution <span class="math inline">Z^n</span> on <span class="math inline">[0,T_n]</span>, with <span class="math inline">T_n</span> the <span class="math inline">n</span>–th event time in the population. Let <span class="math inline">Z^{n+1}</span> be the unique solution of the thinning equation: <span class="math display">
    Z^{n+1}_t  =  Z_{t\wedge T_n}^n + \int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{T_n}^n)\}} \mathbf{1}_{\{k \leq N_{T_n}^n \} }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).
</span> First, observe that <span class="math inline">Z^{n+1}</span> coincides with <span class="math inline">Z^n</span> on <span class="math inline">[0,T_n]</span>. Let <span class="math inline">T_{n+1}</span> be the <span class="math inline">(n+1)</span>–th jump of <span class="math inline">Z^{n+1}</span>. Furthermore, <span class="math inline">Z_{s^-}^{n+1} = Z_{T_n}^n</span> and <span class="math inline">N_{s^-}^{n+1}=N_{T_n}^{n}</span> on <span class="math inline">[T_n, T_{n+1}]</span> (nothing happens between two successive event times), <span class="math inline">Z^{n+1}</span> verifies for all <span class="math inline">t\leq T_{n+1}</span>: <span class="math display">
\begin{aligned}
    Z^{n+1}_t  =  Z_{t\wedge T_n}^n +\int_{t\wedge T_n}^{t} \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-}^{n+1} )\}} \mathbf{1}_{\{k \leq N_{s^-}^{n+1} \} }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).
\end{aligned}
</span> Since, <span class="math inline">Z^n</span> is a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T_n]</span> coinciding with <span class="math inline">Z^{n+1}</span> this achieves to prove that <span class="math inline">Z^{n+1}</span> is solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T_{n+1}]</span>. Finally, let <span class="math inline">Z =\lim_{n\to \infty } Z^n</span>. For all <span class="math inline">n\geq 1</span>, <span class="math inline">T_n</span> is the <span class="math inline">n</span>–th event time of <span class="math inline">Z</span>, and <span class="math inline">Z</span> is solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on all time intervals <span class="math inline">[0,T_n\wedge T]</span> by construction.</p>
<p>By <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a> <span class="math inline">T_n \underset{n\to \infty}{\longrightarrow} \infty</span>. Thus, by letting <span class="math inline">n\to \infty</span> we can conclude that <span class="math inline">Z</span> is a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a> on <span class="math inline">[0,T]</span>.</p>
<ul>
<li>Step 2. Let <span class="math inline">\tilde Z</span> be a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>. Using the same arguments than in Step 1, it is straightforward to show that <span class="math inline">\tilde Z</span> coincides with <span class="math inline">Z^n</span> on <span class="math inline">[0,T_n]</span>, for all <span class="math inline">n \geq 1</span>. Thus, <span class="math inline">\tilde{Z} = Z</span>, with achieves to prove uniqueness.</li>
</ul>
</div>
</section>
<section id="sec-prf-lem-non-explosion" class="level3" data-number="8.2.2">
<h3 data-number="8.2.2" class="anchored" data-anchor-id="sec-prf-lem-non-explosion"><span class="header-section-number">8.2.2</span> Proof of <a href="#lem-non-explosion" class="quarto-xref">Lemma&nbsp;1</a></h3>
<p>The proof is obtained using pathwise comparison result, generalizing those obtained in <span class="citation" data-cites="KaaElK20">(<a href="#ref-KaaElK20" role="doc-biblioref">Kaakai and El Karoui 2023</a>)</span>.</p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>Let <span class="math inline">Z</span> be a solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>. For all <span class="math inline">e \in \mathcal{P} \cup \mathcal{E} \cup  \mathcal{E}_W</span>, let <span class="math inline">N^e</span> be the process counting the occurrence of events of type <span class="math inline">e</span> in the population. <span class="math inline">N^e</span> is a counting process of <span class="math inline">\{\mathcal{F}_t\}</span>-intensity <span class="math inline">(\Lambda_t^e(Z_{t^-}))</span>, solution of <span id="eq-Ne"><span class="math display">
\begin{aligned}
  &amp; N_t^e = \int_0^t \int_{{\mathbb{N}}\times {\mathbb{R}}^+} \mathbf{1}_{\{k\leq N_{s^-}\}}  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-})\}} Q(\mathrm{d}s, \mathrm{d}k, \{e\}, \mathrm{d}\theta), &amp; \quad  \textit{ if } e \in \mathcal{E}\cup \mathcal{E}_W, \\
&amp; N_t^e = \int_0^t \int_{{\mathbb{R}}^+} \mathbf{1}_{\{\theta \leq \mu^e_s \}} Q^{\mathcal{P}}(\mathrm{d}s, \{e\}, \mathrm{d}\theta), &amp; \quad  \textit{ if } e \in \cal P. \\
\end{aligned}
\tag{22}</span></span> By definition, the jump times of the multivariate counting process <span class="math inline">(N^e)_{e \in \mathcal{P} \cup \mathcal{E}\cup \mathcal{E}_W}</span> are the population event times <span class="math inline">(T_n)_{n\geq 0}</span>. The idea of the proof is to show that <span class="math inline">(N^e)_{e \in \mathcal{P} \cup \mathcal{E}\cup \mathcal{E}_W}</span> does not explode in finite time, by pathwise domination with a simpler multivariate counting process. The first steps are to control the population size <span class="math inline">N_t = N_0 + N^b_t + N^{en}_t</span>.<br>
</p>
<p><strong>Step 1</strong> Let <span class="math inline">(\bar N^b, \bar N^{en})</span> be the 2-dimensional counting process defined as follows: for <span class="math inline">e \in \{b,en\}</span>, <span class="math inline">\bar N^e_0 = 0</span> and <span id="eq-dominatingprocess"><span class="math display">
\begin{aligned}
&amp; \bar N_t^e = \int_0^t \int_{{\mathbb{N}}\times {\mathbb{R}}^+} \mathbf{1}_{\{k\leq N_0 + \bar N_{s^-} \}}  \mathbf{1}_{\{\theta \leq f^e(N_0 + \bar N_{s^-})\}} Q(\mathrm{d}s, \mathrm{d}k, \{e\}, \mathrm{d}\theta),  \quad  \textit{ if } e \in \mathcal{E}\cup \mathcal{E}_W, \\
&amp;   \bar N_t^e = \int_0^t \int_{{\mathbb{R}}^+} \mathbf{1}_{\{\theta \leq \bar \mu^e\}} Q^{\mathcal{P}}(\mathrm{d}s, \{e\}, \mathrm{d}\theta)  \quad  \textit{ if } e \in \cal P,
\end{aligned}
\tag{23}</span></span> with <span class="math inline">\bar N := \bar N^b + \bar N^{en}</span> and <span class="math inline">f^e</span> the function introduced in <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a>.<br>
- If <span class="math inline">b,en \in \cal P</span>, then <span class="math inline">\bar N</span> is a inhomogeneous Poisson process.<br>
- If <span class="math inline">b,en \in \mathcal{E}\cup \mathcal{E}_W</span>, then it is straightforward to show that conditionally to <span class="math inline">N_0</span>, <span class="math inline">\bar N</span> is a pure birth Markov process with birth intensity function <span class="math inline">g(n) = n\big(f^b(N_0+n) + f^{en}(N_0+n)\big)</span>. In particular, by <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a>, <span class="math inline">g</span> verifies the standard Feller condition for pure birth Markov processes (see e.g. <span class="citation" data-cites="BanMel15">(<a href="#ref-BanMel15" role="doc-biblioref">Bansaye and Méléard 2015</a>)</span>): <span class="math display">\sum_{n=1}^\infty \frac{1}{g(n)}.</span> - Finally, if <span class="math inline">b \in \mathcal{E}</span> and <span class="math inline">en \in \cal P</span> (or equivalently if <span class="math inline">b \in \cal P</span> and <span class="math inline">en \in \mathcal{E}</span>), then one can show easily that <span class="math inline">\bar N</span> is a pure birth Markov process with immigration, of birth intensity function <span class="math inline">g(n)= \bar  \mu^{en} + n f^b(N_0 + n)</span> (resp. <span class="math inline">g(n)= \bar  \mu^b+ n f^{en}(N_0 + n)</span>), also verifying the Feller condition. Therefore, there exists a non-exploding solution of <a href="#eq-dominatingprocess" class="quarto-xref">Equation&nbsp;23</a>, by Proposition 3.3 in <span class="citation" data-cites="KaaElK20">(<a href="#ref-KaaElK20" role="doc-biblioref">Kaakai and El Karoui 2023</a>)</span>.<br>
</p>
<p><strong>Step 2</strong> The second step consists in showing that <span class="math inline">(N^b, N^{en})</span> is strongly dominated by <span class="math inline">(\bar N^b, \bar N^{en})</span>, i.e that all jumps of <span class="math inline">(N^b, N^{en})</span> are jumps of <span class="math inline">(\bar N^b, \bar N^{en})</span>. Without loss of generality, we can assume that <span class="math inline">f^e:\mathbb{N} \to (0,+\infty)</span> is increasing since <span class="math inline">f^e(n)</span> can be replaced by <span class="math inline">\sup_{\{m\leq n \} } f^e(m)</span>.<br>
Let <span class="math inline">e\in \{b, en\}</span>. If <span class="math inline">e \in \mathcal{P}</span>, then for all <span class="math inline">s\in [0,T]</span> <span class="math display">\{\theta \leq \mu_s^e\} \subset \{ \theta \leq \bar \mu^e\},</span> which yields that all jumps of <span class="math inline">N^e</span> are jumps of <span class="math inline">\bar N^e</span>.<br>
If <span class="math inline">e \in  \mathcal{E}\cup \mathcal{E}_W</span>, the proof by induction is analogous to the proof of Proposition 2.1 in <span class="citation" data-cites="KaaElK20">(<a href="#ref-KaaElK20" role="doc-biblioref">Kaakai and El Karoui 2023</a>)</span>. Let <span class="math inline">T_1^e</span> be first jump time of <span class="math inline">N^e</span>, associated with the marks <span class="math inline">(K_1^e,\Theta_1^e)</span> of <span class="math inline">Q</span> (or <span class="math inline">Q^{\mathcal{P}}</span>). Then, by Definition of <a href="#eq-Ne" class="quarto-xref">Equation&nbsp;22</a>, <span class="math inline">K_1^e \leq N_0</span> and <span class="math inline">\Theta_1^e \leq \lambda_{T_1^e}^e (I_{K_1^e}, Z_0)</span>.<br>
By <a href="#cnj-non-explosion" class="quarto-xref">Assumption&nbsp;4</a>, we have also <span class="math display">\Theta_1^e \leq \lambda_{T_1^e}^e (I_{K_1^e}, Z_0) \leq f^e(N_0) \leq f^e(N_0 +\bar N_{T_1^{e,-}}), \quad K_1^e \leq N_0 +  \bar N_{T_1^{e,-}}.</span> Thus, <span class="math inline">T_1^e</span> is also a jump time of <span class="math inline">\bar N^e</span>. By iterating this argument, we obtain that all jump times of <span class="math inline">N^e</span> are jump times of <span class="math inline">\bar N^e</span>.<br>
Thus, <span class="math inline">(N^b, N^{en})</span> does not explode in finite time.<br>
</p>
<p><strong>Step 3</strong> It remains to show that for <span class="math inline">e \notin \{b, en\}</span>, <span class="math inline">N^e</span> does not explode.<br>
Let <span class="math inline">e \neq b, en</span>. If <span class="math inline">e\in \mathcal P</span>, the proof is the same than in Step 2. Otherwise, let: <span class="math display">h^e_t(n) = \sup_{I \in \mathcal{I},  m \leq n } \lambda^e_t \biggl(I, \sum_{k=1}^{m} \delta_{I_k}\biggr), \quad \forall \; t \in [0,T] \;  n \in {\mathbb{N}}^*.</span> By <a href="#cnj-intensity1" class="quarto-xref">Assumption&nbsp;2</a> and <a href="#cnj-intensity2" class="quarto-xref">Assumption&nbsp;3</a>, <span class="math inline">h^e_t(n) &lt;\infty</span>, and we can introduce the non exploding counting process <span class="math inline">\bar{N}^e</span>, defined by the thinning equation : <span class="math display">\bar N_t^e = \int_0^t \int_{{\mathbb{N}}\times {\mathbb{R}}^+} \mathbf{1}_{\{k\leq N_0 + \bar N_{s^-} \}}  \mathbf{1}_{\{\theta \leq h^e_s (N_0 + \bar N_{s^-})\}} Q(\mathrm{d}s, \mathrm{d}k, \{e\}, \mathrm{d}\theta),</span> with <span class="math inline">\bar N_s = \bar N^b_s + \bar N^{en}_s</span>.<br>
Finally, by Step 2, for <span class="math inline">s\in [0,T]</span> the population size <span class="math inline">N_s = N_0 + N^b_s+ N^{en}_s</span> is bounded a.s. by <span class="math inline">N_0 + \bar N_s</span>, since all jumps of <span class="math inline">(N^b,N^{en})</span> are jumps of <span class="math inline">(\bar N^b, \bar N^{en})</span>. Thus, for all <span class="math inline">s\in [0,T]</span>, <span class="math display">\{k \leq N_{s^-} \}\subset  \{k\leq N_0 + \bar N_{s^-} \}, \text{ and }  \{\theta \leq \lambda_s^e(I_k, Z_{s^-})\} \subset \{\theta \leq h_s^e(N_0 + \bar N_{s^-})\}.</span> This proves that all jumps of <span class="math inline">N^e</span> are jumps <span class="math inline">\bar N^e</span>, and thus <span class="math inline">N^e</span> does not explode in finite time.</p>
</div>
</section>
<section id="alternative-pathwise-representation" class="level3" data-number="8.2.3">
<h3 data-number="8.2.3" class="anchored" data-anchor-id="alternative-pathwise-representation"><span class="header-section-number">8.2.3</span> Alternative pathwise representation</h3>
<div id="thm-EqZrandomized" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3</strong></span> Let <span class="math inline">\mathcal{J}_{\mathcal{E}} = \mathbb N \times \mathcal{E}</span> and <span class="math inline">\mathcal{J}_W  = \mathbb N \times \mathcal{E}_W</span>.<br>
Let <span class="math inline">Q^{\mathcal{E}}</span> be a random Poisson measure on <span class="math inline">\mathbb R^+ \times \mathcal{J}_{\mathcal{E}}\times \mathbb{R}^+</span>, of intensity <span class="math inline">\mathrm{d}t \delta_{\mathcal{J}_{\mathcal{E}}}(\mathrm{d}k, \mathrm{d}e)  \mathbf{1}_{[0,\bar \lambda^e]} (\theta) \mathrm{d}\theta</span>, and <span class="math inline">Q^{W}</span> a random Poisson measure on <span class="math inline">\mathbb R^+ \times \mathcal{J}_W \times \mathbb{N} \times  \mathbb{R}^+</span>, of intensity <span class="math inline">\mathrm{d}t \delta_{\mathcal{J}_{\mathcal{E}}}(\mathrm{d}k,\mathrm{d}e)) \delta_{\mathbb{N}} (\mathrm{d}j) \mathbf{1}_{[0,\bar W^e]} (\theta)\mathrm{d}\theta</span>. Finally, let <span class="math inline">Q^{\mathcal P}</span> be a random Poisson measure on <span class="math inline">\mathbb R^+ \times \mathcal{P}  \times \mathbb{R}^+</span>, of intensity <span class="math inline">\mathrm{d}t \delta_{\cal P}(\mathrm{d}e)  \mathbf{1}_{[0,\bar \mu^e]} (\theta)\mathrm{d}\theta</span>.<br>
There exists a unique measure-valued process <span class="math inline">Z</span>, strong solution on the following SDE driven by Poisson measure: <span id="eq-SDE_pop_randomized"><span class="math display">\begin{aligned}
Z_t  = Z_0 &amp;  + \int_0^t \int_{\mathcal{J}_{\mathcal{E}}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-})\}} Q^{\mathcal{E}}(\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ) \\
&amp;  + \int_0^t \int_{\mathcal{J}_W  \times {\mathbb{N}}\times  \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} } \mathbf{1}_{\{j \leq N_{s^-}\} }\mathbf{1}_{\{\theta \leq W^e(s, I_k , I_j) \}} Q^W (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e,  \mathrm{d}j ,\mathrm{d}\theta ),\\
&amp; +   \int_0^t \int_{\mathcal{P} \times \mathbb R^+}  \phi^e(s, I_{s^-}) \mathbf{1}_{\{\theta \leq \mu_s^e \}} Q^{\mathcal{P}} (\mathrm{d}s ,\mathrm{d}e , \mathrm{d}\theta),
\end{aligned} \tag{24}</span></span> with <span class="math inline">I_{s^-}</span> an individual taken uniformly in <span class="math inline">Z_{s^-}</span>.<br>
Furthermore, the solution of <a href="#eq-SDE_pop_randomized" class="quarto-xref">Equation&nbsp;24</a> has the same law than the solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>.</p>
</div>
<p>The proof of <a href="#thm-EqZrandomized" class="quarto-xref">Theorem&nbsp;3</a> follows the same steps than the proof of <a href="#thm-eq-Z" class="quarto-xref">Theorem&nbsp;1</a>.</p>
</section>
</section>
<section id="sec-prf-thm-interaction" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="sec-prf-thm-interaction"><span class="header-section-number">8.3</span> Proof of <a href="#thm-interaction" class="quarto-xref">Theorem&nbsp;2</a></h2>
<p>For ease of notation, we prove the case when <span class="math inline">\mathcal{P} =\emptyset</span> (there are no events with Poisson intensity).<br>
Let <span class="math inline">Z</span> be the population process obtained by <a href="#alg-interaction" class="quarto-xref">Algorithm 2</a>, and <span class="math inline">(T_n)_{n\geq 0}</span> the sequence of its jump times (<span class="math inline">T_0=0</span>).<br>
<strong>Step 1</strong> Let <span class="math inline">T_1</span> be the first event time in the population, with its associated marks defining the type <span class="math inline">E_1</span> of the event and the individual <span class="math inline">I_1</span> to which this event occurs. By construction, <span class="math inline">(T_1, E_1, I_1)</span> is characterized by the first jump of: <span class="math display">Q^0(\mathrm{d}t, \mathrm{d}k , \mathrm{d}e) = \int_{\mathbb R^+} \mathbf{1}_{\{\theta \leq \lambda_{t}^e(I_k,Z_0)\}}\bar Q^0 (\mathrm{d}t ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ),</span> with <span class="math inline">\bar Q^0</span> the Poisson measure introduced in the first step of the algorithm described in <a href="#sec-simulation-algo" class="quarto-xref">Section&nbsp;4.2</a>.</p>
<p>Since <span class="math inline">T_1</span> is the first event time, the population composition stays constant, <span class="math inline">Z_t=Z_0</span>, on <span class="math inline">\{t&lt;T_1\}</span>. In addition, recalling that the first event has the action <span class="math inline">\phi^{E_1}(T_1, I_1)</span> (see <a href="#tbl-event-action" class="quarto-xref">Table&nbsp;1</a>) on the population <span class="math inline">Z</span>, we obtain that: <span class="math display">\begin{aligned}
Z_{t\wedge T_1} &amp; =  Z_0 + \mathbf{1}_{\{t\geq T_1\}} \phi^{E_1} (T_1 , I_1)  \\
&amp; = Z_0 + \int_0^{t\wedge T_1}  \int_{\mathcal{J}_0} \phi^e (s , I_k)  Q^0 (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e ) \\
&amp; = Z_0 + \int_0^{t\wedge T_1} \int_{\mathcal{J}_0}  \int_{\mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k,Z_0)\}}\bar Q^0 (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).
\end{aligned}</span> Since <span class="math inline">Z_{s^-} = Z_0</span> on <span class="math inline">\{s \leq T_1\}</span>, the last equation can be rewritten as <span class="math display">
Z_{t\wedge T_1}   = Z_0 + \int_0^{t\wedge T_1} \int_{\mathcal{J}_0}  \int_{\mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k,Z_{s^-})\}}\bar Q^0 (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).</span></p>
<p><strong>Step 2</strong> The population size at the <span class="math inline">n</span>–th event time <span class="math inline">T_n</span> is <span class="math inline">N_{T_n}</span>. The <span class="math inline">(n+1)</span>–th event type and the individual to which this event occur are thus chosen in the set <span class="math display">\mathcal{J}_n := \{ 1,\dots, N_{T_n}\} \times (\mathcal{E} \cup \mathcal{E}_W).</span> Conditionally to <span class="math inline">\mathcal{F}_{T_n}</span>, let us first introduce the marked Poisson measure <span class="math inline">\bar Q^n</span> on <span class="math inline">[T_n, \infty) \times \mathcal J_n \times \mathbb R^+</span>, of intensity: <span id="eq-barmun"><span class="math display">
\begin{aligned}
\bar \mu^n(\mathrm{d}t, \mathrm{d}k, \mathrm{d}e , \mathrm{d}\theta ) &amp; := \mathbf{1}_{\{t &gt; T_n \}}\bar \Lambda (N_{T_n})\mathrm{d}t  \frac{\bar \lambda^e_n }{\bar \Lambda(N_{T_n})} \delta_{\mathcal J_n}(\mathrm{d}k, \mathrm{d}e) \frac{1}{\bar \lambda^e_n} \mathbf{1}_{[0,\bar \lambda^e_n]} (\theta)\mathrm{d}\theta,\\
&amp;  = \mathbf{1}_{\{t &gt; T_n \}}\mathrm{d}t  \delta_{\mathcal J_n}(\mathrm{d}k, \mathrm{d}e) \mathbf{1}_{[0,\bar \lambda^e_n]}(\theta)\mathrm{d}\theta,
\end{aligned}
\tag{25}</span></span> with <span class="math inline">\lambda^e_n = \bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_{T_n} \mathbf{1}_{e \in \mathcal{E}_W}</span>.</p>
<p>By definition, <span class="math inline">\bar Q^n</span> has no jump before <span class="math inline">T_n</span>.<br>
As for the first event, the triplet <span class="math inline">(T_{n+1}, E_{n+1}, I_{n+1})</span> is determined by the first jump of the measure <span class="math inline">Q^n (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e) := \int_{\mathbb R^+} \mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{T_n})\}}\bar Q^n (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta)</span>, obtained by thinning of <span class="math inline">\bar Q^n</span>. Finally, since the population composition is constant on <span class="math inline">[T_n, T_{n+1}[</span>, <span class="math inline">Z_t = Z_{T_n}</span>, the population on <span class="math inline">[0,T_{n+1}]</span> is defined by: <span id="eq-z-tn"><span class="math display">
\begin{aligned}
Z_{t\wedge T_{n+1}}  &amp;  = Z_{t \wedge T_n }  + \mathbf{1}_{\{t\geq T_{n+1}\}}\phi^{E_{n+1}}(T_{n+1}, I_{n+1}), \\
&amp; = Z_{t \wedge T_n } + \int_{t \wedge T_n}^{t \wedge T_{n+1}} \int_{\mathcal{J}_n
\times \mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{\theta\leq \lambda_s^e(I_k, Z_{s^-})\}}\bar Q^n (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).
\end{aligned}
\tag{26}</span></span> Applying <span class="math inline">n</span> times <a href="#eq-z-tn" class="quarto-xref">Equation&nbsp;26</a> yields that: <span class="math display">\begin{aligned}
Z_{t\wedge T_{n+1}} = Z_0  + \sum_{l=0}^n \int_{t \wedge T_l}^{t \wedge T_{l+1}}\int_{ \mathcal{J}_l \times  \mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{\theta\leq \lambda_s^e(I_k, \tilde Z_{s^-})\}}\bar Q^l (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ).
\end{aligned}
</span></p>
<p><strong>Step 3</strong> Finally, let <span class="math inline">\tilde{Z}</span> be the solution of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>, with <span class="math inline">(\tilde T_n)_{n\geq 0}</span> the sequence of its event times. Then, we can write similarly for all <span class="math inline">n\geq 0</span>: <span class="math display">\begin{aligned}
\tilde Z_{t\wedge \tilde T_{n+1}} &amp; = Z_0  + \sum_{l=0}^n \int_{t \wedge \tilde  T_l}^{t \wedge \tilde T_{l+1}} \int_{\mathcal{J}\times \mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{\theta\leq \lambda_s^e(I_k,  \tilde Z_{s^-})\}}\mathbf{1}_{ \{k \leq \tilde N_{s^-} \}}   Q(\mathrm{d}s, \mathrm{d}k , \mathrm{d}e , \mathrm{d}\theta ), \\
&amp; = Z_0  + \sum_{l=0}^n \int_{t \wedge \tilde  T_l}^{t \wedge \tilde T_{l+1}} \int_{\mathcal{J}\times \mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{\theta\leq \lambda_s^e(I_k,  \tilde Z_{s^-})\}} \mathbf{1}_{ \{\theta \leq \tilde \lambda^e_n \}}\mathbf{1}_{ \{k \leq \tilde N_{\tilde T_l} \}}  Q(\mathrm{d}s, \mathrm{d}k , \mathrm{d}e , \mathrm{d}\theta ),
\end{aligned}</span> since <span class="math inline">\tilde  Z_{s^-} = \tilde Z_{T_l}</span> on <span class="math inline">\tilde [T_l, \tilde T_{l+1}]</span>, and <span class="math display">\lambda_s^e(I_k,  \tilde Z_{s^-}) \leq \tilde \lambda^e_n:=  \bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e \tilde N_{\tilde T_n} \mathbf{1}_{e \in \mathcal{E}_W}</span> For each <span class="math inline">l \geq 0</span>, let <span class="math display">\tilde Q^l(\mathrm{d}t, \mathrm{d}k , \mathrm{d}e , \mathrm{d}\theta )  = \mathbf{1}_{\{t &gt;  \tilde T_l\}} \mathbf{1}_{ \{1, \dots , \tilde N_{\tilde T_l} \}}(k)  \mathbf{1}_{[0, \tilde \lambda^e_n]}(\theta) Q(\mathrm{d}t, \mathrm{d}k , \mathrm{d}e , \mathrm{d}\theta ).</span> By <a href="#prp-restriction-poisson-measure" class="quarto-xref">Proposition&nbsp;4</a>, <span class="math inline">\tilde Q^l</span> is, conditionally to <span class="math inline">\mathcal{F}_{T_l}</span>, a Poisson measure of intensity <span class="math display">\mathbf{1}_{\{t &gt;  \tilde T_l\}}   \mathrm{d}t \mathbf{1}_{ \{1, \dots , \tilde N_{\tilde T_l} \}}(k) \delta_{\mathcal{J}}(\mathrm{d}k, \mathrm{d}e)\mathbf{1}_{[0, \tilde \lambda^e_n]}(\theta) \mathrm{d}\theta.</span> It follows easily by induction that <span class="math inline">\tilde{Q}^l</span> has thus the same distribution than <span class="math inline">\bar Q^l</span>, the Poisson measure with the conditional intensity <span class="math inline">\bar \mu^l</span> defined in <a href="#eq-barmun" class="quarto-xref">Equation&nbsp;25</a>. Thus, <span class="math inline">Z</span> is an exact simulation of <a href="#eq-sde-eq-Z" class="quarto-xref">Equation&nbsp;12</a>.</p>
</section>

</div></section><section id="sec-recall-poisson" class="level2 appendix" data-number="8.1"><h2 class="anchored quarto-appendix-heading"><span class="header-section-number">8.1</span> Recall on Poisson random measures</h2><div class="quarto-appendix-contents">

<p>We recall below some useful properties of Poisson random measures, mainly following Chapter&nbsp;6 of&nbsp;<span class="citation" data-cites="Cin11">(<a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>)</span>. We also refer to&nbsp;<span class="citation" data-cites="Kal17">(<a href="#ref-Kal17" role="doc-biblioref">Kallenberg 2017</a>)</span> for a more comprehensive presentation of random counting measures.</p>
<div id="def-poisson-random-measure" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 (Poisson Random Measures)</strong></span> Let <span class="math inline">\mu</span> be a <span class="math inline">\sigma</span>-finite diffuse measure on a Borel subspace <span class="math inline">(E,\mathcal{E})</span> of <span class="math inline">({\mathbb{R}}^d, \mathcal{B}({\mathbb{R}}^d))</span>. A random counting measure <span class="math inline">Q= \sum_{k\geq 1} \delta_{X_k}</span> is a Poisson (counting) random measure of <em>mean measure</em> <span class="math inline">\mu</span> if</p>
<ol type="1">
<li><span class="math inline">\forall A \in \mathcal{E}</span>, <span class="math inline">Q(A)</span> is a Poisson random variable with <span class="math inline">{\mathbb{E}}[Q(A)]= \mu(A)</span>.</li>
<li>For all disjoints subsets <span class="math inline">A_1, \dots, A_n \in \mathcal{E}</span>, <span class="math inline">Q(A_1), \dots, Q(A_n)</span> are independent Poisson random variables.</li>
</ol>
</div>
<p>Let us briefly recall here some simple but useful operations on Poisson measures. In the following, <span class="math inline">Q</span> is a Poisson measure of mean measure <span class="math inline">\mu</span>, unless stated otherwise.</p>
<div id="prp-restriction-poisson-measure" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4 (Restricted Poisson measure)</strong></span> If <span class="math inline">B \in \mathcal{E}</span>, then, the restriction of <span class="math inline">Q</span> to <span class="math inline">B</span> defined by <span class="math display">
    Q^B = \mathbf{1}_B Q = \sum_{k \ge 1} \mathbf{1}_{B}(X_k) \delta_{X_k}
</span> is also a Poisson random measure, of mean measure <span class="math inline">\mu^B = \mu(\cdot \cap B)</span>.</p>
</div>
<div id="prp-proj-poisson-measure" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 5 (Projection of Poisson measure)</strong></span> If <span class="math inline">E = F_1 \times F_2</span> is a product space, then the projection <span class="math display">
    Q_1(\mathrm{d}x) = \int_{F_2} Q(\mathrm{d}x , \mathrm{d}y)
</span> is a Poisson random measure of mean measure <span class="math inline">\mu_1 (\mathrm{d}x ) = \int_{F_2} \mu(\mathrm{d}x, \mathrm{d}y)</span>.</p>
</div>
<section id="link-with-poisson-processes" class="level3" data-number="8.1.1">
<h3 data-number="8.1.1" class="anchored" data-anchor-id="link-with-poisson-processes"><span class="header-section-number">8.1.1</span> Link with Poisson processes</h3>
<p>Let <span class="math inline">Q= \sum_{k\geq 1} \delta_{T_k}</span> a Poisson random measure on <span class="math inline">E={\mathbb{R}}^+</span> with mean measure <span class="math inline">\mu(\mathrm{d}t) = \Lambda (t) \mathrm{d}t</span> absolutely continuous with respect to the Lebesgue measure, <span class="math inline">\mu(A) = \int_A \Lambda(t) \mathrm{d}t</span>. The counting process <span class="math inline">(N_t)_{t \ge 0}</span> defined by <span id="eq-inhomogeneous-pp"><span class="math display">
    N_t = Q([0,t]) = \sum_{k \geq 1} \mathbf{1}_{\{T_k \leq t\}}, \quad \forall \; t\geq 0,
\tag{21}</span></span> is an inhomogeneous Poisson process with intensity function (or rate) <span class="math inline">t \mapsto \Lambda(t)</span>. In particular, when <span class="math inline">\Lambda(t) \equiv c</span> is a constant, <span class="math inline">N</span> is a homogeneous Poisson process with rate <span class="math inline">c</span>. Assuming that the atoms are ordered <span class="math inline">T_1&lt; T_2&lt; \dots</span>, we recall that the sequence <span class="math inline">(T_{k+1}-T_k)_{k\geq 1}</span> is a sequence of <em>i.i.d.</em> exponential variables of parameter <span class="math inline">c</span>.</p>
</section>
<section id="marked-poisson-measures-on-e-mathbbr-times-f" class="level3" data-number="8.1.2">
<h3 data-number="8.1.2" class="anchored" data-anchor-id="marked-poisson-measures-on-e-mathbbr-times-f"><span class="header-section-number">8.1.2</span> Marked Poisson measures on <span class="math inline">E = {\mathbb{R}}^+ \times F</span></h3>
<p>We are interested in the particular case when <span class="math inline">E</span> is the product space <span class="math inline">{\mathbb{R}}^+ \times F</span>, with <span class="math inline">(F,\mathcal{F})</span> a Borel subspace of <span class="math inline">{\mathbb{R}}^d</span>. Then, a random counting measure is defined by a random set <span class="math inline">S =\{ (T_k, \Theta_k ), k \geq 1\}</span>. The random variables <span class="math inline">T_k\geq 0</span> can be considered as time variables, and constitute the jump times of the random measure, while the variables <span class="math inline">\Theta_k \in F</span> represent space variables.</p>
<p>We recall in this special case the Theorem&nbsp;VI.3.2 in&nbsp;<span class="citation" data-cites="Cin11">(<a href="#ref-Cin11" role="doc-biblioref">Çinlar 2011</a>)</span>.</p>
<div id="prp-marked-poisson" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 6 (Marked Poisson measure)</strong></span> Let <span class="math inline">m</span> be a <span class="math inline">\sigma</span>–finite diffuse measure on <span class="math inline">{\mathbb{R}}^+</span>, and <span class="math inline">K</span> a transition probability kernel from <span class="math inline">({\mathbb{R}}^+,\mathcal{B}({\mathbb{R}}^+))</span> into <span class="math inline">(F, \mathcal{F})</span>. Assume that the collection <span class="math inline">(T_k)_{k \ge 1}</span> forms a Poisson process <span class="math inline">(N_t) =(\sum_{k\geq 1} \mathbf{1}_{\{T_k \leq t\}})</span> with mean <span class="math inline">m(\mathrm{d}t) =\Lambda(t) \mathrm{d}t</span>, and that given <span class="math inline">(T_k)_{k \ge 1}</span>, the variables <span class="math inline">\Theta_k</span> are conditionally independent and have the respective distributions <span class="math inline">K(T_k, \cdot)</span>.</p>
<ol type="1">
<li><p>Then, <span class="math inline">\{ (T_k, \Theta_k) ;\; k \ge 1\}</span> forms a Poisson random measure <span class="math inline">Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}</span> on <span class="math inline">({\mathbb{R}}^+ \times F, \mathcal{B}({\mathbb{R}}^+) \otimes \mathcal{F})</span>, called a <em>Marked point process</em> , with mean <span class="math inline">\mu</span> defined by <span class="math display">
\mu(\mathrm{d}t, \mathrm{d}y) = \Lambda(t) \mathrm{d}t K(t, \mathrm{d}y).
</span></p></li>
<li><p>Reciprocally let <span class="math inline">Q</span> be a Poisson random measure of mean measure <span class="math inline">\mu(\mathrm{d}t, \mathrm{d}y)</span>, admitting the following disintegration with respect to the first coordinate: <span class="math inline">\mu(\mathrm{d}t , \mathrm{d}y) =\tilde  \Lambda(t) \mathrm{d}t \nu(t, \mathrm{d}y)</span>, with <span class="math inline">\nu(t, F)&lt;\infty</span>. Let <span class="math inline">K(t, \mathrm{d}y) = \dfrac{\nu(t,\mathrm{d}y) }{\nu(t, F) }</span> and <span class="math inline">\Lambda(t) = \nu(t, F)\tilde  \Lambda(t)</span>. Then, <span class="math inline">Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}</span> is a marked Poisson measure with <span class="math inline">(T_k,\Theta_k)_{k\in {\mathbb{N}}^*}</span> defined as above. In particular, the projection <span class="math inline">N= (N_t)_{t\geq0}</span> of the Poisson measure on the first coordinate, <span class="math display">
N_t = Q([0,t] \times F) = \sum_{k\geq 1} \mathbf{1}_{[0,t] \times F} (T_k, \Theta_k)  = \sum_{k\geq 1} \mathbf{1}_{\{T_k \leq t\}}, \quad \forall \; t \geq 0,
</span> is an inhomogeneous Poisson process of rate <span class="math inline">\Lambda(t)= \nu(t, F)\tilde  \Lambda(t)</span>.</p></li>
</ol>
</div>
<div id="rem">
<p>When the transition probability kernel <span class="math inline">K</span> does not depend on the time: <span class="math inline">K(t, A) = \nu(A)</span> for some probability measure <span class="math inline">\nu</span>, then the marks <span class="math inline">(\Theta_k)_{k \ge 1}</span> form an <em>i.i.d.</em> sequence with distribution <span class="math inline">\nu</span>, independent of <span class="math inline">(T_k)_{k \ge 1}</span>.</p>
</div>
<p>The preceding proposition thus yields a straightforward iterative simulation procedure for a Marked Poisson process on <span class="math inline">[0,T]\times F</span> with mean measure <span class="math inline">\mu(\mathrm{d}t, \mathrm{d}y) = c \mathrm{d}t K(t, \mathrm{d}y)</span> and <span class="math inline">c&gt;0</span>. The procedure is described in <a href="#alg-marked-poisson" class="quarto-xref">Algorithm 4</a>.</p>
<div id="alg-marked-poisson" class="pseudocode-container quarto-float" data-caption-prefix="Algorithm" data-line-number-punc=":" data-comment-delimiter="//" data-pseudocode-number="4" data-no-end="false" data-line-number="true" data-indent-size="1.2em">
<div class="pseudocode">
\begin{algorithm} \caption{Simulation of Marked Poisson measure} \begin{algorithmic} \State \textbf{Input:} Constant $c$, simulatable kernel $K$ and final time $T$ \State \textbf{Output:} Times $(T_1,\dots,T_n)$ and Marks $(Y_1, \dots, Y_n)$ of the Marked Poisson measure of mean $\mu(\mathrm{d} t, \mathrm{d} y) = c \mathrm{d} t K(t, \mathrm{d} y)$ in $[0,T]\times F$. \State Initialization draw $T_1 \sim \mathcal{E}(c)$ and draw $Y_1 \sim K(T_1, \mathrm{d} y)$ \While{condition} \State increment iterative variable $k \longleftarrow k+1$ \State compute next jump time compute next jump time $T_k \longleftarrow T_{k-1} + \mathcal{E}(c)$ \State draw a conditional mark $Y_k \sim K(T_k, \mathrm{d} y)$ \EndWhile \end{algorithmic} \end{algorithm}
</div>
</div>
<div id="fig-poisson" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-poisson-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<embed src="img/plot_poisson.tex" class="img-fluid">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-poisson-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Example of Marked Poisson measure on <span class="math inline">[0,T]</span> with <span class="math inline">m(\mathrm{d} t) = L \mathrm{d} t</span> (jump times occur at Poisson arrival times of rate <span class="math inline">L</span>) and with <span class="math inline">\nu(\mathrm{d} y) = \frac{1}{L} \mathbf{1}_{[0, L]}(y) \mathrm{d} y</span> (marks are drawn uniformly on <span class="math inline">[0,L]</span>). The mean measure is then <span class="math inline">\mu(\mathrm{d} t, \mathrm{d} y) = \mathrm{d} t {1}_{[0,L]}(y) \mathrm{d} y</span>.
</figcaption>
</figure>
</div>
</section>
</div></section><section id="acknowledgements" class="level2 appendix" data-number="8.4"><h2 class="anchored quarto-appendix-heading"><span class="header-section-number">8.4</span> Acknowledgements</h2><div class="quarto-appendix-contents">

<p>The research of Sarah Kaakai is funded by the European Union (ERC, SINGER, 101054787). Views and opinions expressed are however those of the author(s) only and do not necessarily reflect those of the European Union or the European Research Council. Neither the European Union nor the granting authority can be held responsible for them.</p>
</div></section><section id="session-information" class="level1 appendix unnumbered"><h2 class="anchored quarto-appendix-heading">Session information</h2><div class="quarto-appendix-contents">

<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>R version 4.4.1 (2024-06-14)
Platform: x86_64-pc-linux-gnu
Running under: Ubuntu 22.04.5 LTS

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 
LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0

locale:
 [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8       
 [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8   
 [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C          
[10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C   

time zone: Etc/UTC
tzcode source: system (glibc)

attached base packages:
[1] stats     graphics  grDevices datasets  utils     methods   base     

other attached packages:
[1] reshape2_1.4.4  StMoMo_0.4.1    forecast_8.23.0 gnm_1.1-5      
[5] IBMPopSim_1.1.0 ggplot2_3.5.1  

loaded via a namespace (and not attached):
 [1] dotCall64_1.2          gtable_0.3.5           spam_2.11-0           
 [4] xfun_0.44              lattice_0.22-6         tzdb_0.4.0            
 [7] quadprog_1.5-8         vctrs_0.6.5            tools_4.4.1           
[10] generics_0.1.3         curl_6.0.1             parallel_4.4.1        
[13] tibble_3.2.1           fansi_1.0.6            xts_0.14.1            
[16] pkgconfig_2.0.3        Matrix_1.7-0           checkmate_2.3.2       
[19] RColorBrewer_1.1-3     lifecycle_1.0.4        rootSolve_1.8.2.4     
[22] farver_2.1.2           stringr_1.5.1          compiler_4.4.1        
[25] fields_16.3            munsell_0.5.1          htmltools_0.5.8.1     
[28] maps_3.4.2.1           yaml_2.3.8             pillar_1.9.0          
[31] MASS_7.3-60.2          nlme_3.1-164           fracdiff_1.5-3        
[34] tidyselect_1.2.1       fanplot_4.0.0          digest_0.6.35         
[37] stringi_1.8.4          dplyr_1.1.4            labeling_0.4.3        
[40] qvcalc_1.0.3           tseries_0.10-58        RcppArmadillo_14.2.0-1
[43] fastmap_1.2.0          grid_4.4.1             colorspace_2.1-0      
[46] cli_3.6.2              magrittr_2.0.3         relimp_1.0-5          
[49] utf8_1.2.4             readr_2.1.5            withr_3.0.0           
[52] scales_1.3.0           backports_1.5.0        TTR_0.24.4            
[55] rmarkdown_2.27         quantmod_0.4.26        nnet_7.3-19           
[58] timeDate_4041.110      zoo_1.8-12             hms_1.1.3             
[61] urca_1.3-4             evaluate_0.23          knitr_1.46            
[64] lmtest_0.9-40          viridisLite_0.4.2      rlang_1.1.3           
[67] Rcpp_1.0.13-1          glue_1.7.0             renv_1.0.7            
[70] jsonlite_1.8.8         plyr_1.8.9             R6_2.5.1              </code></pre>
</div>
</div>
<!-- -->

</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>The choices <span class="math inline">(\alpha, \beta) \in \{(1,2/300),(1, 1/300), (1.5, 1/300), (2, 1/300)\}</span> lead to the stationary population sizes <span class="math inline">N \in \{360, 900, 1800, 2600\}</span>. For each set of parameters, we generated a new initial population, which was used for a benchmark of 50 simulations with both randomized and full algorithm. The simulations run on a Intel Core i7-8550U CPU 1.80GHz × 8 processor, with 15.3 GiB of RAM, under Debian GNU/Linux 11.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{giorgi2024,
  author = {Giorgi, Daphné and Kaakai, Sarah and Lemaire, Vincent},
  publisher = {Société Française de Statistique},
  title = {Efficient Simulation of Individual-Based Population Models},
  journal = {Computo},
  date = {2024-12-01},
  url = {https://computo.sfds.asso.fr/published-202412-giorgi-efficient},
  doi = {10.57750/sfxn-1t05},
  issn = {2824-7795},
  langid = {en},
  abstract = {The `R` Package `IBMPopSim` facilitates the simulation of
    the random evolution of heterogeneous populations using stochastic
    Individual-Based Models (IBMs). The package enables users to
    simulate population evolution, in which individuals are
    characterized by their age and some characteristics, and the
    population is modified by different types of events, including
    births/arrivals, death/exit events, or changes of characteristics.
    The frequency at which an event can occur to an individual can
    depend on their age and characteristics, but also on the
    characteristics of other individuals (interactions). Such models
    have a wide range of applications in fields including actuarial
    science, biology, ecology or epidemiology. `IBMPopSim` overcomes the
    limitations of time-consuming IBMs simulations by implementing new
    efficient algorithms based on thinning methods, which are compiled
    using the `Rcpp` package while providing a user-friendly interface.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-giorgi2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Giorgi, Daphné, Sarah Kaakai, and Vincent Lemaire. 2024.
<span>“Efficient Simulation of Individual-Based Population
Models.”</span> <em>Computo</em>, December. <a href="https://doi.org/10.57750/sfxn-1t05">https://doi.org/10.57750/sfxn-1t05</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb45" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Efficient simulation of individual-based population models"</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "The `R` package `IBMPopSim`"</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Daphné Giorgi </span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="co">    email: daphne.giorgi@sorbonne-universite.fr</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://perso.lpsm.paris/~giorgi/</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Sorbonne Université, CNRS</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire de Probabilités, Statistique et Modélisation</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.lpsm.paris/</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Sarah Kaakai</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="co">    email: sarah.kaakai@univ-lemans.fr</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://perso.univ-lemans.fr/~skaakai/</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Le Mans Université</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire Manceau de Mathématiques</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://lmm.univ-lemans.fr/fr/</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Ecole Polytechnique, CNRS</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Centre de Mathématiques Appliquées</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://cmap.ip-paris.fr/ </span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Vincent Lemaire </span></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a><span class="co">    email: vincent.lemaire@sorbonne-universite.fr</span></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://perso.lpsm.paris/~vlemaire/</span></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-0433-7722</span></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Sorbonne Université, CNRS</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a><span class="co">        department: Laboratoire de Probabilités, Statistique et Modélisation</span></span>
<span id="cb45-32"><a href="#cb45-32" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.lpsm.paris/</span></span>
<span id="cb45-33"><a href="#cb45-33" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> 2024-12-01</span></span>
<span id="cb45-34"><a href="#cb45-34" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb45-35"><a href="#cb45-35" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb45-36"><a href="#cb45-36" aria-hidden="true" tabindex="-1"></a><span class="co">    This document provides a full description of the Stochastic Individual-Based Models (IBMs) that can be implemented in the IBMPopSim package. A unified mathematical and simulation framework is given, with a detailed description of the simulation algorithm. Examples of applications for the package are also provided, showing the performance and flexibility of IBMPopSim. </span></span>
<span id="cb45-37"><a href="#cb45-37" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb45-38"><a href="#cb45-38" aria-hidden="true" tabindex="-1"></a><span class="co">    The `R` Package `IBMPopSim` facilitates the simulation of the random evolution of heterogeneous populations using stochastic Individual-Based Models (IBMs). The package enables users to simulate population evolution, in which individuals are characterized by their age and some characteristics, and the population is modified by different types of events, including births/arrivals, death/exit events, or changes of characteristics. The frequency at which an event can occur to an individual can depend on their age and characteristics, but also on the characteristics of other individuals (interactions). Such models have a wide range of applications in fields including  actuarial science, biology, ecology or epidemiology. `IBMPopSim` overcomes the limitations of time-consuming IBMs simulations by implementing new efficient algorithms  based on thinning methods, which are compiled using the `Rcpp` package while providing a user-friendly interface.</span></span>
<span id="cb45-39"><a href="#cb45-39" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [Individual-based models, stochastic simulation, population dynamics, Poisson measures, thinning method, actuarial science, insurance portfolio simulation]</span></span>
<span id="cb45-40"><a href="#cb45-40" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb45-41"><a href="#cb45-41" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb45-42"><a href="#cb45-42" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb45-43"><a href="#cb45-43" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "10.57750/sfxn-1t05"</span></span>
<span id="cb45-44"><a href="#cb45-44" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/published-202412-giorgi-efficient</span></span>
<span id="cb45-45"><a href="#cb45-45" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb45-46"><a href="#cb45-46" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb45-47"><a href="#cb45-47" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb45-48"><a href="#cb45-48" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb45-49"><a href="#cb45-49" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "published-202412-giorgi-efficient"</span></span>
<span id="cb45-50"><a href="#cb45-50" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> false</span></span>
<span id="cb45-51"><a href="#cb45-51" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> true</span></span>
<span id="cb45-52"><a href="#cb45-52" aria-hidden="true" tabindex="-1"></a><span class="an">google-scholar:</span><span class="co"> true</span></span>
<span id="cb45-53"><a href="#cb45-53" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb45-54"><a href="#cb45-54" aria-hidden="true" tabindex="-1"></a><span class="co">    computo-html: default</span></span>
<span id="cb45-55"><a href="#cb45-55" aria-hidden="true" tabindex="-1"></a><span class="co">    computo-pdf: default</span></span>
<span id="cb45-56"><a href="#cb45-56" aria-hidden="true" tabindex="-1"></a><span class="an">crossref:</span></span>
<span id="cb45-57"><a href="#cb45-57" aria-hidden="true" tabindex="-1"></a><span class="co">    cnj-title: Assumption</span></span>
<span id="cb45-58"><a href="#cb45-58" aria-hidden="true" tabindex="-1"></a><span class="co">    cnj-prefix: Assumption </span></span>
<span id="cb45-59"><a href="#cb45-59" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb45-60"><a href="#cb45-60" aria-hidden="true" tabindex="-1"></a><span class="co">    eval: true</span></span>
<span id="cb45-61"><a href="#cb45-61" aria-hidden="true" tabindex="-1"></a><span class="co">    echo: true</span></span>
<span id="cb45-62"><a href="#cb45-62" aria-hidden="true" tabindex="-1"></a><span class="co">    warning: false</span></span>
<span id="cb45-63"><a href="#cb45-63" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb45-64"><a href="#cb45-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-65"><a href="#cb45-65" aria-hidden="true" tabindex="-1"></a><span class="in">```{r echo=FALSE}</span></span>
<span id="cb45-66"><a href="#cb45-66" aria-hidden="true" tabindex="-1"></a><span class="in">library(ggplot2)</span></span>
<span id="cb45-67"><a href="#cb45-67" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-68"><a href="#cb45-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-69"><a href="#cb45-69" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb45-70"><a href="#cb45-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-71"><a href="#cb45-71" aria-hidden="true" tabindex="-1"></a>In various fields, advances in probability have contributed to the development of a new mathematical framework for so-called individual-based stochastic population dynamics, also called stochastic Individual-Based Models (IBMs).</span>
<span id="cb45-72"><a href="#cb45-72" aria-hidden="true" tabindex="-1"></a>Stochastic IBMs allow the modeling in continuous time of populations dynamics structured by age and/or characteristics. In the field of mathematical biology and ecology, a large community has used this formalism for the study of the evolution of structured populations (see e.g. @FerTra09; @collet2013rigorous; @BanMel15; @costa2016stochastic; @billiard2016effect; @lavallee2019stochastic; @meleard2019birth; @calvez2020horizontal), after the pioneer works&nbsp;<span class="co">[</span><span class="ot">@FouMel04;@tran_2008;@meleard2009trait</span><span class="co">]</span>.</span>
<span id="cb45-73"><a href="#cb45-73" aria-hidden="true" tabindex="-1"></a>IBMs are also useful in demography and actuarial sciences, for the modeling of human populations dynamics (see e.g. @Ben10; @Bou16; @karoui2021simulating). </span>
<span id="cb45-74"><a href="#cb45-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-75"><a href="#cb45-75" aria-hidden="true" tabindex="-1"></a>Indeed, they allow the modeling of heterogeneous and complex population dynamics, which can be used to compute demographic indicators or simulate the evolution of insurance portfolios in order to study the basis risk, compute cash flows for annuity products or pension schemes, or for a fine assessment of mortality models <span class="co">[</span><span class="ot">@barrieu2012understanding</span><span class="co">]</span>. There are other domains in which stochastic IBMs can be used, for example in epidemiology with stochastic compartmental models, neurosciences, cyber risk, or Agent-Based Models (ABMs) in economy and social sciences, which can be seen as IBMs.</span>
<span id="cb45-76"><a href="#cb45-76" aria-hidden="true" tabindex="-1"></a>Many mathematical results have been obtained in the literature cited above, for quantifying the limit behaviors of IBMs over long time scales or in large population. In particular, pathwise representations of IBMs have been introduced in @FouMel04 (and extended to age-structured populations in @tran_2008; @meleard2009trait), as measure-valued pure jumps Markov processes, solutions of SDEs driven by Poisson measures. These pathwise representations are based on the *thinning* and projection of Poisson random measures defined on extended spaces. However, the simulation of large and interacting populations is often computationally expensive.</span>
<span id="cb45-77"><a href="#cb45-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-78"><a href="#cb45-78" aria-hidden="true" tabindex="-1"></a>The aim of the <span class="in">`R`</span> package <span class="in">`IBMPopSim`</span> is to meet the needs of the various communities for efficient tools in order to simulate the evolution of stochastic IBMs. <span class="in">`IBMPopSim`</span> provides a general framework for the simulation of a wide class of IBMs, where individuals are characterized by their age and/or a set of characteristics. Different types of events can be included in the modeling by users, depending on their needs: births, deaths, entry or exit in/to the population and changes of characteristics (swap events). Furthermore, the various events that can happen to individuals in the population can occur at a non-stationary frequency, depending on the individuals' characteristics and time, and also including potential interactions between individuals.</span>
<span id="cb45-79"><a href="#cb45-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-80"><a href="#cb45-80" aria-hidden="true" tabindex="-1"></a>We introduce a unified mathematical and simulation framework for this class of IBMs, generalizing the pathwise representation of IBMs by thinning of Poisson measures, as well as the associated population simulation algorithm, based on an acceptance/rejection procedure. In particular, we provide general sufficient conditions on the event intensities under which the simulation of a particular model is possible.</span>
<span id="cb45-81"><a href="#cb45-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-82"><a href="#cb45-82" aria-hidden="true" tabindex="-1"></a>We opted to implement the algorithms of the <span class="in">`IBMPopSim`</span> package using the <span class="in">`Rcpp`</span> package, a tool facilitating the seamless integration of high-performance <span class="in">`C++`</span> code into easily callable <span class="in">`R`</span> functions <span class="co">[</span><span class="ot">@JSSv040i08</span><span class="co">]</span>. <span class="in">`IBMPopSim`</span> offers user-friendly R functions for defining and simulating IBMs. Once events and their associated intensities are specified, an automated procedure creates the model. This involves integrating the user's source code into the primary <span class="in">`C++`</span> code using a template mechanism. Subsequently, <span class="in">`Rcpp`</span> is invoked to compile the model so that the model is integrated into the <span class="in">`R`</span> session and callable with varying parameters, enabling the generation of diverse population evolution scenarios. Combined with the design of the simulation algorithms, the package structure yields very competitive simulation runtimes for IBMs, while staying user-friendly for <span class="in">`R`</span> users. Several outputs function are also implemented in <span class="in">`IBMPopSim`</span>. For instance the package allows the construction and visualization of age pyramids, as well as the construction of death and exposures table from the censored individual data, compatible with <span class="in">`R`</span> packages concerned with mortality modelling, such as @Rdemography or @Rstmomo. Several examples are provided in the form of <span class="in">`R`</span> vignettes on the <span class="co">[</span><span class="ot">website</span><span class="co">](https://daphnegiorgi.github.io/IBMPopSim/)</span>, and in recent works of @karoui2021simulating and @roget2022positive.</span>
<span id="cb45-83"><a href="#cb45-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-84"><a href="#cb45-84" aria-hidden="true" tabindex="-1"></a>To the best of our knowledge, there are no other <span class="in">`R`</span> packages currently available addressing the issue of stochastic IBMs efficient simulation.</span>
<span id="cb45-85"><a href="#cb45-85" aria-hidden="true" tabindex="-1"></a>Another approach for simulating populations is continuous time microsimulation in social sciences, which is implemented in the <span class="in">`R`</span> package <span class="in">`MicSim`</span>&nbsp;<span class="co">[</span><span class="ot">@Zin14</span><span class="co">]</span>. In this framework, individual life-courses are specified by sequences of state transitions (events) and the time spans between these transitions. The state space is usually discrete and finite, which is not necessarily the case in <span class="in">`IBMPopSim`</span>, where individuals can have continuous characteristics. But most importantly, microsimulation does not allow for interactions between individuals. Indeed, microsimulation produces separately the life courses of all individuals in the populations, based on the computation of the distribution functions of the waiting times in the distinct states of the state space, for each individual <span class="co">[</span><span class="ot">@Zin14</span><span class="co">]</span>. This can be slow in comparison to the simulation by thinning of event times occurring in the population, which is based on selecting event times among some competing proposed event times. Finally, <span class="in">`MicSim`</span> simplifies the Mic-Core microsimulation tool implemented in Java <span class="co">[</span><span class="ot">@zinn2009mic</span><span class="co">]</span>. However, the implementation in <span class="in">`R`</span> of simulation algorithms yields longer simulation run times than when using <span class="in">`Rcpp`</span>. </span>
<span id="cb45-86"><a href="#cb45-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-87"><a href="#cb45-87" aria-hidden="true" tabindex="-1"></a>In @sec-overview, we give a short description of Stochastic Individual-Based Models (IBMs) and a quick example of model implementation with the <span class="in">`IBMPopSim`</span> package. </span>
<span id="cb45-88"><a href="#cb45-88" aria-hidden="true" tabindex="-1"></a>In @sec-math, we introduce the mathematical framework that characterizes the class of IBMs that can be implemented in the <span class="in">`IBMPopSim`</span> package. In particular, a general pathwise representation of IBMs is presented. The population dynamics is obtained as the solution of an SDE driven by Poisson measures, for which we obtain existence and uniqueness results in @thm-eq-Z. </span>
<span id="cb45-89"><a href="#cb45-89" aria-hidden="true" tabindex="-1"></a>In @sec-simulation the two main algorithms for simulating the population evolution of an IBM across the interval $<span class="co">[</span><span class="ot">0, T</span><span class="co">]</span>$ are detailed. </span>
<span id="cb45-90"><a href="#cb45-90" aria-hidden="true" tabindex="-1"></a>In @sec-package we present the main functions of the <span class="in">`IBMPopSim`</span> package, which allow for the definition of events and their intensities, the creation of a model, and the simulation of scenarios. </span>
<span id="cb45-91"><a href="#cb45-91" aria-hidden="true" tabindex="-1"></a>Two examples are detailed in @sec-insurance-portfolio and @sec-example-interaction, featuring applications involving an heterogeneous insurance portfolio characterized by entry and exit events, and an age and size-structured population with intricate interactions.</span>
<span id="cb45-92"><a href="#cb45-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-93"><a href="#cb45-93" aria-hidden="true" tabindex="-1"></a><span class="fu"># Brief overview of IBMPopSim {#sec-overview}</span></span>
<span id="cb45-94"><a href="#cb45-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-95"><a href="#cb45-95" aria-hidden="true" tabindex="-1"></a>Stochastic Individual-Based Models (IBMs) represent a broad class of random population dynamics models, allowing the description of population evolution on an individual scale. Informally, an IBM can be summarized by the description of the individuals constituting the population, the various types of events that can occur to these individuals, along with their respective frequencies. In <span class="in">`IBMPopSim`</span>, individuals can be characterized by their age and/or a collection of discrete or continuous characteristics. Moreover, the package enables users to simulate efficiently populations in which one or more of the following event types may occur:</span>
<span id="cb45-96"><a href="#cb45-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-97"><a href="#cb45-97" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Birth event**: addition of an individual of age 0 to the population.</span>
<span id="cb45-98"><a href="#cb45-98" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Death event**: removal of an individual from the population.</span>
<span id="cb45-99"><a href="#cb45-99" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Entry event**: arrival of an individual in the population.</span>
<span id="cb45-100"><a href="#cb45-100" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Exit (emigration) event**: exit from the population (other than death).</span>
<span id="cb45-101"><a href="#cb45-101" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**Swap event**: an individual changes characteristics.</span>
<span id="cb45-102"><a href="#cb45-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-103"><a href="#cb45-103" aria-hidden="true" tabindex="-1"></a>Each event type is linked to an associated event kernel, describing how the population is modified following the occurrence of the event. For some event types, the event kernel requires explicit specification. This is the case for entry events when a new individual joins the population, which requires to specify the age and characteristics of this new individual. For instance, the characteristics of a new individual in the population can be chosen uniformly in the space of all characteristics, or can depend on the distribution of his parents or those of the other individuals composing the population.</span>
<span id="cb45-104"><a href="#cb45-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-105"><a href="#cb45-105" aria-hidden="true" tabindex="-1"></a>The last component of an IBM are the event intensities. Informally, an event intensity is a function $\lambda^e_t(I, Z)$ describing the frequency at which an event $e$ can occur to an individual $I$ in a population $Z$ at a time $t$. Given a history of the population $(\mathcal{F}_t)$, the probability of event $e$ occurring to individual $I$ during a small interval of time $(t,t+dt]$ is proportional to $\lambda^e(I,t)$:</span>
<span id="cb45-106"><a href="#cb45-106" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-107"><a href="#cb45-107" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}(\text{event } e \text{ occurring to $I$ during } (t,t+dt] | \mathcal{F}_t) \simeq \lambda^e_t(I, Z)dt.</span>
<span id="cb45-108"><a href="#cb45-108" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-109"><a href="#cb45-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-110"><a href="#cb45-110" aria-hidden="true" tabindex="-1"></a>The intensity function $\lambda^e$ can include various dependencies:</span>
<span id="cb45-111"><a href="#cb45-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-112"><a href="#cb45-112" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**individual intensity**: $\lambda^e$ depends only on the individual's $I$ age and characteristics, and time $t$,</span>
<span id="cb45-113"><a href="#cb45-113" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>**interaction intensity**: in addition $\lambda^e$ depends on the population composition $Z$.</span>
<span id="cb45-114"><a href="#cb45-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-115"><a href="#cb45-115" aria-hidden="true" tabindex="-1"></a>Prior to providing a detailed description of an Individual-Based Model (IBM), we present a simple model of birth and death in an age-structured _human_ population. We assume no interactions between individuals, and individuals are characterized by their gender, in addition to their age.</span>
<span id="cb45-116"><a href="#cb45-116" aria-hidden="true" tabindex="-1"></a>In this simple model, all individuals, regardless of gender, can give birth when their age falls between 15 and 40 years, with a constant birth rate of 0.05. The death intensity is assumed to follow a Gompertz-type intensity depending on age. </span>
<span id="cb45-117"><a href="#cb45-117" aria-hidden="true" tabindex="-1"></a>The birth and death intensities are then given by  </span>
<span id="cb45-118"><a href="#cb45-118" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb45-119"><a href="#cb45-119" aria-hidden="true" tabindex="-1"></a>    \lambda^b(t, I) = 0.05 \times \mathbf{1}_{<span class="co">[</span><span class="ot">15,40</span><span class="co">]</span>}(a(I,t)), \quad </span>
<span id="cb45-120"><a href="#cb45-120" aria-hidden="true" tabindex="-1"></a>    \lambda^d(t, I) = \alpha\exp(\beta a(I,t)), </span>
<span id="cb45-121"><a href="#cb45-121" aria-hidden="true" tabindex="-1"></a>\end{equation*} </span>
<span id="cb45-122"><a href="#cb45-122" aria-hidden="true" tabindex="-1"></a>with $a(I,t)$ the age of individual $I$ at time $t$. </span>
<span id="cb45-123"><a href="#cb45-123" aria-hidden="true" tabindex="-1"></a>Birth events are also characterized with a kernel determining the gender of the newborn, who is male with probability $p_{male}$. </span>
<span id="cb45-124"><a href="#cb45-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-125"><a href="#cb45-125" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model creation </span></span>
<span id="cb45-126"><a href="#cb45-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-127"><a href="#cb45-127" aria-hidden="true" tabindex="-1"></a>All models in <span class="in">`IBMPopSim`</span> are created with a call to the <span class="in">`mk_model`</span> function, which takes the list of events as an argument. In this example, the events are created with the <span class="in">`mk_event_individual`</span> function, involving  a few lines of <span class="in">`cpp`</span> instructions defining the intensity and, if applicable, the kernel of the event. For a more in depth description of the event creation step and its parameters, we refer to @sec-package-events.</span>
<span id="cb45-128"><a href="#cb45-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-129"><a href="#cb45-129" aria-hidden="true" tabindex="-1"></a>The events of this simple model are for example defined through the following calls.</span>
<span id="cb45-132"><a href="#cb45-132" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-133"><a href="#cb45-133" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb45-134"><a href="#cb45-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-135"><a href="#cb45-135" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(IBMPopSim)</span>
<span id="cb45-136"><a href="#cb45-136" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-137"><a href="#cb45-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-140"><a href="#cb45-140" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-141"><a href="#cb45-141" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb45-142"><a href="#cb45-142" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>, </span>
<span id="cb45-143"><a href="#cb45-143" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = birth_rate(I.age(t));"</span>,</span>
<span id="cb45-144"><a href="#cb45-144" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"newI.male = CUnif(0,1) &lt; p_male;"</span>)</span>
<span id="cb45-145"><a href="#cb45-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-146"><a href="#cb45-146" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>(</span>
<span id="cb45-147"><a href="#cb45-147" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb45-148"><a href="#cb45-148" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha * exp(beta * I.age(t));"</span>)</span>
<span id="cb45-149"><a href="#cb45-149" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-150"><a href="#cb45-150" aria-hidden="true" tabindex="-1"></a>In the <span class="in">`cpp`</span> codes, the names <span class="in">`birth_rate`</span>, <span class="in">`p_male`</span>, <span class="in">`alpha`</span> and <span class="in">`beta`</span> refer to the model parameters defined in the following list. </span>
<span id="cb45-153"><a href="#cb45-153" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-154"><a href="#cb45-154" aria-hidden="true" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb45-155"><a href="#cb45-155" aria-hidden="true" tabindex="-1"></a>  <span class="st">"alpha"</span> <span class="ot">=</span> <span class="fl">0.008</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">0.02</span>, </span>
<span id="cb45-156"><a href="#cb45-156" aria-hidden="true" tabindex="-1"></a>  <span class="st">"p_male"</span> <span class="ot">=</span> <span class="fl">0.51</span>,</span>
<span id="cb45-157"><a href="#cb45-157" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_rate"</span> <span class="ot">=</span> <span class="fu">stepfun</span>(<span class="fu">c</span>(<span class="dv">15</span>, <span class="dv">40</span>), <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.05</span>, <span class="dv">0</span>)))</span>
<span id="cb45-158"><a href="#cb45-158" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-159"><a href="#cb45-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-160"><a href="#cb45-160" aria-hidden="true" tabindex="-1"></a>In a second step, the model is created by calling the function <span class="in">`mk_model`</span>. A <span class="in">`cpp`</span> source code is automatically created through a template mechanism based on the events and parameters, subsequently compiled using the <span class="in">`sourceCpp`</span> function from the <span class="in">`Rcpp`</span> package.</span>
<span id="cb45-163"><a href="#cb45-163" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-164"><a href="#cb45-164" aria-hidden="true" tabindex="-1"></a>birth_death_model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb45-165"><a href="#cb45-165" aria-hidden="true" tabindex="-1"></a>  <span class="at">characteristics =</span> <span class="fu">c</span>(<span class="st">"male"</span> <span class="ot">=</span> <span class="st">"bool"</span>),</span>
<span id="cb45-166"><a href="#cb45-166" aria-hidden="true" tabindex="-1"></a>  <span class="at">events =</span> <span class="fu">list</span>(death_event, birth_event),</span>
<span id="cb45-167"><a href="#cb45-167" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params)</span>
<span id="cb45-168"><a href="#cb45-168" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-169"><a href="#cb45-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-170"><a href="#cb45-170" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simulation </span></span>
<span id="cb45-171"><a href="#cb45-171" aria-hidden="true" tabindex="-1"></a>Once the model is created and compiled, the <span class="in">`popsim`</span> function is called to simulate the evolution of a population according to this model. To achieve this, an initial population must be defined. In this example, we extract a population from a dataset specified in the package (a sample of $100\,000$ individuals based on the population of England and Wales in 2014). It is also necessary to set bounds for the events intensities. In this example, they are obtained by assuming that the maximum age for an individual is 115 years. </span>
<span id="cb45-174"><a href="#cb45-174" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-175"><a href="#cb45-175" aria-hidden="true" tabindex="-1"></a>a_max <span class="ot">&lt;-</span> <span class="dv">115</span></span>
<span id="cb45-176"><a href="#cb45-176" aria-hidden="true" tabindex="-1"></a>events_bounds <span class="ot">=</span> <span class="fu">c</span>(</span>
<span id="cb45-177"><a href="#cb45-177" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> params<span class="sc">$</span>alpha <span class="sc">*</span> <span class="fu">exp</span>(params<span class="sc">$</span>beta <span class="sc">*</span> a_max),</span>
<span id="cb45-178"><a href="#cb45-178" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="fu">max</span>(params<span class="sc">$</span>birth_rate))</span>
<span id="cb45-179"><a href="#cb45-179" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-180"><a href="#cb45-180" aria-hidden="true" tabindex="-1"></a>The function <span class="in">`popsim`</span> can now be called to simulate the population starting from the initial population <span class="in">`population(EW_pop_14$sample)`</span> up to time $T = 30$. </span>
<span id="cb45-183"><a href="#cb45-183" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-184"><a href="#cb45-184" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(</span>
<span id="cb45-185"><a href="#cb45-185" aria-hidden="true" tabindex="-1"></a>  birth_death_model, </span>
<span id="cb45-186"><a href="#cb45-186" aria-hidden="true" tabindex="-1"></a>  <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample), </span>
<span id="cb45-187"><a href="#cb45-187" aria-hidden="true" tabindex="-1"></a>  events_bounds, </span>
<span id="cb45-188"><a href="#cb45-188" aria-hidden="true" tabindex="-1"></a>  <span class="at">parameters =</span> params, <span class="at">age_max =</span> a_max, </span>
<span id="cb45-189"><a href="#cb45-189" aria-hidden="true" tabindex="-1"></a>  <span class="at">time =</span> <span class="dv">30</span>)</span>
<span id="cb45-190"><a href="#cb45-190" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-191"><a href="#cb45-191" aria-hidden="true" tabindex="-1"></a>The data frame <span class="in">`sim_out$population`</span> contains the information (birth, death, gender) on individuals who lived in the population over the period $<span class="co">[</span><span class="ot">0,30</span><span class="co">]</span>$. Functions of the package allows to provide aggregated information on the population.</span>
<span id="cb45-192"><a href="#cb45-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-193"><a href="#cb45-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-194"><a href="#cb45-194" aria-hidden="true" tabindex="-1"></a><span class="fu"># Mathematical framework {#sec-math}</span></span>
<span id="cb45-195"><a href="#cb45-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-196"><a href="#cb45-196" aria-hidden="true" tabindex="-1"></a>In this section, we define rigorously the class of IBMs that can be simulated in <span class="in">`IBMPopSim`</span>, along with the assumptions that are required in order for the population to be simulatable. The representation of age-structured IBMs based on measure-valued processes, as introduced in @tran_2008, is generalized to a wider class of abstract population dynamics. The modeling differs slightly here, since individuals are _kept in the population_ after their death (or exit), by including the death/exit date as an individual trait. </span>
<span id="cb45-197"><a href="#cb45-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-198"><a href="#cb45-198" aria-hidden="true" tabindex="-1"></a>In the remainder of the paper, the filtered probability space is denoted by $(\Omega,<span class="sc">\{</span>\mathcal{F}_t \},{\mathbb{P}})$, under the usual assumptions. All processes are assumed to be càdlàg and adapted to the filtration $\{\mathcal{F}_t \}$ (for instance the history of the population) on a time interval $[0,T]$. For a càdlàg process $X$, we denote $X_{t^-} := \lim_{\genfrac{}{}{0pt}{2}{s\to t}{s&lt;t}} X_s$.</span>
<span id="cb45-199"><a href="#cb45-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-200"><a href="#cb45-200" aria-hidden="true" tabindex="-1"></a><span class="fu">## Population {#sec-population}</span></span>
<span id="cb45-201"><a href="#cb45-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-202"><a href="#cb45-202" aria-hidden="true" tabindex="-1"></a>As mentioned in @sec-overview a population is a collection of individuals whose evolution defines the population process. </span>
<span id="cb45-203"><a href="#cb45-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-204"><a href="#cb45-204" aria-hidden="true" tabindex="-1"></a><span class="fu">### Individuals</span></span>
<span id="cb45-205"><a href="#cb45-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-206"><a href="#cb45-206" aria-hidden="true" tabindex="-1"></a>An individual is represented by a triplet $I = (\tau^b, \tau^d, x) \in \mathcal{I}= {\mathbb{R}}\times \bar {\mathbb{R}}\times {\mathcal{X}}$ with:</span>
<span id="cb45-207"><a href="#cb45-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-208"><a href="#cb45-208" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\tau^b \in {\mathbb{R}}$ the date of birth,</span>
<span id="cb45-209"><a href="#cb45-209" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\tau^d \in \bar {\mathbb{R}}$ the death date, with $\tau^d = \infty$ if the individual is still alive,</span>
<span id="cb45-210"><a href="#cb45-210" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>a collection $x \in {\mathcal{X}}$ of characteristics where ${\mathcal{X}}$ is the space of characteristics.</span>
<span id="cb45-211"><a href="#cb45-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-212"><a href="#cb45-212" aria-hidden="true" tabindex="-1"></a>Note that in IBMs, individuals are usually characterized by their age $a(t) =t-\tau^b$ instead of their date of birth $\tau^b$. However, using the latter is actually easier for the simulation, as it remains constant over time.</span>
<span id="cb45-213"><a href="#cb45-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-214"><a href="#cb45-214" aria-hidden="true" tabindex="-1"></a><span class="fu">### Population process</span></span>
<span id="cb45-215"><a href="#cb45-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-216"><a href="#cb45-216" aria-hidden="true" tabindex="-1"></a>The population at a given time $t$ is a random set</span>
<span id="cb45-217"><a href="#cb45-217" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-218"><a href="#cb45-218" aria-hidden="true" tabindex="-1"></a>    Z_t=<span class="sc">\{</span> I_k \in \mathcal{I}; \; k= 1,\dots, N_t<span class="sc">\}</span>,</span>
<span id="cb45-219"><a href="#cb45-219" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-220"><a href="#cb45-220" aria-hidden="true" tabindex="-1"></a>composed of all individuals (alive or dead) who have lived in the population before time $t$. As a random set, $Z_t$ can be represented by a random counting measure on $\mathcal{I}$ , that is an integer-valued measure $Z: \Omega \times \mathcal{I}\to \bar {\mathbb{N}}$ where for $A \in \mathcal{I}$, $Z(A)$ is the (random) number of individuals $I$ in the subset $A$. With this representation: </span>
<span id="cb45-221"><a href="#cb45-221" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-222"><a href="#cb45-222" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb45-223"><a href="#cb45-223" aria-hidden="true" tabindex="-1"></a>    Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} \delta_{I_k} (\tau^b, \tau^d,x),  <span class="sc">\\</span></span>
<span id="cb45-224"><a href="#cb45-224" aria-hidden="true" tabindex="-1"></a>    \text{ with }  \int_{\mathcal{I}} f(\tau^b, \tau^d, x) Z_t (\mathrm{d}\tau^b, \mathrm{d}\tau^d , \mathrm{d}x) &amp;= \sum_{k=1}^{N_t} f(I_k).</span>
<span id="cb45-225"><a href="#cb45-225" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb45-226"><a href="#cb45-226" aria-hidden="true" tabindex="-1"></a>$$ {#eq-popZ}</span>
<span id="cb45-227"><a href="#cb45-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-228"><a href="#cb45-228" aria-hidden="true" tabindex="-1"></a>The number of individuals present in the population *before time* $t$ is obtained by taking $f\equiv 1$:</span>
<span id="cb45-229"><a href="#cb45-229" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-230"><a href="#cb45-230" aria-hidden="true" tabindex="-1"></a>    N_t =  \int_{\mathcal{I}}  Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \mathbf{1}_{\mathcal{I}} (I_k).</span>
<span id="cb45-231"><a href="#cb45-231" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-232"><a href="#cb45-232" aria-hidden="true" tabindex="-1"></a>Note that $(N_t)_{t\geq 0}$ is an increasing process since dead/exited individuals are kept in the population $Z$. The number of alive individuals in the population at time $t$ is: </span>
<span id="cb45-233"><a href="#cb45-233" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-234"><a href="#cb45-234" aria-hidden="true" tabindex="-1"></a>    N_t^a =  \int_{\mathcal{I}}  \mathbf{1}_{\{\tau^d &gt; t \} }Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t} \mathbf{1}_{<span class="sc">\{</span>\tau^d_k &gt; t <span class="sc">\}</span> }.</span>
<span id="cb45-235"><a href="#cb45-235" aria-hidden="true" tabindex="-1"></a>$$ {#eq-Nta}</span>
<span id="cb45-236"><a href="#cb45-236" aria-hidden="true" tabindex="-1"></a>Another example is the number of alive individuals of age over $a$ is</span>
<span id="cb45-237"><a href="#cb45-237" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-238"><a href="#cb45-238" aria-hidden="true" tabindex="-1"></a>    N_t(<span class="co">[</span><span class="ot">a,+\infty)) :=  \int_{\mathcal{I}}  \mathbf{1}_{[a,+\infty)}(t-\tau^b)\mathbf{1}_{]t,\infty</span><span class="co">]</span>}(\tau^d) Z_t(\mathrm{d}\tau^b, \mathrm{d}\tau^d, \mathrm{d}x) = \sum_{k=1}^{N_t}  \mathbf{1}_{\{ t -\tau_k^b \geq a \}}\mathbf{1}_{<span class="sc">\{</span>\tau^d_k \geq t <span class="sc">\}</span> }.</span>
<span id="cb45-239"><a href="#cb45-239" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-240"><a href="#cb45-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-241"><a href="#cb45-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-242"><a href="#cb45-242" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events {#sec-events}</span></span>
<span id="cb45-243"><a href="#cb45-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-244"><a href="#cb45-244" aria-hidden="true" tabindex="-1"></a>The population composition changes at random dates following different types of events. <span class="in">`IBMPopSim`</span> allows the simulation of IBMs with the following events types:</span>
<span id="cb45-245"><a href="#cb45-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-246"><a href="#cb45-246" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A **birth** event at time $t$ is the addition of a new individual $I'=(t,\infty, X)$ of age $0$ to the population. Their date of birth is $\tau^b =t$, and characteristics is $X$, a random variable of distribution defined by the birth kernel $k^b(t,I,\mathrm{d}x)$ on ${\mathcal{X}}$, depending on $t$ and its parent $I$. The population size becomes $N_t = N_{t^-} + 1$, and the population composition after the event is $$Z_t  = Z_{t^-} +  \delta_{(t,\infty, X)}.$$</span>
<span id="cb45-247"><a href="#cb45-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-248"><a href="#cb45-248" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>An **entry** event at time $t$ is also the addition of an individual $I'$ in the population. However, this individual is not of age $0$. The date of birth and characteristics of the new individual $I'= (\tau^b, \infty, X)$ are random variables of probability distribution defined by the entry kernel $k^{en}(t, \mathrm{d}s, \mathrm{d}x)$ on ${\mathbb{R}}\times {\mathcal{X}}$. The population size becomes $N_t = N_{t^-} + 1$, and the population composition after the event is: </span>
<span id="cb45-249"><a href="#cb45-249" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-250"><a href="#cb45-250" aria-hidden="true" tabindex="-1"></a>    Z_t  = Z_{t^-} +  \delta_{(\tau^b, \infty, X)}.</span>
<span id="cb45-251"><a href="#cb45-251" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-252"><a href="#cb45-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-253"><a href="#cb45-253" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A **death** or **exit** event of an individual $I= (\tau^b,\infty, x)\in Z_{t^-}$ at time $t$ is the modification of its death date $\tau^d$ from $+\infty$ to $t$. This event results in the simultaneous addition of the individual $(\tau^b,t,x)$ and removal of the individual $I$ from the population. The population size is not modified, and the population composition after the event is </span>
<span id="cb45-254"><a href="#cb45-254" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-255"><a href="#cb45-255" aria-hidden="true" tabindex="-1"></a>    Z_t  = Z_{t^-} +\delta_{(\tau^b,t,x)}- \delta_{I}.</span>
<span id="cb45-256"><a href="#cb45-256" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-257"><a href="#cb45-257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-258"><a href="#cb45-258" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>A **swap** event (change of characteristics) results in the simultaneous addition and removal of an individual. If an individual $I= (\tau^b,\infty, x) \in Z_{t^-}$ changes of characteristics at time $t$, then it is removed from the population and replaced by $I' = (\tau^b,\infty, X)$. The new characteristics $X$ is a random variable of distribution $k^s(t, I,\mathrm{d}x)$ on ${\mathcal{X}}$, depending on time, the individual's age and previous characteristics $x$. In this case, the population size is not modified and the population becomes:</span>
<span id="cb45-259"><a href="#cb45-259" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-260"><a href="#cb45-260" aria-hidden="true" tabindex="-1"></a>    Z_t  = Z_{t^-}   +  \delta_{(\tau^b,  \infty, X)} -  \delta_{(\tau^b, \infty, x)}.</span>
<span id="cb45-261"><a href="#cb45-261" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-262"><a href="#cb45-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-263"><a href="#cb45-263" aria-hidden="true" tabindex="-1"></a>To summarize, the space of event types is $E = <span class="sc">\{</span> b, en, d, s <span class="sc">\}</span>$, and the jump $\Delta Z_t = Z_t - Z_{t^-}$ (change in the population composition) generated by an event of type $e \in <span class="sc">\{</span> b, en, d, s <span class="sc">\}</span>$ is denoted by $\phi^e(t, I)$. We thus have the following rules summarized in @tbl-event-action.</span>
<span id="cb45-264"><a href="#cb45-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-265"><a href="#cb45-265" aria-hidden="true" tabindex="-1"></a>Event | Type | $\phi^e(t, I)$ | New individual</span>
<span id="cb45-266"><a href="#cb45-266" aria-hidden="true" tabindex="-1"></a>------|:----:|----------------|---------------</span>
<span id="cb45-267"><a href="#cb45-267" aria-hidden="true" tabindex="-1"></a>Birth | $b$ | $\delta_{(t, \infty,  X)}$ | $\tau^b =t, \; X \sim k^b(t,I,\mathrm{d}x)$ </span>
<span id="cb45-268"><a href="#cb45-268" aria-hidden="true" tabindex="-1"></a>Entry | $en$ | $\delta_{(\tau^b, \infty,  X)}$ | $(\tau^b, X) \sim k^{en}(t,\mathrm{d}s, \mathrm{d}x)$ </span>
<span id="cb45-269"><a href="#cb45-269" aria-hidden="true" tabindex="-1"></a>Death/Exit | $d$ | $\delta_{(\tau^b, t,x)} - \delta_{(\tau^b, \infty, x)}$ | $\tau^d = t$</span>
<span id="cb45-270"><a href="#cb45-270" aria-hidden="true" tabindex="-1"></a>Swap | $s$ | $\delta_{(\tau^b, \infty , X)} - \delta_{(\tau^b, \infty, x)}$ | $X \sim k^s(t,I,\mathrm{d}x)$</span>
<span id="cb45-271"><a href="#cb45-271" aria-hidden="true" tabindex="-1"></a>: Action in the population for a given event type {#tbl-event-action}</span>
<span id="cb45-272"><a href="#cb45-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-273"><a href="#cb45-273" aria-hidden="true" tabindex="-1"></a>::: {#rem-popfinale}</span>
<span id="cb45-274"><a href="#cb45-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-275"><a href="#cb45-275" aria-hidden="true" tabindex="-1"></a><span class="fu">## Composition of the population </span></span>
<span id="cb45-276"><a href="#cb45-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-277"><a href="#cb45-277" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>At time $T$, the population $Z_T$ contains all individuals who lived in the population before $T$, including dead/exited individuals. If there are no swap events, or entries, the population state $Z_t$ for any time $t\leq T$ can be obtained from $Z_T$. Indeed, if $Z_T = \sum_{k=1}^{N_T}  \delta_{I_k}$, then the population at time $t\leq T$ is simply composed of the individuals born before $t$: $$</span>
<span id="cb45-278"><a href="#cb45-278" aria-hidden="true" tabindex="-1"></a>    Z_t = \sum_{k=1}^{N_T} \mathbf{1}_{\{\tau^b_k \leq t \}} \delta_{I_k}.</span>
<span id="cb45-279"><a href="#cb45-279" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-280"><a href="#cb45-280" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>In the presence of entries (open population), a characteristic $x$ can track the individuals' entry dates. Then, the previous equation can be easily modified in order to obtain the population $Z_t$ at time $t\leq T$ from $Z_T$.</span>
<span id="cb45-281"><a href="#cb45-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-282"><a href="#cb45-282" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-283"><a href="#cb45-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-284"><a href="#cb45-284" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events intensity {#sec-event-intensity}</span></span>
<span id="cb45-285"><a href="#cb45-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-286"><a href="#cb45-286" aria-hidden="true" tabindex="-1"></a>Once the different event types have been defined in the population model, the frequency at which each event $e$ occurs in the population has to be specified.</span>
<span id="cb45-287"><a href="#cb45-287" aria-hidden="true" tabindex="-1"></a>Informally, the intensity $\Lambda^e_t(Z_t)$ at which an event $e$ can occur is defined by</span>
<span id="cb45-288"><a href="#cb45-288" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-289"><a href="#cb45-289" aria-hidden="true" tabindex="-1"></a>    \mathbb P\big( \text{event } e \text { occurs in the population }  Z_t  \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \Lambda^e_t (Z_t)\mathrm{d}t.</span>
<span id="cb45-290"><a href="#cb45-290" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-291"><a href="#cb45-291" aria-hidden="true" tabindex="-1"></a>For a more formal definition of stochastic intensities, we refer to @bremaud1981point or @KaaElK20. The form of the intensity function $(\Lambda^e_t (Z_t))$ determines the population simulation algorithm in <span class="in">`IBMPopSim`</span>:</span>
<span id="cb45-292"><a href="#cb45-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-293"><a href="#cb45-293" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When the event intensity does not depend on the population state, </span>
<span id="cb45-294"><a href="#cb45-294" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-295"><a href="#cb45-295" aria-hidden="true" tabindex="-1"></a>    \big(\Lambda^e_t (Z_t)\big)_{t\in [0,T]} = \big(\mu^e(t)\big)_{t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>},</span>
<span id="cb45-296"><a href="#cb45-296" aria-hidden="true" tabindex="-1"></a>$$ {#eq-poisson-intensity}</span>
<span id="cb45-297"><a href="#cb45-297" aria-hidden="true" tabindex="-1"></a>with $\mu^e$ a deterministic function, the events of type $e$ occur at the jump times of an inhomogeneous Poisson process of intensity function $(\mu^e(t))_{t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$. </span>
<span id="cb45-298"><a href="#cb45-298" aria-hidden="true" tabindex="-1"></a>This is particularly useful when entry events occur with intensities influenced by environmental processes and/or exhibit seasonal variations.</span>
<span id="cb45-299"><a href="#cb45-299" aria-hidden="true" tabindex="-1"></a>When such an event occurs, the individual to whom the event happens is drawn uniformly from the living individuals in the population.</span>
<span id="cb45-300"><a href="#cb45-300" aria-hidden="true" tabindex="-1"></a>In a given model, the set of events $e\in E$ with Poisson intensities will be denoted by $\mathcal{P}$.</span>
<span id="cb45-301"><a href="#cb45-301" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Otherwise, we assume that the global intensity $\Lambda^e_t(Z_t)$ at which the events of type $e$ occur in the population can be written as the sum of individual intensities $\lambda^e_t(I,Z_t)$:</span>
<span id="cb45-302"><a href="#cb45-302" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-303"><a href="#cb45-303" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb45-304"><a href="#cb45-304" aria-hidden="true" tabindex="-1"></a>    &amp;\Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e_t ( I_k,Z_t),  <span class="sc">\\</span></span>
<span id="cb45-305"><a href="#cb45-305" aria-hidden="true" tabindex="-1"></a>    &amp;  \text{with } \mathbb P\big( \text{event } e \text { occurs to an individual } I \in (t,t+\mathrm{d}t] | \mathcal{F}_t \big) \simeq  \lambda^e_t (I,Z_t)\mathrm{d}t.</span>
<span id="cb45-306"><a href="#cb45-306" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb45-307"><a href="#cb45-307" aria-hidden="true" tabindex="-1"></a>$$ {#eq-global-intensity}</span>
<span id="cb45-308"><a href="#cb45-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-309"><a href="#cb45-309" aria-hidden="true" tabindex="-1"></a>Obviously, nothing can happen to dead or exited individuals, i.e. individuals $I= (\tau^b, \tau^d, x)$ with $\tau^d \leq t$. Thus, individual event intensities are assumed to be null for dead/exited individuals:</span>
<span id="cb45-310"><a href="#cb45-310" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-311"><a href="#cb45-311" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t ( I,Z_t) = 0, \text{ if }\tau^d \leq t, \text{ so that } \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t^a} \lambda^e_t ( I_k,Z_t),</span>
<span id="cb45-312"><a href="#cb45-312" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-313"><a href="#cb45-313" aria-hidden="true" tabindex="-1"></a>with $N^a_t$ the number of alive individuals at time $t$.</span>
<span id="cb45-314"><a href="#cb45-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-315"><a href="#cb45-315" aria-hidden="true" tabindex="-1"></a>The event's individual intensity $\lambda^e_t (I,Z_t)$ can depend on time (for instance when there is a mortality reduction over time), on the individual's age $t-\tau^b$ and characteristics, but also on the population composition $Z_t$. The dependence of $\lambda^e$ on the population $Z$ models interactions between individuals in the populations. Hence, two types of individual intensity functions can be implemented in <span class="in">`IBMPopSim`</span>:</span>
<span id="cb45-316"><a href="#cb45-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-317"><a href="#cb45-317" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>*No interactions:* The intensity function $\lambda^e$ does not depend on the population composition. The intensity at which an event of type $e$ occurs to an individual $I$ only depends on its date of birth and characteristics: </span>
<span id="cb45-318"><a href="#cb45-318" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-319"><a href="#cb45-319" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t (I,Z_t) = \lambda^e(t, I),</span>
<span id="cb45-320"><a href="#cb45-320" aria-hidden="true" tabindex="-1"></a>$$ {#eq-intensity-no-interaction}</span>
<span id="cb45-321"><a href="#cb45-321" aria-hidden="true" tabindex="-1"></a>where $\lambda^e: \mathbb{R}_+ \times \mathcal{I}\to {\mathbb{R}}^+$ is a deterministic function. In a given model, we denote by $\mathcal{E}$ the set of event types with individual intensity @eq-intensity-no-interaction.</span>
<span id="cb45-322"><a href="#cb45-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-323"><a href="#cb45-323" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>*"Quadratic" interactions:* The intensity at which an event of type $e$ occurs to an individual $I$ depends on $I$ and on the population composition, through an interaction function $W^e$. The quantity $W^e(t, I,J)$ describes the intensity of interactions between two alive individuals $I$ and $J$ at time $t$, for instance in the presence of competition or cooperation. In this case, we have</span>
<span id="cb45-324"><a href="#cb45-324" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-325"><a href="#cb45-325" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t(I,Z_t)=\sum_{j=1}^{N_t} W^e(t, I, I_j) = \int_{\mathcal{I}} W^e(t, I, (\tau^b,\tau^d,x)) Z_t (\mathrm{d}\tau^b,\mathrm{d}\tau^d, \mathrm{d}x),</span>
<span id="cb45-326"><a href="#cb45-326" aria-hidden="true" tabindex="-1"></a>$$ {#eq-intensity-interaction}</span>
<span id="cb45-327"><a href="#cb45-327" aria-hidden="true" tabindex="-1"></a>where $W^e(t, I, (\tau^b,\tau^d,x))  = 0$ if the individual $J =(\tau^b,\tau^d,x)$ is dead, i.e. $\tau^d \leq t$.\ In a given model, we denote by $\mathcal{E}_W$ the set of event types with individual intensity @eq-intensity-interaction.</span>
<span id="cb45-328"><a href="#cb45-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-329"><a href="#cb45-329" aria-hidden="true" tabindex="-1"></a>To summarize, an individual intensity in IBMPopSim can be written as:</span>
<span id="cb45-330"><a href="#cb45-330" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-331"><a href="#cb45-331" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t(I,Z_t) = \lambda^e(t, I) \mathbf{1}_{\{e \in \mathcal{E}\}} + \biggl( \sum_{j=1}^{N_t} W^e(t, I, I_j) \biggr) \mathbf{1}_{<span class="sc">\{</span>e \in \mathcal{E}_W<span class="sc">\}</span>}.</span>
<span id="cb45-332"><a href="#cb45-332" aria-hidden="true" tabindex="-1"></a>$$ {#eq-individual-intensity}</span>
<span id="cb45-333"><a href="#cb45-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-334"><a href="#cb45-334" aria-hidden="true" tabindex="-1"></a>::: {#exm-popfinale}</span>
<span id="cb45-335"><a href="#cb45-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-336"><a href="#cb45-336" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>An example of death intensity without interaction for an individual $I=(\tau^b, \tau^d, x)$ alive at time $t$, $t &lt; \tau^d$, is:</span>
<span id="cb45-337"><a href="#cb45-337" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-338"><a href="#cb45-338" aria-hidden="true" tabindex="-1"></a>    \lambda^d(t,I) =  \alpha_x \exp(\beta_x a(I,t)), \text{ where }  a(I,t) = t-\tau^b</span>
<span id="cb45-339"><a href="#cb45-339" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-340"><a href="#cb45-340" aria-hidden="true" tabindex="-1"></a>is the age of the individual $I$ at time $t$. In this standard case, the death rate of an individual $I$ is an exponential (Gompertz) function of the individual's age, with coefficients depending on the individual's characteristics $x$.</span>
<span id="cb45-341"><a href="#cb45-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-342"><a href="#cb45-342" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>In the presence of competition between individuals, the death intensity of an individual $I$ also depends on other individuals $J$ in the population. For example, if $I=(\tau^b,\tau^d, x)$, with its size $x$, then we have: </span>
<span id="cb45-343"><a href="#cb45-343" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-344"><a href="#cb45-344" aria-hidden="true" tabindex="-1"></a>    W^d(t,I,J) = (x_J - x)^+ \mathbf{1}_{<span class="sc">\{</span>\tau^d_J &gt; t<span class="sc">\}</span>}, \quad \forall \; J=(\tau^b_J,\tau^d_J , x_J).</span>
<span id="cb45-345"><a href="#cb45-345" aria-hidden="true" tabindex="-1"></a>$$ {#eq-ex-interaction}</span>
<span id="cb45-346"><a href="#cb45-346" aria-hidden="true" tabindex="-1"></a>This can be interpreted as follows: if the individual $I$ meets randomly an individual $J$ alive at time $t$, and of bigger size $x_J &gt; x$, then he can die at the intensity $x_J-x$. If $J$ is smaller than $I$, then it cannot kill $I$. The bigger is the size $x$ of $I$, the lower is its death intensity $\lambda^d_t(I,Z_t)$ defined by </span>
<span id="cb45-347"><a href="#cb45-347" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-348"><a href="#cb45-348" aria-hidden="true" tabindex="-1"></a>    \lambda^d_t(I,Z_t) = \sum_{\genfrac{}{}{0pt}{2}{J\in Z_t,}{x_J &gt; x}} (x_J -x)\mathbf{1}_{<span class="sc">\{</span>\tau^d_J &gt; t<span class="sc">\}</span>}.</span>
<span id="cb45-349"><a href="#cb45-349" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-350"><a href="#cb45-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-351"><a href="#cb45-351" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span><span class="in">`IBMPopSim`</span> can simulate IBMs that include intensities expressed as a sum of Poisson intensities and individual intensities of the form $\Lambda^e(Z_t) =\mu^e_t + \sum_{k=1}^{N_t} \lambda^e(I_k, Z_t)$. Other examples are provided in @sec-insurance-portfolio and @sec-example-interaction.</span>
<span id="cb45-352"><a href="#cb45-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-353"><a href="#cb45-353" aria-hidden="true" tabindex="-1"></a>Finally, the global intensity at which an event can occur in the population is defined by: </span>
<span id="cb45-354"><a href="#cb45-354" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-355"><a href="#cb45-355" aria-hidden="true" tabindex="-1"></a>    \Lambda_t(Z_t) = \sum_{e\in \mathcal{P}} \mu^e(t) + \sum_{e \in \mathcal E} \Big(\sum_{k=1}^{N_t} \lambda^e(t, I_k)\Big) + \sum_{e \in \mathcal E_W} \Big(\sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)\Big).</span>
<span id="cb45-356"><a href="#cb45-356" aria-hidden="true" tabindex="-1"></a>$$ {#eq-global-ev-intensity}</span>
<span id="cb45-357"><a href="#cb45-357" aria-hidden="true" tabindex="-1"></a>An important point is that for events $e \in \mathcal E$ without interactions, the global event intensity $\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I_k)$ is _of order_ $N_t^a$ defined in @eq-Nta (number of alive individuals at time $t$). On the other hand, for events $e \in \mathcal{E}_W$ with interactions, $\Lambda^e_t(Z_t) = \sum_{k=1}^{N_t}\sum_{j=1}^{N_t} W^e(t, I_k, I_j)$ is of order $(N_t^a)^2$. </span>
<span id="cb45-358"><a href="#cb45-358" aria-hidden="true" tabindex="-1"></a>Informally, this means that when the population size increases, events with interaction are more costly to simulate. Furthermore, the numerous computations of the interaction kernel $W^e$ can also be computationally costly. The randomized @alg-randomized, detailed in</span>
<span id="cb45-359"><a href="#cb45-359" aria-hidden="true" tabindex="-1"></a>@sec-simulation-randomized, allows us to overcome these limitations.</span>
<span id="cb45-360"><a href="#cb45-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-361"><a href="#cb45-361" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-362"><a href="#cb45-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-363"><a href="#cb45-363" aria-hidden="true" tabindex="-1"></a><span class="fu">### Events intensity bounds {.unnumbered}</span></span>
<span id="cb45-364"><a href="#cb45-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-365"><a href="#cb45-365" aria-hidden="true" tabindex="-1"></a>The simulation algorithms implemented in <span class="in">`IBMPopSim`</span> are based on an acceptance/rejection procedure, which requires the user to specify bounds for the various events intensities $\Lambda^e_t(Z_t)$. These bounds are defined differently depending on the expression of the intensity.</span>
<span id="cb45-366"><a href="#cb45-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-367"><a href="#cb45-367" aria-hidden="true" tabindex="-1"></a>::: {#cnj-intensity-poisson} </span>
<span id="cb45-368"><a href="#cb45-368" aria-hidden="true" tabindex="-1"></a>For all events $e \in \mathcal{P}$ with Poisson intensity (@eq-poisson-intensity), the intensity is assumed to be bounded on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$:</span>
<span id="cb45-369"><a href="#cb45-369" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-370"><a href="#cb45-370" aria-hidden="true" tabindex="-1"></a>    \forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>, \quad \Lambda^e_t(Z_t) = \mu^e(t) \leq \bar \mu^e.</span>
<span id="cb45-371"><a href="#cb45-371" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-372"><a href="#cb45-372" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-373"><a href="#cb45-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-374"><a href="#cb45-374" aria-hidden="true" tabindex="-1"></a>When $e \in \mathcal{E} \cup \mathcal{E}_W$, $\Lambda^e_t(Z_t) =\sum_{k=1}^{N_t} \lambda^e_t(I_k,Z_t)$, assuming that $\Lambda^e_t(Z_t)$ is uniformly bounded is too restrictive since the event intensity depends on the population size. In this case, the assumption is made on the individual intensity $\lambda^e$ or on the interaction function $W^e$, depending on the situation.</span>
<span id="cb45-375"><a href="#cb45-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-376"><a href="#cb45-376" aria-hidden="true" tabindex="-1"></a>::: {#cnj-intensity1}</span>
<span id="cb45-377"><a href="#cb45-377" aria-hidden="true" tabindex="-1"></a>For all event types $e \in \mathcal{E}$, the associated individual event intensity $\lambda^e$ with no interactions (@eq-intensity-no-interaction) is assumed to be uniformly bounded:</span>
<span id="cb45-378"><a href="#cb45-378" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-379"><a href="#cb45-379" aria-hidden="true" tabindex="-1"></a>    \lambda^e(t, I) \leq \bar \lambda^e, \quad \forall \;  t\in <span class="co">[</span><span class="ot">0, T</span><span class="co">]</span>,  \;   I \in \mathcal{I}.</span>
<span id="cb45-380"><a href="#cb45-380" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-381"><a href="#cb45-381" aria-hidden="true" tabindex="-1"></a>In particular, </span>
<span id="cb45-382"><a href="#cb45-382" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-383"><a href="#cb45-383" aria-hidden="true" tabindex="-1"></a>    \forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>, \quad \Lambda^e_t (Z_t) = \sum_{k=1}^{N_t} \lambda^e(t, I) \leq \bar \lambda^e  N_t .</span>
<span id="cb45-384"><a href="#cb45-384" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-bar-Lambda}</span>
<span id="cb45-385"><a href="#cb45-385" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-386"><a href="#cb45-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-387"><a href="#cb45-387" aria-hidden="true" tabindex="-1"></a>::: {#cnj-intensity2}</span>
<span id="cb45-388"><a href="#cb45-388" aria-hidden="true" tabindex="-1"></a>For all event types $e \in \mathcal{E}_W$, the associated interaction function $W^e$ is assumed to be uniformly bounded:</span>
<span id="cb45-389"><a href="#cb45-389" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-390"><a href="#cb45-390" aria-hidden="true" tabindex="-1"></a>    W^e(t, I, J) \leq \bar W^e, \quad \forall \; t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>, \;   I, J \in \mathcal{I}.</span>
<span id="cb45-391"><a href="#cb45-391" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-392"><a href="#cb45-392" aria-hidden="true" tabindex="-1"></a>In particular, $\forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$,</span>
<span id="cb45-393"><a href="#cb45-393" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-394"><a href="#cb45-394" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I, I_j)  \leq  \bar W^e N_t, \quad \text{and} \quad \Lambda^e_t (Z_t) \leq \bar W^e (N_t)^2.</span>
<span id="cb45-395"><a href="#cb45-395" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-396"><a href="#cb45-396" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-397"><a href="#cb45-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-398"><a href="#cb45-398" aria-hidden="true" tabindex="-1"></a>@cnj-intensity-poisson, @cnj-intensity1 and @cnj-intensity2 yield that events in the population occur with the global event intensity&nbsp;$\Lambda_t(Z_t)$, given in @eq-global-ev-intensity, which is dominated by a polynomial function in the population size: </span>
<span id="cb45-399"><a href="#cb45-399" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-400"><a href="#cb45-400" aria-hidden="true" tabindex="-1"></a>    \Lambda_t(Z_t) \leq \bar \Lambda(N_t), \quad \text{with }  \bar \Lambda (n) = \sum_{e \in \mathcal{P}} \bar \mu^e + \sum_{e\in \mathcal{E}}\bar \lambda^e  n + \sum_{e \in \mathcal E_W} \bar W^e n^2.</span>
<span id="cb45-401"><a href="#cb45-401" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-bar-Lambda}</span>
<span id="cb45-402"><a href="#cb45-402" aria-hidden="true" tabindex="-1"></a>This bound is linear in the population size if there are no interactions, and quadratic if there at least is an event including interactions. This assumption is the key to the algorithms implemented in <span class="in">`IBMPopSim`</span>. Before presenting the simulation algorithm, we close this section with a rigorous definition of an IBM, based on the pathwise representation of its dynamics as a Stochastic Differential Equation (SDE) driven by Poisson random measures.</span>
<span id="cb45-403"><a href="#cb45-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-404"><a href="#cb45-404" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pathwise representation of stochastic IBM</span></span>
<span id="cb45-405"><a href="#cb45-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-406"><a href="#cb45-406" aria-hidden="true" tabindex="-1"></a>Since the seminal paper of @FouMel04, it has been shown that a stochastic IBM dynamics can be defined rigorously as the unique solution of an SDE driven by Poisson measures, under reasonable non explosion conditions. This representation has actually been proved only in particular case, for various models. We provide here a general mathematical framework.  </span>
<span id="cb45-407"><a href="#cb45-407" aria-hidden="true" tabindex="-1"></a>Some recalls on Poisson random measures are presented in the Appendix @sec-recall-poisson, and for more details on these representations of particular examples, we refer to the abundant literature on the subject (see <span class="co">[</span><span class="ot">@bremaud1981point, @Cin11</span><span class="co">]</span> and the references therein).</span>
<span id="cb45-408"><a href="#cb45-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-409"><a href="#cb45-409" aria-hidden="true" tabindex="-1"></a>In the following we consider an individual-based stochastic population $(Z_t)_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$, keeping the notations introduced in @sec-events and @sec-event-intensity for the events and their intensities.</span>
<span id="cb45-410"><a href="#cb45-410" aria-hidden="true" tabindex="-1"></a>In particular, the set of events types that define the population evolution is denoted by $\mathcal{P} \cup \mathcal{E} \cup \mathcal{E}_W \subset E$, with $\mathcal{P}\,$ the set of events types with Poisson intensity verifying @cnj-intensity-poisson, $\mathcal{E}$ the set of events types with individual intensity and no interaction, verifying @cnj-intensity1 and finally $\mathcal{E}_W$ the set of event types with interactions, verifying @cnj-intensity2.</span>
<span id="cb45-411"><a href="#cb45-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-412"><a href="#cb45-412" aria-hidden="true" tabindex="-1"></a><span class="fu">### Non-explosion criterion {.unnumbered}</span></span>
<span id="cb45-413"><a href="#cb45-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-414"><a href="#cb45-414" aria-hidden="true" tabindex="-1"></a>First, one has to ensure that the number of events occurring in the population will not explode in finite time, leading to an infinite simulation time. @cnj-intensity1 and @cnj-intensity2 are not sufficient to guarantee the non explosion of the event number, due to the potential explosion of the population size in the presence of interactions. An example is the case when only birth events occur, with an intensity $\Lambda^b_t(Z_t) = C_b (N_t^a)^2$ (i.e. when $W^b(t, I,J) =C_b$). Then, the number of alive individuals $(N_t^a)_{t\geq 0}$ is a well-known pure birth process of intensity function $g(n) = C_b n^2$ (intensity of moving from state $n$ to $n+1$). This process explodes in finite time, since $g$ does not verify the necessary and sufficient non explosion criterion for pure birth Markov processes: $\sum_{n=1}^\infty \frac{1}{g(n)} = \infty$ (see e.g. Theorem 2.2 in <span class="co">[</span><span class="ot">@BanMel15</span><span class="co">]</span>). There is thus an explosion in finite time of birth events.</span>
<span id="cb45-415"><a href="#cb45-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-416"><a href="#cb45-416" aria-hidden="true" tabindex="-1"></a>This example shows that the important point for non explosion is to control the population size. We give below a general sufficient condition on birth and entry event intensities, in order for the population size to stay finite in finite time. This ensures that the number of events does not explode in finite time. Informally, the idea is to control the intensities by a pure birth intensity function verifying the non-explosion criterion.</span>
<span id="cb45-417"><a href="#cb45-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-418"><a href="#cb45-418" aria-hidden="true" tabindex="-1"></a>::: {#cnj-non-explosion} </span>
<span id="cb45-419"><a href="#cb45-419" aria-hidden="true" tabindex="-1"></a>Let $e\in<span class="sc">\{</span>b, en<span class="sc">\}</span>$ a birth or entry event type. If the intensity at which the events of type $e$ occur in the population are not Poissonian, i.e. $e \in \mathcal{E} \cup \mathcal{E}_W$, then there exists a function $f^e : {\mathbb{N}}\to (0, +\infty)$, such that</span>
<span id="cb45-420"><a href="#cb45-420" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-421"><a href="#cb45-421" aria-hidden="true" tabindex="-1"></a>    \sum_{n=1}^{\infty} \frac{1}{nf^e(n)} = \infty,</span>
<span id="cb45-422"><a href="#cb45-422" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-423"><a href="#cb45-423" aria-hidden="true" tabindex="-1"></a>and for all individual $I \in \mathcal{I}$ and population measure $Z = \sum_{k=1}^{n} \delta_{I_k}$ of size $n$,</span>
<span id="cb45-424"><a href="#cb45-424" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-425"><a href="#cb45-425" aria-hidden="true" tabindex="-1"></a>    \lambda^e_t (I, Z) \leq f^e(n), \; \forall \; 0\leq t \leq T.</span>
<span id="cb45-426"><a href="#cb45-426" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-427"><a href="#cb45-427" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-428"><a href="#cb45-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-429"><a href="#cb45-429" aria-hidden="true" tabindex="-1"></a>::: {#rem}</span>
<span id="cb45-430"><a href="#cb45-430" aria-hidden="true" tabindex="-1"></a>If $e \in \mathcal{E}$, $\lambda_t^e(I,Z) = \lambda^e(t,I) \leq \bar{\lambda}^e$ by the domination @cnj-intensity2, then @cnj-non-explosion is always verified with $f^e(n) = \bar{\lambda}^e$.</span>
<span id="cb45-431"><a href="#cb45-431" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-432"><a href="#cb45-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-433"><a href="#cb45-433" aria-hidden="true" tabindex="-1"></a>@cnj-non-explosion yields that the global intensity $\Lambda_t^e(\cdot)$ of event $e$ is bounded by a function $g^e$ only depending on the population size:</span>
<span id="cb45-434"><a href="#cb45-434" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-435"><a href="#cb45-435" aria-hidden="true" tabindex="-1"></a>    \Lambda_t^e (Z) \leq g^e(n) := nf^e(n), \quad \text{with }\sum_{n=1}^{\infty} \frac{1}{g^e(n)} = \infty.</span>
<span id="cb45-436"><a href="#cb45-436" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-437"><a href="#cb45-437" aria-hidden="true" tabindex="-1"></a>If $e\in \mathcal{P}\,$ has a Poisson intensity, then $\Lambda_t^e(Z) =\mu^e_t$ always verifies the previous equation with $g^e(n) = \bar \mu^e$.</span>
<span id="cb45-438"><a href="#cb45-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-439"><a href="#cb45-439" aria-hidden="true" tabindex="-1"></a>Before introducing the IBM SDE, let us give an idea of the equation construction. Between two successive events, the population composition $Z_t$ stays constant, since the population process $(Z_t)_{t \geq 0}$ is a pure jump process.</span>
<span id="cb45-440"><a href="#cb45-440" aria-hidden="true" tabindex="-1"></a>Furthermore, since each event type is characterized by an intensity function, the jumps occurring in the population can be represented by restriction and projection of a Poisson measure defined on a larger state space. </span>
<span id="cb45-441"><a href="#cb45-441" aria-hidden="true" tabindex="-1"></a>More precisely, we introduce a random Poisson measure $Q$ on $\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+$, with $\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)$. $Q$ is composed of random quadruplets $(\tau, k , e, \theta)$, where $\tau$ represents a potential event time for an individual $I_k$ and event type $e$. </span>
<span id="cb45-442"><a href="#cb45-442" aria-hidden="true" tabindex="-1"></a>The last variable $\theta$ is used to accept/reject this proposed event, depending on the event intensity. Hence, the Poisson measure is restricted to a certain random set and then projected on the space of interest ${\mathbb{R}}^+ \times \mathcal{J}$. If the event is accepted, then a jump $\phi^e(\tau,I_k)$ occurs.</span>
<span id="cb45-443"><a href="#cb45-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-444"><a href="#cb45-444" aria-hidden="true" tabindex="-1"></a>::: {#thm-eq-Z} </span>
<span id="cb45-445"><a href="#cb45-445" aria-hidden="true" tabindex="-1"></a><span class="fu">## Pathwise representation</span></span>
<span id="cb45-446"><a href="#cb45-446" aria-hidden="true" tabindex="-1"></a>Let $T\in {\mathbb{R}}^+$ and $\mathcal{J}= \mathbb N \times(\mathcal E \cup \mathcal{E}_W)$. </span>
<span id="cb45-447"><a href="#cb45-447" aria-hidden="true" tabindex="-1"></a>Let $Q$ be a random Poisson measure on $\mathbb R^+ \times \mathcal{J}\times \mathbb{R}^+$, of intensity $\mathrm{d}t \delta_{\mathcal{J}}(\mathrm{d}k,\mathrm{d}e)  (\theta)\mathrm{d}\theta$, with $\delta_{\mathcal{J}}$ the counting measure on $\mathcal{J}$. </span>
<span id="cb45-448"><a href="#cb45-448" aria-hidden="true" tabindex="-1"></a>Finally, let $Q^{\mathcal P}$ be a random Poisson measure on $\mathbb R^+ \times \mathcal{P}  \times \mathbb{R}^+$, of intensity $\mathrm{d}t \delta_{\cal P}(\mathrm{d}e)\mathrm{d}\theta$, and $Z_0= \sum_{k=1}^{N_0} \delta_{I_k}$ an initial population.</span>
<span id="cb45-449"><a href="#cb45-449" aria-hidden="true" tabindex="-1"></a>Then, under @cnj-non-explosion</span>
<span id="cb45-450"><a href="#cb45-450" aria-hidden="true" tabindex="-1"></a>, there exists a unique</span>
<span id="cb45-451"><a href="#cb45-451" aria-hidden="true" tabindex="-1"></a>measure-valued population process $Z$, strong solution on the following</span>
<span id="cb45-452"><a href="#cb45-452" aria-hidden="true" tabindex="-1"></a>SDE driven by the Poisson measure $Q$: </span>
<span id="cb45-453"><a href="#cb45-453" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-454"><a href="#cb45-454" aria-hidden="true" tabindex="-1"></a>    \begin{aligned}</span>
<span id="cb45-455"><a href="#cb45-455" aria-hidden="true" tabindex="-1"></a>    Z_t = Z_0 &amp;+ \int_0^t \int_{ \mathcal{J}\times \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} }\mathbf{1}_{\{\theta \leq \lambda_s^e(I_k, Z_{s^-})<span class="sc">\}</span>} Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}\theta ) <span class="sc">\\</span></span>
<span id="cb45-456"><a href="#cb45-456" aria-hidden="true" tabindex="-1"></a>    &amp;+   \int_0^t \int_{\mathcal{P} \times \mathbb R^+}  \phi^e(s, I_{s^-}) \mathbf{1}_{<span class="sc">\{</span>\theta \leq \mu^e(s) <span class="sc">\}</span>} Q^{\mathcal{P}} (\mathrm{d}s ,\mathrm{d}e,  \mathrm{d}\theta),  \qquad \forall  0 \leq t \leq T,</span>
<span id="cb45-457"><a href="#cb45-457" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb45-458"><a href="#cb45-458" aria-hidden="true" tabindex="-1"></a>$$ {#eq-sde-eq-Z}</span>
<span id="cb45-459"><a href="#cb45-459" aria-hidden="true" tabindex="-1"></a>and where $I_{s^-}$ is an individual, chosen uniformly among alive individuals in the population $Z_{s^-}$.</span>
<span id="cb45-460"><a href="#cb45-460" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-461"><a href="#cb45-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-462"><a href="#cb45-462" aria-hidden="true" tabindex="-1"></a>The proof of @thm-eq-Z is detailed in the Appendix, @sec-prf-thm-eq-Z. Note that @eq-sde-eq-Z is an SDE describing the evolution of the IBM, the intensity of the events in the right hand side of the equation depending on the population process $Z$ itself. </span>
<span id="cb45-463"><a href="#cb45-463" aria-hidden="true" tabindex="-1"></a>The main idea of the proof of @thm-eq-Z is to use the non explosion property of @lem-non-explosion, and to write the r.h.s of @eq-sde-eq-Z as a sum of simple equations between two successive events, solved by induction.</span>
<span id="cb45-464"><a href="#cb45-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-465"><a href="#cb45-465" aria-hidden="true" tabindex="-1"></a>::: {#lem-non-explosion}</span>
<span id="cb45-466"><a href="#cb45-466" aria-hidden="true" tabindex="-1"></a>Let $Z$ be a solution of @eq-sde-eq-Z on ${\mathbb{R}}^+$, with $(T_n)_{n\geq 0}$ its jump times, $T_0 = 0$. If @cnj-non-explosion is satisfied, then</span>
<span id="cb45-467"><a href="#cb45-467" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-468"><a href="#cb45-468" aria-hidden="true" tabindex="-1"></a>    \lim_{n \to \infty} T_n = \infty, \quad {\mathbb{P}}\text{-a.s.}</span>
<span id="cb45-469"><a href="#cb45-469" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-470"><a href="#cb45-470" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-471"><a href="#cb45-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-472"><a href="#cb45-472" aria-hidden="true" tabindex="-1"></a>The proof of @lem-non-explosion, detailed in Appendix @sec-prf-lem-non-explosion is more technical and relies on a pathwise comparison result, generalizing those obtained in <span class="co">[</span><span class="ot">@KaaElK20</span><span class="co">]</span>. An alternative pathwise representation of the population process, inspired by the randomized @alg-randomized is given as well in @prp-randomized.</span>
<span id="cb45-473"><a href="#cb45-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-474"><a href="#cb45-474" aria-hidden="true" tabindex="-1"></a><span class="fu"># Population simulation {#sec-simulation}</span></span>
<span id="cb45-475"><a href="#cb45-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-476"><a href="#cb45-476" aria-hidden="true" tabindex="-1"></a>We now present the main algorithm for simulating the evolution of an IBM over $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$. The algorithm implemented in <span class="in">`IBMPopSim`</span> allows the exact simulation of @eq-sde-eq-Z, based on an acceptance/reject algorithm for simulating random times called *thinning*. The exact simulation of event times with this acceptance/reject procedure is closely related to the simulations of inhomogeneous Poisson processes by the so-called thinning algorithm, often attributed to @LewShe79. </span>
<span id="cb45-477"><a href="#cb45-477" aria-hidden="true" tabindex="-1"></a>The simulation methods for inhomogeneous Poisson processes can be adapted to IBMs, and we introduce in this section a general algorithm extending those by @FouMel04 (see also @FerTra09, @Ben10).</span>
<span id="cb45-478"><a href="#cb45-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-479"><a href="#cb45-479" aria-hidden="true" tabindex="-1"></a>It can be noted that under appropriate rescaling and when the population size goes to infinity, an IBM can be approximated by a non linear transport PDE, structured by age and trait. A central limit theorem can also be obtained under appropriate assumptions <span class="co">[</span><span class="ot">@tran_2008</span><span class="co">]</span>. In the presence of interactions as in @sec-example-interaction for instance, the IBM goes almost surely to extinction in finite time, which is not the case for the limit PDE. In this case, simulating the microscopic process can be quite useful for approximating the distribution of the extinction time. Other applications of IBM simulations can include the simulation of multiscale population evolution, strongly heterogeneous populations, or small populations with strong interactions. </span>
<span id="cb45-480"><a href="#cb45-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-481"><a href="#cb45-481" aria-hidden="true" tabindex="-1"></a>The algorithm is based on exponential "candidate" event times, chosen with a (constant) intensity which must be greater than the global event intensity $\Lambda_t(Z_t)$ (@eq-global-intensity). Starting from time $t$, once a candidate event time $t + \bar T_\ell$ has been proposed, a candidate event type $e$ (birth, death,<span class="sc">\.</span>..) is chosen with a probability $p^e$ depending on the event intensity bounds $\bar \mu^e$, $\bar \lambda^e$ and $\bar W^e$, as defined in @cnj-intensity1 and @cnj-intensity2. </span>
<span id="cb45-482"><a href="#cb45-482" aria-hidden="true" tabindex="-1"></a>An individual $I$ is then drawn from the population. </span>
<span id="cb45-483"><a href="#cb45-483" aria-hidden="true" tabindex="-1"></a>Finally, it remains to accept or reject the candidate event with a probability $q^e(t,I,Z_t)$ depending on the true event intensity. </span>
<span id="cb45-484"><a href="#cb45-484" aria-hidden="true" tabindex="-1"></a>If the candidate event time is accepted, then the event $e$ occurs at time $t + \bar T_\ell$ to the individual $I$. The main idea of the implemented algorithm can be summarized as follows:</span>
<span id="cb45-485"><a href="#cb45-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-486"><a href="#cb45-486" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Draw a candidate time $t + \bar T_\ell$ and candidate event type $e$.</span>
<span id="cb45-487"><a href="#cb45-487" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Draw a uniform variable $\theta \sim \mathcal{U}(<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>)$ and individual $I$.</span>
<span id="cb45-488"><a href="#cb45-488" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**If** $\theta \leq q^e(t,I,Z_t)$ **then** event $e$ occur to individual $I$, **else** Do nothing and start again from $t + \bar T_\ell$.</span>
<span id="cb45-489"><a href="#cb45-489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-490"><a href="#cb45-490" aria-hidden="true" tabindex="-1"></a>Before introducing the main algorithms in more details, we recall briefly the thinning procedure for simulating inhomogeneous Poisson processes, as well as the links with pathwise representations. Some recalls on Poisson random measures are presented in @sec-recall-poisson.</span>
<span id="cb45-491"><a href="#cb45-491" aria-hidden="true" tabindex="-1"></a>For a more general presentation of thinning of a Poisson random measure, see <span class="co">[</span><span class="ot">@Dev86; @Cin11; @Kal17</span><span class="co">]</span>.</span>
<span id="cb45-492"><a href="#cb45-492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-493"><a href="#cb45-493" aria-hidden="true" tabindex="-1"></a><span class="fu">## Thinning of Poisson measure {#sec-thinning}</span></span>
<span id="cb45-494"><a href="#cb45-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-495"><a href="#cb45-495" aria-hidden="true" tabindex="-1"></a>Let us start with the simulation and pathwise representation of an inhomogeneous Poisson process on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ with intensity $(\Lambda(t))_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$. The thinning procedure is based on the fundamental assumption that $\Lambda(t) \leq  \bar \Lambda$ is bounded on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$. In this case, the inhomogeneous Poisson can be obtained from an homogeneous Poisson process of intensity $\bar \Lambda$, which can be simulated easily.</span>
<span id="cb45-496"><a href="#cb45-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-497"><a href="#cb45-497" aria-hidden="true" tabindex="-1"></a>First, the Poisson process can be extended to a Marked Poisson measure $\bar Q:= \sum_{\ell \ge 1} \delta_{(\bar T_\ell, \bar \Theta_\ell)}$ on $(\mathbb{R}^+)^2$, defined as follow:</span>
<span id="cb45-498"><a href="#cb45-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-499"><a href="#cb45-499" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The jump times of $(\bar T_\ell)_{\ell \ge 1}$ of $\bar Q$ are the jump times of a Poisson process of intensity $\bar \Lambda$.</span>
<span id="cb45-500"><a href="#cb45-500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-501"><a href="#cb45-501" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The marks $(\bar \Theta_\ell)_{\ell \ge 1}$ are _i.i.d._ random variables, uniformly distributed on $<span class="co">[</span><span class="ot">0, \bar \Lambda</span><span class="co">]</span>$.</span>
<span id="cb45-502"><a href="#cb45-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-503"><a href="#cb45-503" aria-hidden="true" tabindex="-1"></a>By @prp-marked-poisson , $\bar{Q}$ is a Poisson random measure with mean measure</span>
<span id="cb45-504"><a href="#cb45-504" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-505"><a href="#cb45-505" aria-hidden="true" tabindex="-1"></a>    \bar \mu(\mathrm{d}t, \mathrm{d}\theta): = \bar \Lambda \mathrm{d}t</span>
<span id="cb45-506"><a href="#cb45-506" aria-hidden="true" tabindex="-1"></a>    \frac{\mathbf{1}_{[0, \bar \Lambda]}(\theta)}{\bar \Lambda} \mathrm{d}\theta= \mathrm{d}t  \mathbf{1}_{<span class="co">[</span><span class="ot">0, \bar \Lambda</span><span class="co">]</span>}(\theta) \mathrm{d}\theta.</span>
<span id="cb45-507"><a href="#cb45-507" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-508"><a href="#cb45-508" aria-hidden="true" tabindex="-1"></a>In particular, the average number of atoms $(\bar T_\ell, \bar \Theta_\ell)$ in $<span class="co">[</span><span class="ot">0,t</span><span class="co">]</span>\times <span class="co">[</span><span class="ot">0,h</span><span class="co">]</span>$ is</span>
<span id="cb45-509"><a href="#cb45-509" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-510"><a href="#cb45-510" aria-hidden="true" tabindex="-1"></a>    \mathbb{E}<span class="co">[</span><span class="ot">Q([0,t]\times [0,h])</span><span class="co">]</span>={\mathbb{E}}<span class="co">[</span><span class="ot">\sum_{\ell} \mathbf{1}_{[0,t]\times [0,h]} (\bar T_\ell, \bar \Theta_{\ell})</span><span class="co">]</span>  = \int_{(\mathbb{R}^+)^2}  \bar \mu(\mathrm{d}t, \mathrm{d}\theta)  = t (\bar \Lambda \wedge h).</span>
<span id="cb45-511"><a href="#cb45-511" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-512"><a href="#cb45-512" aria-hidden="true" tabindex="-1"></a>The thinning is based on the restriction property for Poisson measure: for a measurable set $\Delta\subset {\mathbb{R}}^+\times {\mathbb{R}}^+$, the restriction $Q^\Delta:= \mathbf{1}_{\Delta}\bar Q$ of $\bar Q$ to $\Delta$ (by taking only atoms in $\Delta$) is also a Poisson random measure of mean measure $\mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta)  = \mathbf{1}_{\Delta}(t,\theta) \bar \mu(\mathrm{d}t, \mathrm{d}\theta).$</span>
<span id="cb45-513"><a href="#cb45-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-514"><a href="#cb45-514" aria-hidden="true" tabindex="-1"></a>In order to obtain an inhomogeneous Poisson measure of intensity $(\Lambda(t))$, the "good" choice of $\Delta$ is the hypograph of $\Lambda$:</span>
<span id="cb45-515"><a href="#cb45-515" aria-hidden="true" tabindex="-1"></a>$\Delta =<span class="sc">\{</span> (t,\theta) \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>\times <span class="co">[</span><span class="ot">0,\bar \Lambda</span><span class="co">]</span> ; \; \theta \leq \Lambda(t)<span class="sc">\}</span>$ </span>
<span id="cb45-516"><a href="#cb45-516" aria-hidden="true" tabindex="-1"></a>(see @fig-thinning). Then, </span>
<span id="cb45-517"><a href="#cb45-517" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-518"><a href="#cb45-518" aria-hidden="true" tabindex="-1"></a>    Q^\Delta = \sum_{\ell \ge 1} \mathbf{1}_{\left\{\bar \Theta_\ell \le \Lambda(\bar T_\ell)\right\}} \delta_{(\bar T_\ell, \bar \Theta_\ell)},</span>
<span id="cb45-519"><a href="#cb45-519" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb45-520"><a href="#cb45-520" aria-hidden="true" tabindex="-1"></a>and since $\Lambda(t) \leq \bar \Lambda$, on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$:</span>
<span id="cb45-521"><a href="#cb45-521" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-522"><a href="#cb45-522" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb45-523"><a href="#cb45-523" aria-hidden="true" tabindex="-1"></a>    \mu^{\Delta}(\mathrm{d}t, \mathrm{d}\theta) &amp; = \mathbf{1}_{<span class="sc">\{</span> \theta \leq \Lambda(t)<span class="sc">\}</span>}  \mathrm{d}t</span>
<span id="cb45-524"><a href="#cb45-524" aria-hidden="true" tabindex="-1"></a>\mathbf{1}_{[0, \bar \Lambda]}(\theta)\mathrm{d}\theta = \mathbf{1}_{<span class="sc">\{</span>\theta \leq \Lambda(t)<span class="sc">\}</span>} \mathrm{d}t \mathrm{d}\theta.</span>
<span id="cb45-525"><a href="#cb45-525" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb45-526"><a href="#cb45-526" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-527"><a href="#cb45-527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-528"><a href="#cb45-528" aria-hidden="true" tabindex="-1"></a>!<span class="co">[</span><span class="ot">Realization of a Marked Poisson measure $\bar Q$ on $[0,T]$ with mean measure $\bar \mu(\mathrm{d} t, \mathrm{d} \theta) = \mathrm{d} t \mathbf{1}_{[0, \bar \Lambda]}(\theta) \mathrm{d} \theta$ (red crosses), and realization of the restriction $\bar Q^\Delta$ where $\Delta = \{ (t,\theta)\in [0,T]\times[0, \bar \Lambda], \theta \leq \Lambda(t) \}$ (blue circles). The projection of $\bar Q^\Delta$ on first component is an inhomogeneous Poisson process on $[0,T]$ of intensity $(\Lambda(t))$ and jump times $(T_k)_{k \ge 1}$.</span><span class="co">](img/plot_thinning.tex)</span>{#fig-thinning}</span>
<span id="cb45-529"><a href="#cb45-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-530"><a href="#cb45-530" aria-hidden="true" tabindex="-1"></a>Finally, the inhomogeneous Poisson process is obtained by the projection @prp-proj-poisson-measure, which states that the jump times of $Q^\Delta$ are the jump times of an inhomogeneous Poisson process of intensity $(\Lambda(t))$.</span>
<span id="cb45-531"><a href="#cb45-531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-532"><a href="#cb45-532" aria-hidden="true" tabindex="-1"></a>::: {#prp-thinning}</span>
<span id="cb45-533"><a href="#cb45-533" aria-hidden="true" tabindex="-1"></a>The counting process $N^\Lambda$, projection of $Q^{\Delta}$ on the time component and defined by,</span>
<span id="cb45-534"><a href="#cb45-534" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-535"><a href="#cb45-535" aria-hidden="true" tabindex="-1"></a>    N^{\Lambda}_t := Q^{\Delta}( [0,t] \times {\mathbb{R}}^+) = \int_0^t \int_{{\mathbb{R}}^+} \mathbf{1}_{\{\theta \leq \Lambda(s)\}} \bar Q(\mathrm{d}s, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathbf{1}_{\{ \bar T_\ell \leq t \}} \mathbf{1}_{\{\bar \Theta_\ell \leq  \Lambda(\bar T_\ell) <span class="sc">\}</span>},  \quad \forall t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>,</span>
<span id="cb45-536"><a href="#cb45-536" aria-hidden="true" tabindex="-1"></a>$$ {#eq-thinning-inhomogeneous-poisson}</span>
<span id="cb45-537"><a href="#cb45-537" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ of intensity function $(\Lambda(t))_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$. The thinning @eq-thinning-inhomogeneous-poisson is a pathwise representation of $N^\Lambda$ by *restriction and projection* of the Poisson measure $Q$ on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.</span>
<span id="cb45-538"><a href="#cb45-538" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-539"><a href="#cb45-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-540"><a href="#cb45-540" aria-hidden="true" tabindex="-1"></a>The previous proposition yields a straightforward thinning algorithm to simulate the jump times $(T_k)_{k \ge 1}$ of an inhomogeneous Poisson process of intensity $\Lambda(t)$, by selecting jump times $\bar T_\ell$ such that $\bar \Theta_\ell \le \Lambda(\bar T_\ell)$.</span>
<span id="cb45-541"><a href="#cb45-541" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-542"><a href="#cb45-542" aria-hidden="true" tabindex="-1"></a><span class="fu">### Multivariate Poisson process {#sec-vector}</span></span>
<span id="cb45-543"><a href="#cb45-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-544"><a href="#cb45-544" aria-hidden="true" tabindex="-1"></a>This can be extended to the simulation of multivariate inhomogeneous Poisson processes, which is an important example before tackling the simulation of an IBM.</span>
<span id="cb45-545"><a href="#cb45-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-546"><a href="#cb45-546" aria-hidden="true" tabindex="-1"></a>Let $(N^j)_{j \in \mathcal{J}}$ be a (inhomogeneous) multivariate Poisson process indexed by a finite set $\mathcal{J}$, such that $\forall j \in \mathcal{J}$, the intensity $(\lambda_j(t))_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$ of $N_j$ is bounded on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$:</span>
<span id="cb45-547"><a href="#cb45-547" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-548"><a href="#cb45-548" aria-hidden="true" tabindex="-1"></a>    \sup_{t\in<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>} \lambda_j(t) \le \bar \lambda_j, \text{ and let }</span>
<span id="cb45-549"><a href="#cb45-549" aria-hidden="true" tabindex="-1"></a>    \bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j.</span>
<span id="cb45-550"><a href="#cb45-550" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb45-551"><a href="#cb45-551" aria-hidden="true" tabindex="-1"></a>Recall that such multivariate counting process can be rewritten as a Poisson random measure $N= \sum_{k\geq 1} \delta_{(T_k,J_k)}$ on ${\mathbb{R}}^+\times \mathcal{J}$ (see e.g. Sec. 2 of Chapter 6 in&nbsp;<span class="co">[</span><span class="ot">@Cin11</span><span class="co">]</span>), where $T_k$ is $k$th jump time of $\sum_{j\in \mathcal{J}} N^j$ and $J_k$ corresponds to the component of the the vector which jumps. In particular, $N^j_t = N(<span class="co">[</span><span class="ot">0,t</span><span class="co">]</span>\times <span class="sc">\{</span>j<span class="sc">\}</span>)$.</span>
<span id="cb45-552"><a href="#cb45-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-553"><a href="#cb45-553" aria-hidden="true" tabindex="-1"></a>Once again the simulation of such process can be obtained from the simulation of a (homogeneous) multivariate Poisson process of intensity vector $(\bar{\lambda}_j)_{j \in \mathcal{J}}$, extended into a Poisson measures by adding marks on ${\mathbb{R}}^+$. </span>
<span id="cb45-554"><a href="#cb45-554" aria-hidden="true" tabindex="-1"></a>Thus, we introduce the Marked Poisson measure $\bar Q = \sum \delta_{(\bar T_\ell, \bar J_\ell, \bar \Theta_\ell)}$ on ${\mathbb{R}}^+  \times \mathcal{J}\times {\mathbb{R}}^+$, such that:</span>
<span id="cb45-555"><a href="#cb45-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-556"><a href="#cb45-556" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The jump times $(\bar T_\ell)$ of $\bar Q$ are the jump times of a Poisson measure of intensity $\bar \Lambda$.</span>
<span id="cb45-557"><a href="#cb45-557" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The variables $(\bar J_\ell)$ are *i.i.d.* random variables on $\mathcal{J}$, with $\displaystyle p_j= {\mathbb{P}}(\bar J_1 = j)= \bar \lambda_j/\bar \Lambda$ and representing the component of the vector which jumps.</span>
<span id="cb45-558"><a href="#cb45-558" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>The marks $(\bar \Theta_\ell)$ are independent variables with $\bar \Theta_\ell$ a uniform random variable on $[0,\bar \lambda_{{\bar J}_\ell}]$, $\forall \ell \geq 1$.</span>
<span id="cb45-559"><a href="#cb45-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-560"><a href="#cb45-560" aria-hidden="true" tabindex="-1"></a>By @prp-marked-poisson and @prp-proj-poisson-measure, each measure $\bar Q_j (\mathrm{d}t, \mathrm{d}\theta) = \bar Q(\mathrm{d}t, <span class="sc">\{</span>j<span class="sc">\}</span>, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathbf{1}_{\{\bar J_\ell=j \}} \delta_{(\bar T_\ell, \bar \Theta_\ell)}$ is a marked Poisson measure of intensity</span>
<span id="cb45-561"><a href="#cb45-561" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-562"><a href="#cb45-562" aria-hidden="true" tabindex="-1"></a>    \bar \mu_j ( \mathrm{d}t  ,\mathrm{d}\theta) = \bar{\Lambda}p_j \mathrm{d}t  \frac{\mathbf{1}_{\{\theta \leq \bar \lambda_{j}\}}(\theta)}{\bar \lambda_{j}} \mathrm{d}\theta = \mathrm{d}t  \mathbf{1}_{\{\theta \leq \bar \lambda_{j}<span class="sc">\}</span>}(\theta) \mathrm{d}\theta.</span>
<span id="cb45-563"><a href="#cb45-563" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-564"><a href="#cb45-564" aria-hidden="true" tabindex="-1"></a>As a direct application of @prp-thinning , the inhomogeneous multivariate Poisson process is obtained by restriction of each measures $\bar Q_j$ to $\Delta_j = <span class="sc">\{</span> (t, \theta) \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span> \times <span class="co">[</span><span class="ot">0,\bar \lambda_j</span><span class="co">]</span> ;\; \theta \leq \lambda_j(t) <span class="sc">\}</span>$ and projection.</span>
<span id="cb45-565"><a href="#cb45-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-566"><a href="#cb45-566" aria-hidden="true" tabindex="-1"></a>::: {#prp-thinning-vector}</span>
<span id="cb45-567"><a href="#cb45-567" aria-hidden="true" tabindex="-1"></a>The multivariate counting process $(N^j)_{j \in \mathcal{J}}$, defined for all $j \in \mathcal{J}$ and $t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ by thinning and projection of $\bar Q$:</span>
<span id="cb45-568"><a href="#cb45-568" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-569"><a href="#cb45-569" aria-hidden="true" tabindex="-1"></a>    N^j_t  := \int_0^t \int_{ {\mathbb{R}}^+} \mathbf{1}_{\{\theta \leq \lambda_j(s)\}} \bar{Q}(\mathrm{d}s, \{j\}, \mathrm{d}\theta) = \sum_{\ell \geq 1} \mathbf{1}_{\{ \bar T_\ell \leq t \}}\mathbf{1}_{\{\bar J_\ell = j\}} \mathbf{1}_{\{\bar \Theta_\ell \leq  \lambda_j (\bar T_\ell ) <span class="sc">\}</span>},</span>
<span id="cb45-570"><a href="#cb45-570" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-571"><a href="#cb45-571" aria-hidden="true" tabindex="-1"></a>is an inhomogeneous Poisson process of intensity vector $(\lambda_j(t))_{j\in\mathcal{J}}$ on $<span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$.</span>
<span id="cb45-572"><a href="#cb45-572" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-573"><a href="#cb45-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-574"><a href="#cb45-574" aria-hidden="true" tabindex="-1"></a>@prp-thinning-vector yields the following simulation @alg-thinning2 for multivariate Poisson processes.</span>
<span id="cb45-575"><a href="#cb45-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-576"><a href="#cb45-576" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb45-577"><a href="#cb45-577" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-thinning2</span></span>
<span id="cb45-578"><a href="#cb45-578" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb45-579"><a href="#cb45-579" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb45-580"><a href="#cb45-580" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb45-581"><a href="#cb45-581" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb45-582"><a href="#cb45-582" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb45-583"><a href="#cb45-583" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb45-584"><a href="#cb45-584" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb45-585"><a href="#cb45-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-586"><a href="#cb45-586" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb45-587"><a href="#cb45-587" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Thinning algorithm for multivariate inhomogeneous Poisson processes.}</span></span>
<span id="cb45-588"><a href="#cb45-588" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb45-589"><a href="#cb45-589" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Input:} Functions and bounds $(\lambda_j, \bar \lambda_j)$, $\lambda_j: [0,T] \to [0,\bar \lambda_j]$ and $\bar \Lambda = \sum_{j \in \mathcal{J}} \bar \lambda_j$</span></span>
<span id="cb45-590"><a href="#cb45-590" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Output:} Points $(T_k, J_k)$ of Poisson measure $N$ on $[0,T] \times \mathcal{J}$</span></span>
<span id="cb45-591"><a href="#cb45-591" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$</span></span>
<span id="cb45-592"><a href="#cb45-592" aria-hidden="true" tabindex="-1"></a><span class="in">    \While{$T_k &lt; T$}</span></span>
<span id="cb45-593"><a href="#cb45-593" aria-hidden="true" tabindex="-1"></a><span class="in">        \Repeat</span></span>
<span id="cb45-594"><a href="#cb45-594" aria-hidden="true" tabindex="-1"></a><span class="in">            \State increment iterative variable $\ell \longleftarrow \ell+1$</span></span>
<span id="cb45-595"><a href="#cb45-595" aria-hidden="true" tabindex="-1"></a><span class="in">            \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + S_\ell$  with $S_\ell \sim \mathcal{E}(\bar \Lambda)$ </span></span>
<span id="cb45-596"><a href="#cb45-596" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw $\bar J_\ell \sim \mathcal{U}\big\{ \bar \lambda_j / \bar \Lambda, j \in \mathcal{J} \big\}$ i.e. $\mathbb{P}(\bar J_\ell = j) = \bar \lambda_j / \bar \Lambda$</span></span>
<span id="cb45-597"><a href="#cb45-597" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw $\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda_{\bar J_\ell}])$</span></span>
<span id="cb45-598"><a href="#cb45-598" aria-hidden="true" tabindex="-1"></a><span class="in">        \Until{accepted event $\bar \Theta_\ell \le \lambda_{\bar J_\ell}(\bar T_{\ell})$} </span></span>
<span id="cb45-599"><a href="#cb45-599" aria-hidden="true" tabindex="-1"></a><span class="in">        \State record $(T_k, J_k) \longleftarrow (\bar T_{\ell}, \bar J_\ell)$ as accepted point</span></span>
<span id="cb45-600"><a href="#cb45-600" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndWhile</span></span>
<span id="cb45-601"><a href="#cb45-601" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb45-602"><a href="#cb45-602" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb45-603"><a href="#cb45-603" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-604"><a href="#cb45-604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-605"><a href="#cb45-605" aria-hidden="true" tabindex="-1"></a>::: {#rem-alternate-thinning}</span>
<span id="cb45-606"><a href="#cb45-606" aria-hidden="true" tabindex="-1"></a>The acceptance/rejection @alg-thinning2 can be efficient when the functions $\lambda_j$ are of different order, and thus bounded by different $\bar \lambda_j$. However, it is important to note that the simulation of the discrete random variables $(\bar J_\ell)$ can be costly (compared to a uniform law) when $\mathcal{J}$ is large, for instance when an individual is drawn from a large population. In this case, an alternative is to choose the same bound $\bar \lambda_j= \bar \lambda$ for all $j \in \mathcal{J}$. Then the marks $(\bar J_\ell, \bar \Theta_\ell)$ are *i.i.d.* uniform variables on $\mathcal{J}\times <span class="co">[</span><span class="ot">0,\bar \lambda</span><span class="co">]</span>$, faster to simulate.</span>
<span id="cb45-607"><a href="#cb45-607" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-608"><a href="#cb45-608" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-609"><a href="#cb45-609" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simulation algorithm {#sec-simulation-algo}</span></span>
<span id="cb45-610"><a href="#cb45-610" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-611"><a href="#cb45-611" aria-hidden="true" tabindex="-1"></a>Let us now come back to the simulation of the IBM introduced in @sec-overview. For ease of notations, we assume that there are no event with Poisson intensity ($\mathcal{P} =\emptyset$), so that all events that occur are of type $e \in \mathcal{E} \cup \mathcal{E}_W$, with individual intensity $\lambda_t^e(I,Z_t)$ depending on the population composition $Z_t$ ($e \in \mathcal{E}_W$) or not ($e \in \mathcal{E}$), as defined in @eq-individual-intensity and verifying either @cnj-intensity1 or @cnj-intensity2.</span>
<span id="cb45-612"><a href="#cb45-612" aria-hidden="true" tabindex="-1"></a>The global intensity @eq-global-ev-intensity at time $t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>$ is thus</span>
<span id="cb45-613"><a href="#cb45-613" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-614"><a href="#cb45-614" aria-hidden="true" tabindex="-1"></a>    \Lambda_t(Z_t) = \sum_{e \in \mathcal{E}} \Big( \sum_{k=1}^{N_t} \lambda^e(t, I_k) \Big)</span>
<span id="cb45-615"><a href="#cb45-615" aria-hidden="true" tabindex="-1"></a><span class="ss">    + </span>\sum_{e \in \mathcal{E}_W} \Big( \sum_{k=1}^{N_t} \sum_{j=1}^{N_t} W^e(t, I_k, I_j) \Big) \leq \bar \Lambda(N_t),</span>
<span id="cb45-616"><a href="#cb45-616" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-intensity}</span>
<span id="cb45-617"><a href="#cb45-617" aria-hidden="true" tabindex="-1"></a>with</span>
<span id="cb45-618"><a href="#cb45-618" aria-hidden="true" tabindex="-1"></a>$\bar \Lambda(n) = \big(\sum_{e \in \mathcal{E}} \bar \lambda^e \big) n + \big( \sum_{e \in \mathcal{E}_W} \bar W^e \big) n^2$.</span>
<span id="cb45-619"><a href="#cb45-619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-620"><a href="#cb45-620" aria-hidden="true" tabindex="-1"></a>One of the main difficulty is that the intensity of events is not deterministic as in the case of inhomogeneous Poisson processes, but a function $\Lambda_t(Z_t)$ of the population state, bounded by a function which also depends on the population size. However, the @alg-thinning2 can be adapted to simulate the IBM. The construction is done by induction, by conditioning on the state of the population $Z_{T_k}$ at the $k$th event time $T_k$ ($T_0 = 0$).</span>
<span id="cb45-621"><a href="#cb45-621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-622"><a href="#cb45-622" aria-hidden="true" tabindex="-1"></a>We first present the construction of the first event at time $T_1$.</span>
<span id="cb45-623"><a href="#cb45-623" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-624"><a href="#cb45-624" aria-hidden="true" tabindex="-1"></a><span class="fu">### First event simulation {.unnumbered}</span></span>
<span id="cb45-625"><a href="#cb45-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-626"><a href="#cb45-626" aria-hidden="true" tabindex="-1"></a>Before the first event time, on $<span class="sc">\{</span> t &lt; T_1 <span class="sc">\}</span>$, the population composition is constant : $Z_t = Z_0 = <span class="sc">\{</span> I_1, \dots, I_{N_0}<span class="sc">\}</span>$. For each type of event $e$ and individual $I_k$, $k \in <span class="sc">\{</span>1,\dots N_0<span class="sc">\}</span>$, we denote by $N^{k,e}$ the counting process of intensity $\lambda_t^e (I_k,Z_t)$, counting the occurrences of the events of type $e$ happening to the individual $I_k$. Then, the first event $T_1$ is the first jump time of the multivariate counting vector $(N^{(k,e)})_{ (k,e) \in \mathcal{J}_0}$, with $\mathcal{J}_0 = <span class="sc">\{</span>1,\dots , N_0<span class="sc">\}</span>\times \big(\mathcal{E} \cup \mathcal{E}_W \big)$.</span>
<span id="cb45-627"><a href="#cb45-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-628"><a href="#cb45-628" aria-hidden="true" tabindex="-1"></a>Since the population composition is constant before the first event time, each counting process $N^{j}$ with $j=(k,e) \in \mathcal{J}_0$ coincides on $[0,T_1[$ with an inhomogeneous Poisson process, of intensity $\lambda_t^e (I_k,Z_0)$. Thus (conditionally to $Z_0$), $T_1$ is also the first jump time of an inhomogeneous multivariate Poisson process $N^0 = (N^{0,j})_{j \in \mathcal{J}_0}$ of intensity function $(\lambda_j)_{j\in \mathcal J_0}$, defined for all $j = (k,e) \in \mathcal{J}_0$ by:</span>
<span id="cb45-629"><a href="#cb45-629" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-630"><a href="#cb45-630" aria-hidden="true" tabindex="-1"></a>    \lambda_j(t) = \lambda^e_t(I_k,Z_0) \le \bar \lambda^e_0 \quad \text{with} \quad \bar \lambda^e_0 = \bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_0 \mathbf{1}_{e \in \mathcal{E}_W},</span>
<span id="cb45-631"><a href="#cb45-631" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-632"><a href="#cb45-632" aria-hidden="true" tabindex="-1"></a>by @cnj-intensity1 and @cnj-intensity2. In particular, the jump times of $N^0$ occur at the intensity</span>
<span id="cb45-633"><a href="#cb45-633" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-634"><a href="#cb45-634" aria-hidden="true" tabindex="-1"></a>    \Lambda(t) =\sum_{j \in \mathcal{J}_0} \lambda_j(t)  =\sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \sum_{k=1}^{N_0}  \lambda^e_t(I_k,Z_0) \leq \bar \Lambda(N_0)=N_0 \sum_{e \in \mathcal{E} \cup \mathcal{E}_W} \bar \lambda^e_0.</span>
<span id="cb45-635"><a href="#cb45-635" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-636"><a href="#cb45-636" aria-hidden="true" tabindex="-1"></a>By @prp-thinning-vector, $N^0$ can be obtained by thinning of the marked Poisson measure $\bar Q^0 = \sum_{\ell \geq 1} \delta_{(\bar T_\ell , (\bar{K}_\ell, \bar E_\ell), \bar \Theta_\ell)}$ on ${\mathbb{R}}^+\times\mathcal{J}_0 \times {\mathbb{R}}^+$, with:</span>
<span id="cb45-637"><a href="#cb45-637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-638"><a href="#cb45-638" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(\bar T_\ell)_{\ell \in {\mathbb{N}}^*}$ the jump times of a Poisson process of rate $\bar \Lambda(N_0)$.</span>
<span id="cb45-639"><a href="#cb45-639" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(\bar{K}_\ell, \bar E_\ell)_{\ell \in {\mathbb{N}}^*}$ discrete *i.i.d.* random variables on $\mathcal{J}_0 = \{1,\dots , N_0\}\times \big(\mathcal{E} \cup \mathcal{E}_W \big)$, with $K_\ell$ representing the index of the chosen individual and $E_\ell$ the event type for the proposed event, such that:</span>
<span id="cb45-640"><a href="#cb45-640" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-641"><a href="#cb45-641" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}( \bar  K_1 = k, \bar E_1 = e) </span>
<span id="cb45-642"><a href="#cb45-642" aria-hidden="true" tabindex="-1"></a>    = \frac{\bar \lambda^e_0 }{\bar \Lambda(N_0)}</span>
<span id="cb45-643"><a href="#cb45-643" aria-hidden="true" tabindex="-1"></a>    = \frac{1}{N_0} \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)},</span>
<span id="cb45-644"><a href="#cb45-644" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-645"><a href="#cb45-645" aria-hidden="true" tabindex="-1"></a>i.e. $(\bar K_1, \bar E_1)$ are distributed as independent random variables where $\bar K_1 \sim \mathcal U(<span class="sc">\{</span>1,\dots, N_0<span class="sc">\}</span>)$ and $\bar E_1$ such that </span>
<span id="cb45-646"><a href="#cb45-646" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-647"><a href="#cb45-647" aria-hidden="true" tabindex="-1"></a>    p_e := \mathbb{P}( \bar E_1 = e)</span>
<span id="cb45-648"><a href="#cb45-648" aria-hidden="true" tabindex="-1"></a>        = \frac{\bar \lambda^e_0 N_0}{\bar \Lambda(N_0)}.</span>
<span id="cb45-649"><a href="#cb45-649" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-650"><a href="#cb45-650" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$(\bar \Theta_\ell)_{\ell \in {\mathbb{N}}^*}$ are independent uniform random variables, with $\bar \Theta_\ell \sim \mathcal{U}([0,\bar \lambda^{\bar E_\ell}]).$</span>
<span id="cb45-651"><a href="#cb45-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-652"><a href="#cb45-652" aria-hidden="true" tabindex="-1"></a>Since the first event is the first jump of $N^0$, by @prp-thinning-vector and @alg-thinning2, the first event time $T_1$ is the first jump time $\bar T_\ell$ of $\bar Q^0$ such that $\bar \Theta_\ell \leq \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell}, Z_0)$.</span>
<span id="cb45-653"><a href="#cb45-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-654"><a href="#cb45-654" aria-hidden="true" tabindex="-1"></a>At $T_1 =\bar T_{\ell}$, the event $\bar E_\ell$ occurs to the individual $I_{\bar K_\ell} = (\tau^b, \infty, x)$. For instance, if $\bar E_\ell =d$, a death/exit event occurs, so that $Z_{T_1} = Z_{0} + \delta_{(\tau^b, T_1, x)} - \delta_{I_{\bar K_\ell}}$ and $N_{T_1} = N_{0}$. If $\bar E_\ell =b$ or $en$, a birth or entry event occurs, so that $N_{T_1} = N_{0} + 1$, and a new individual $I_{N_0+1}$ is added to the population, chosen as described in @tbl-event-action. </span>
<span id="cb45-655"><a href="#cb45-655" aria-hidden="true" tabindex="-1"></a>Finally, if $\bar E_\ell=s$, a swap event occurs, the population size stays constant and $I_{\bar K_\ell}$ is replaced by an individual $I_{\bar K_\ell}'$, chosen as described in @tbl-event-action.</span>
<span id="cb45-656"><a href="#cb45-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-657"><a href="#cb45-657" aria-hidden="true" tabindex="-1"></a>The steps for simulating the first event in the population can be iterated in order to simulate the population. At the $k$th step, the same procedure is repeated to simulate the $k$th event, starting from a population $Z_{T_{k-1}}$ of size $N_{T_{k-1}}$. The algorithm is summarized in @alg-interaction.</span>
<span id="cb45-658"><a href="#cb45-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-659"><a href="#cb45-659" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb45-660"><a href="#cb45-660" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-interaction</span></span>
<span id="cb45-661"><a href="#cb45-661" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb45-662"><a href="#cb45-662" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb45-663"><a href="#cb45-663" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb45-664"><a href="#cb45-664" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb45-665"><a href="#cb45-665" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb45-666"><a href="#cb45-666" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb45-667"><a href="#cb45-667" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb45-668"><a href="#cb45-668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-669"><a href="#cb45-669" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb45-670"><a href="#cb45-670" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{IBM simulation algorithm (without events of Poissonian intensity)}</span></span>
<span id="cb45-671"><a href="#cb45-671" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb45-672"><a href="#cb45-672" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by:</span></span>
<span id="cb45-673"><a href="#cb45-673" aria-hidden="true" tabindex="-1"></a><span class="in">        \State - Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$ and $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ </span></span>
<span id="cb45-674"><a href="#cb45-674" aria-hidden="true" tabindex="-1"></a><span class="in">        \State - Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W$ </span></span>
<span id="cb45-675"><a href="#cb45-675" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Output:} Population $Z_T$</span></span>
<span id="cb45-676"><a href="#cb45-676" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$</span></span>
<span id="cb45-677"><a href="#cb45-677" aria-hidden="true" tabindex="-1"></a><span class="in">    \While{$T_k &lt; T$}</span></span>
<span id="cb45-678"><a href="#cb45-678" aria-hidden="true" tabindex="-1"></a><span class="in">        \Repeat</span></span>
<span id="cb45-679"><a href="#cb45-679" aria-hidden="true" tabindex="-1"></a><span class="in">            \State increment iterative variable $\ell \longleftarrow \ell+1$</span></span>
<span id="cb45-680"><a href="#cb45-680" aria-hidden="true" tabindex="-1"></a><span class="in">            \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$</span></span>
<span id="cb45-681"><a href="#cb45-681" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + \bar W^e N_{T_k} \mathbf{1}_{e \in \mathcal{E}_W}}{\sum_{e \in \mathcal{E}} \bar \lambda^e + \sum_{e \in \mathcal{E}_W} \bar W^e N_{T_k}}$</span></span>
<span id="cb45-682"><a href="#cb45-682" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$ </span></span>
<span id="cb45-683"><a href="#cb45-683" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw $\bar \Theta_\ell \sim \mathcal{U}([0, \bar \lambda^{\bar E_\ell}])$ if $\bar E_\ell \in \mathcal{E}$ or $\bar \Theta_\ell \sim \mathcal{U}([0, \bar W^{\bar E_\ell} N_{T_k}])$ if $\bar E_\ell \in \mathcal{E}_W$</span></span>
<span id="cb45-684"><a href="#cb45-684" aria-hidden="true" tabindex="-1"></a><span class="in">        \Until{accepted event $\bar \Theta_\ell \le \lambda^{\bar E_\ell}_{\bar T_\ell}(I_{\bar K_\ell},Z_{T_{k}})$}</span></span>
<span id="cb45-685"><a href="#cb45-685" aria-hidden="true" tabindex="-1"></a><span class="in">        \State increment iterative variable $k \longleftarrow k+1$ </span></span>
<span id="cb45-686"><a href="#cb45-686" aria-hidden="true" tabindex="-1"></a><span class="in">        \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell,  I_{\bar K_\ell})$ as accepted time, event and individual</span></span>
<span id="cb45-687"><a href="#cb45-687" aria-hidden="true" tabindex="-1"></a><span class="in">        \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$</span></span>
<span id="cb45-688"><a href="#cb45-688" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndWhile</span></span>
<span id="cb45-689"><a href="#cb45-689" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb45-690"><a href="#cb45-690" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb45-691"><a href="#cb45-691" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-692"><a href="#cb45-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-693"><a href="#cb45-693" aria-hidden="true" tabindex="-1"></a>::: {#thm-interaction}</span>
<span id="cb45-694"><a href="#cb45-694" aria-hidden="true" tabindex="-1"></a>A population process $(Z_t)_{t \in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$ simulated by the @alg-interaction is an exact solution of the SDE @eq-sde-eq-Z.</span>
<span id="cb45-695"><a href="#cb45-695" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-696"><a href="#cb45-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-697"><a href="#cb45-697" aria-hidden="true" tabindex="-1"></a>The proof of @thm-interaction is detailed in the Appendix @sec-prf-thm-interaction.</span>
<span id="cb45-698"><a href="#cb45-698" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-699"><a href="#cb45-699" aria-hidden="true" tabindex="-1"></a>::: {#rem-remvoval-dead} </span>
<span id="cb45-700"><a href="#cb45-700" aria-hidden="true" tabindex="-1"></a>The population $Z_{T_k}$ includes dead/exited individuals before the event time $T_k$. Thus, $N_{T_k} &gt; N_{T_k}^a$ is greater than the number of alive individuals at time $T_k$. When a dead individual $I_{\bar K_l}$ is drawn from the population during the rejection/acceptance phase of the algorithm, the proposed event $(\bar T_{\ell}, \bar E_\ell,  I_{\bar K_\ell})$ is automatically rejected since the event intensity is $\lambda^{\bar E_\ell}_{T_\ell}(I_{\bar K_\ell}, Z_{T_k}) = 0$ (nothing can happen to a dead individual). </span>
<span id="cb45-701"><a href="#cb45-701" aria-hidden="true" tabindex="-1"></a>This can slow down the algorithm, especially when the proportion of dead/exited individuals in the population increases. However, the computational cost of keeping dead/exited individuals in the population is much lower than the cost of removing an individual from the population at each death/exit event, which is linear in the population size.</span>
<span id="cb45-702"><a href="#cb45-702" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-703"><a href="#cb45-703" aria-hidden="true" tabindex="-1"></a>Actually, dead/exited individuals are regularly removed from the population in the <span class="in">`IBMPopSim`</span> algorithm, in order to optimize the trade-off between having to many dead individuals and removing dead individuals from the population too often. The frequency at which dead individuals are "removed from the population" can be chosen by the user, as an optional argument of the main function <span class="in">`popsim`</span> (see details in @sec-simulation). </span>
<span id="cb45-704"><a href="#cb45-704" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-705"><a href="#cb45-705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-706"><a href="#cb45-706" aria-hidden="true" tabindex="-1"></a>::: {#rem-sharp-bounds}</span>
<span id="cb45-707"><a href="#cb45-707" aria-hidden="true" tabindex="-1"></a>In practice, the bounds $\bar \lambda^e$ and $\bar W^e$ should be chosen as sharp as possible. It is easy to see that conditionally to $<span class="sc">\{</span>\bar E_\ell = e, \bar T_\ell = t, \bar K_\ell = l <span class="sc">\}</span>$ the probability of accepting the event is, depending if there are interactions,</span>
<span id="cb45-708"><a href="#cb45-708" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-709"><a href="#cb45-709" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}\big(\bar \Theta_\ell \le \lambda^e_t(I_l,Z_{T_k})| \mathcal{F}_{T_k}\big)</span>
<span id="cb45-710"><a href="#cb45-710" aria-hidden="true" tabindex="-1"></a>    = \frac{\lambda^e(t, I_l)}{\bar \lambda^e} \mathbf{1}_{e \in \mathcal{E}} +  \frac{\sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j)}{\bar W^e N_{T_k}} \mathbf{1}_{e \in \mathcal{E}_W}.</span>
<span id="cb45-711"><a href="#cb45-711" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-712"><a href="#cb45-712" aria-hidden="true" tabindex="-1"></a>The sharper the bounds $\bar \lambda^e$ and $\bar W^e$ are, the higher is the acceptance rate. For even sharper bounds, an alternative is to define bounds $\bar \lambda^e(I_l)$ and $\bar W^e(I_l)$ depending on the individuals' characteristics. However, the algorithm is modified and the individual $I_l$ is not chosen uniformly in the population anymore. Due to the population size, this is way more costly than choosing uniform bounds, as explained in @rem-alternate-thinning.</span>
<span id="cb45-713"><a href="#cb45-713" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-714"><a href="#cb45-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-715"><a href="#cb45-715" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simulation algorithm with randomization {#sec-simulation-randomized}</span></span>
<span id="cb45-716"><a href="#cb45-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-717"><a href="#cb45-717" aria-hidden="true" tabindex="-1"></a>Let $e \in \cal E_W$ be an event with interactions. In order to evaluate the individual intensity $\lambda^e_t (I,Z_t) = \sum_{j=1}^{N_t} W^e(t, I,I_j)$ one must compute $W^e(t, I_l, I_j)$ for all individuals in the population. This step can be computationally costly, especially for large populations. </span>
<span id="cb45-718"><a href="#cb45-718" aria-hidden="true" tabindex="-1"></a>One way to avoid this summation is to use randomization (see also&nbsp;@FouMel04 in a model without age). The randomization consists in replacing the summation by an evaluation of the interaction function $W^e$ using an individual $J$ drawn uniformly from the population.</span>
<span id="cb45-719"><a href="#cb45-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-720"><a href="#cb45-720" aria-hidden="true" tabindex="-1"></a>More precisely, if $J \sim \mathcal{U}(<span class="sc">\{</span>1, \dots, N_{T_k}<span class="sc">\}</span>)$ is independent of $\bar \Theta_\ell$, we have </span>
<span id="cb45-721"><a href="#cb45-721" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-722"><a href="#cb45-722" aria-hidden="true" tabindex="-1"></a>    \mathbb{P}\Big(\bar \Theta_\ell \le </span>
<span id="cb45-723"><a href="#cb45-723" aria-hidden="true" tabindex="-1"></a>    \sum_{j=1}^{N_{T_k}} W^e(t, I_l, I_j) | \mathcal{F}_{T_k} \Big)</span>
<span id="cb45-724"><a href="#cb45-724" aria-hidden="true" tabindex="-1"></a>    = \mathbb{P}\big(\bar \Theta_\ell </span>
<span id="cb45-725"><a href="#cb45-725" aria-hidden="true" tabindex="-1"></a>    \le N_{T_k} W^e(t, I_l, I_J) | \mathcal{F}_{T_k}\big).</span>
<span id="cb45-726"><a href="#cb45-726" aria-hidden="true" tabindex="-1"></a>$$ {#eq-randomized-event}</span>
<span id="cb45-727"><a href="#cb45-727" aria-hidden="true" tabindex="-1"></a>Equivalently, we can write this probability as $\mathbb{P}\big(\tilde \Theta_\ell \le W^e(t, I_l, I_J) \big)$ where $\tilde \Theta_\ell  = \frac{\bar \Theta_\ell}{N_{T_k}}\sim \mathcal{U}(<span class="co">[</span><span class="ot">0, \bar W^e</span><span class="co">]</span>)$ is independent of $J \sim \mathcal{U}(<span class="sc">\{</span>1, \dots, N_{T_k}<span class="sc">\}</span>)$.</span>
<span id="cb45-728"><a href="#cb45-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-729"><a href="#cb45-729" aria-hidden="true" tabindex="-1"></a>::: {#rem} </span>
<span id="cb45-730"><a href="#cb45-730" aria-hidden="true" tabindex="-1"></a>The efficiency of the randomization procedure increases with the population homogeneity. If the function $W^e$ varies little according to the individuals in the population, the randomization approach is very efficient in practice, especially when the population is large.</span>
<span id="cb45-731"><a href="#cb45-731" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-732"><a href="#cb45-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-733"><a href="#cb45-733" aria-hidden="true" tabindex="-1"></a>We now present the main @alg-randomized implemented in the <span class="in">`popsim`</span> function of the <span class="in">`IBMPopSim`</span> package in the case where events arrive with individual intensities, but also with interactions (using randomization) and Poisson intensities. In this general case, $\bar \Lambda(n)$ is defined by @eq-def-bar-Lambda.</span>
<span id="cb45-734"><a href="#cb45-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-735"><a href="#cb45-735" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb45-736"><a href="#cb45-736" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: alg-randomized</span></span>
<span id="cb45-737"><a href="#cb45-737" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb45-738"><a href="#cb45-738" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb45-739"><a href="#cb45-739" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb45-740"><a href="#cb45-740" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb45-741"><a href="#cb45-741" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb45-742"><a href="#cb45-742" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "H"</span></span>
<span id="cb45-743"><a href="#cb45-743" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb45-744"><a href="#cb45-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-745"><a href="#cb45-745" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb45-746"><a href="#cb45-746" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Randomized IBM simulation algorithm.}</span></span>
<span id="cb45-747"><a href="#cb45-747" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb45-748"><a href="#cb45-748" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Input:} Initial population $Z_0$, horizon $T &gt; 0$, and events described by</span></span>
<span id="cb45-749"><a href="#cb45-749" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Intensity functions and bounds $(\lambda^e, \bar \lambda^e)$ for $e \in \mathcal{E}$, $(W^e, \bar W^e)$ for $e \in \mathcal{E}_W$ and $(\mu^e, \bar \mu^e)$ for $e \in \mathcal{P}$ </span></span>
<span id="cb45-750"><a href="#cb45-750" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Event action functions $\phi^e(t, I)$ for $e \in \mathcal{E} \cup \mathcal{E}_W \cup \mathcal{P}$</span></span>
<span id="cb45-751"><a href="#cb45-751" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Output:} Population $Z_T$</span></span>
<span id="cb45-752"><a href="#cb45-752" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Initialization $T_0 \longleftarrow 0$, $\bar T_0 \longleftarrow 0$ </span></span>
<span id="cb45-753"><a href="#cb45-753" aria-hidden="true" tabindex="-1"></a><span class="in">    \While{$T_k &lt; T$}</span></span>
<span id="cb45-754"><a href="#cb45-754" aria-hidden="true" tabindex="-1"></a><span class="in">        \Repeat</span></span>
<span id="cb45-755"><a href="#cb45-755" aria-hidden="true" tabindex="-1"></a><span class="in">            \State increment iterative variable $\ell \longleftarrow \ell+1$</span></span>
<span id="cb45-756"><a href="#cb45-756" aria-hidden="true" tabindex="-1"></a><span class="in">            \State compute next proposed time $\bar T_{\ell} \longleftarrow \bar T_{\ell-1} + \mathcal{E}\big(\bar \Lambda(N_{T_k}) \big)$</span></span>
<span id="cb45-757"><a href="#cb45-757" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw an individual index $\bar K_\ell \sim \mathcal{U}(\{1,\dots,N_{T_k}\})$</span></span>
<span id="cb45-758"><a href="#cb45-758" aria-hidden="true" tabindex="-1"></a><span class="in">            \State draw a proposed event $\bar E_\ell \sim \mathcal{U}\{p_e\}$ with $p_e = \frac{\bar \mu^e \mathbf{1}_{e \in \mathcal{P}} + \bar \lambda^e  N_{T_k}\mathbf{1}_{e \in \mathcal{E}} + \bar W^e (N_{T_k})^2 \mathbf{1}_{e \in \mathcal{E}_W}}{\bar \Lambda(N_{T_k})}$ </span></span>
<span id="cb45-759"><a href="#cb45-759" aria-hidden="true" tabindex="-1"></a><span class="in">            \If{$\bar E_\ell \in \mathcal{E}$ (without interaction)}</span></span>
<span id="cb45-760"><a href="#cb45-760" aria-hidden="true" tabindex="-1"></a><span class="in">                \State draw $\bar \Theta_\ell \sim \mathcal{U}\big([0, \bar \lambda^{\bar E_\ell}] \big)$ </span></span>
<span id="cb45-761"><a href="#cb45-761" aria-hidden="true" tabindex="-1"></a><span class="in">                \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le \lambda^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell})$ </span></span>
<span id="cb45-762"><a href="#cb45-762" aria-hidden="true" tabindex="-1"></a><span class="in">            \EndIf</span></span>
<span id="cb45-763"><a href="#cb45-763" aria-hidden="true" tabindex="-1"></a><span class="in">            \If{$\bar E_\ell \in \mathcal{E}_W$ (with interaction)}</span></span>
<span id="cb45-764"><a href="#cb45-764" aria-hidden="true" tabindex="-1"></a><span class="in">                \State draw $(\bar \Theta_\ell, J_\ell) \sim  \mathcal{U}\big([0, \bar W^{\bar E_\ell}] \times \{1, \dots, N_{T_k}\} \big)$</span></span>
<span id="cb45-765"><a href="#cb45-765" aria-hidden="true" tabindex="-1"></a><span class="in">                \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le W^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell}, I_{J_\ell})$</span></span>
<span id="cb45-766"><a href="#cb45-766" aria-hidden="true" tabindex="-1"></a><span class="in">            \EndIf</span></span>
<span id="cb45-767"><a href="#cb45-767" aria-hidden="true" tabindex="-1"></a><span class="in">            \If{$\bar E_\ell \in \mathcal{P}$ (Poissonian intensity)}</span></span>
<span id="cb45-768"><a href="#cb45-768" aria-hidden="true" tabindex="-1"></a><span class="in">                \State draw $\bar \Theta_\ell \sim \mathcal{U}\big([0, \bar \mu^{\bar E_\ell}] \big)$ </span></span>
<span id="cb45-769"><a href="#cb45-769" aria-hidden="true" tabindex="-1"></a><span class="in">                \State \emph{accepted} $\longleftarrow \bar \Theta_\ell \le \mu^{\bar E_\ell}(\bar T_\ell)$</span></span>
<span id="cb45-770"><a href="#cb45-770" aria-hidden="true" tabindex="-1"></a><span class="in">            \EndIf</span></span>
<span id="cb45-771"><a href="#cb45-771" aria-hidden="true" tabindex="-1"></a><span class="in">        \Until{accepted} </span></span>
<span id="cb45-772"><a href="#cb45-772" aria-hidden="true" tabindex="-1"></a><span class="in">        \State increment iterative variable $k \longleftarrow k+1$</span></span>
<span id="cb45-773"><a href="#cb45-773" aria-hidden="true" tabindex="-1"></a><span class="in">        \State record $(T_k, E_k, I_k) \longleftarrow (\bar T_{\ell}, \bar E_\ell, \bar I_{\bar K_\ell})$ as accepted time, event and individual</span></span>
<span id="cb45-774"><a href="#cb45-774" aria-hidden="true" tabindex="-1"></a><span class="in">        \State update the population $Z_{T_k} = Z_{T_{k-1}} + \phi^{E_k}(T_k, I_k)$</span></span>
<span id="cb45-775"><a href="#cb45-775" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndWhile</span></span>
<span id="cb45-776"><a href="#cb45-776" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb45-777"><a href="#cb45-777" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb45-778"><a href="#cb45-778" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-779"><a href="#cb45-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-780"><a href="#cb45-780" aria-hidden="true" tabindex="-1"></a>::: {#prp-randomized}</span>
<span id="cb45-781"><a href="#cb45-781" aria-hidden="true" tabindex="-1"></a>The population processes $(Z_t)_{t\in <span class="co">[</span><span class="ot">0,T</span><span class="co">]</span>}$ simulated by the @alg-interaction and @alg-randomized have the same law.</span>
<span id="cb45-782"><a href="#cb45-782" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-783"><a href="#cb45-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-784"><a href="#cb45-784" aria-hidden="true" tabindex="-1"></a>::: {.proof}</span>
<span id="cb45-785"><a href="#cb45-785" aria-hidden="true" tabindex="-1"></a>The only difference between @alg-interaction and @alg-randomized is in the acceptance/rejection step of proposed events, in the presence of interactions.</span>
<span id="cb45-786"><a href="#cb45-786" aria-hidden="true" tabindex="-1"></a>In @alg-randomized , a proposed event $(\bar T_\ell, \bar E_\ell, \bar K_\ell)$, with $\bar E_l \in \mathcal{E}_W$ (an event with interaction), is accepted as a true event in the population if</span>
<span id="cb45-787"><a href="#cb45-787" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-788"><a href="#cb45-788" aria-hidden="true" tabindex="-1"></a>    \bar \Theta_\ell \le W^{\bar E_\ell}(\bar T_\ell, I_{\bar K_\ell}, I_{\bar J_\ell}), \text{ with } (\bar \Theta_\ell, \bar J_\ell) \sim  \mathcal{U}\big(<span class="co">[</span><span class="ot">0, \bar W^{\bar E_\ell}</span><span class="co">]</span> \times <span class="sc">\{</span>1, \dots, N_{T_k}<span class="sc">\}</span> \big).</span>
<span id="cb45-789"><a href="#cb45-789" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb45-790"><a href="#cb45-790" aria-hidden="true" tabindex="-1"></a>By @eq-randomized-event, the probability of accepting this event is the same than in @alg-interaction, which achieves the proof.</span>
<span id="cb45-791"><a href="#cb45-791" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-792"><a href="#cb45-792" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-793"><a href="#cb45-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-794"><a href="#cb45-794" aria-hidden="true" tabindex="-1"></a><span class="fu"># Model creation and simulation with IBMPopSim {#sec-package}</span></span>
<span id="cb45-795"><a href="#cb45-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-796"><a href="#cb45-796" aria-hidden="true" tabindex="-1"></a>The use of the <span class="in">`IBMPopSim`</span> package is mainly done in two steps: a first model creation followed by the simulation of the population evolution. The creation of a model is itself based on two steps: the description of the population $Z_t$, as introduced in @sec-population, and the description of the events types, along with their associated intensities, as detailed in @sec-events and @sec-event-intensity.</span>
<span id="cb45-797"><a href="#cb45-797" aria-hidden="true" tabindex="-1"></a>A model is compiled by calling the <span class="in">`mk_model`</span> function, which internally uses a template mechanism to automatically generate the source code describing the model, which is subsequently compiled using the <span class="in">`Rcpp`</span> package to produce the object code.</span>
<span id="cb45-798"><a href="#cb45-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-799"><a href="#cb45-799" aria-hidden="true" tabindex="-1"></a>After the compilation of the model, the simulations are launched by calling the <span class="in">`popsim`</span> function. This function depends on the previously compiled model and simulates a random trajectory of the population evolution based on an initial population and on parameter values, which can change from a call to another.</span>
<span id="cb45-800"><a href="#cb45-800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-801"><a href="#cb45-801" aria-hidden="true" tabindex="-1"></a>In this section, we take a closer look at each component of a model in <span class="in">`IBMPopSim`</span>. We also refer to the <span class="co">[</span><span class="ot">IBMPopSim website</span><span class="co">](https://daphnegiorgi.github.io/IBMPopSim/)</span> and to the <span class="in">`vignettes`</span> of the package for more details on the package and various examples of model creation.</span>
<span id="cb45-802"><a href="#cb45-802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-803"><a href="#cb45-803" aria-hidden="true" tabindex="-1"></a><span class="fu">## Population {#sec-package-population}</span></span>
<span id="cb45-804"><a href="#cb45-804" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-805"><a href="#cb45-805" aria-hidden="true" tabindex="-1"></a>A population $Z$ is represented by an object of class <span class="in">`population`</span> containing a data frame where each row corresponds to an individual $I=(\tau^b, \tau^d, x)$, and which has at least two columns, <span class="in">`birth`</span> and <span class="in">`death`</span>, corresponding to the birth date $\tau^b$ and death/exit date $\tau^d$ ($\tau^d$ is set to <span class="in">`NA`</span> for alive individuals). The data frame can contain more than two columns if individuals are described by additional characteristics $x= (x_1,\dots x_n)$.</span>
<span id="cb45-806"><a href="#cb45-806" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-807"><a href="#cb45-807" aria-hidden="true" tabindex="-1"></a>If entry events can occur in the population, the population will contain a characteristic named <span class="in">`entry`</span>. This can be done by setting the flag <span class="in">`entry=TRUE`</span> in the <span class="in">`population`</span> function, or by calling the <span class="in">`add_characteristic`</span> function on an existing population. During the simulation, the date at which an individual enters the population is automatically recorded in the variable <span class="in">`I.entry`</span>.</span>
<span id="cb45-808"><a href="#cb45-808" aria-hidden="true" tabindex="-1"></a>If exit events can occur, the population shall contain a characteristic named <span class="in">`out`</span>. This can be done by setting the flag <span class="in">`out=TRUE`</span> in the <span class="in">`population`</span> function, or by calling the <span class="in">`add_characteristic`</span> function. When an individual <span class="in">`I`</span> exits the population during the simulation, <span class="in">`I.out`</span> is set to <span class="in">`TRUE`</span> and its exit time is recorded as a "death" date.</span>
<span id="cb45-809"><a href="#cb45-809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-810"><a href="#cb45-810" aria-hidden="true" tabindex="-1"></a>In the example below, individuals are described by their birth and death dates, as well a Boolean characteristics called male, and the <span class="in">`entry`</span> characteristic. For instance, the first individual is a female whose age at $t_0=0$ is $107$ and who was originally in the population.</span>
<span id="cb45-813"><a href="#cb45-813" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb45-814"><a href="#cb45-814" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(EW_pop_14<span class="sc">$</span>sample, <span class="at">entry=</span><span class="cn">TRUE</span>)</span>
<span id="cb45-815"><a href="#cb45-815" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(pop_init)</span>
<span id="cb45-816"><a href="#cb45-816" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-817"><a href="#cb45-817" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-818"><a href="#cb45-818" aria-hidden="true" tabindex="-1"></a>_Individual_ In the <span class="in">`C++`</span> model which is automatically generated and compiled, an individual <span class="in">`I`</span> is an object of an internal class containing some attributes (<span class="in">`birth_date`</span>, <span class="in">`death_date`</span> and the characteristics), and some methods including:</span>
<span id="cb45-819"><a href="#cb45-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-820"><a href="#cb45-820" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I.age(t)`</span>: a <span class="in">`const`</span> method returning the age of an individual <span class="in">`I`</span> at time <span class="in">`t`</span>,</span>
<span id="cb45-821"><a href="#cb45-821" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I.set_age(a, t)`</span>: a method to set the age <span class="in">`a`</span> at time <span class="in">`t`</span> of an individual <span class="in">`I`</span> (set <span class="in">`birth_date`</span> at <span class="in">`t-a`</span>),</span>
<span id="cb45-822"><a href="#cb45-822" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`I.is_dead(t)`</span>: a <span class="in">`const`</span> method returning <span class="in">`true`</span> if the individual <span class="in">`I`</span> is dead at time <span class="in">`t`</span>.</span>
<span id="cb45-823"><a href="#cb45-823" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-824"><a href="#cb45-824" aria-hidden="true" tabindex="-1"></a>::: {#rem-characteristics}</span>
<span id="cb45-825"><a href="#cb45-825" aria-hidden="true" tabindex="-1"></a>A characteristic $x_i$ must be of atomic type: <span class="in">`logical`</span>, <span class="in">`integer`</span>, <span class="in">`double`</span> or <span class="in">`character`</span>. The function <span class="in">`get_characteristic`</span> allows to easily get characteristics names and their types from a population data frame. We draw the attention to the fact that some names for characteristics are forbidden, or reserved to specific cases : this is the case for <span class="in">`birth`</span>, <span class="in">`death`</span>, <span class="in">`entry`</span>, <span class="in">`out`</span>, <span class="in">`id`</span>.</span>
<span id="cb45-826"><a href="#cb45-826" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-827"><a href="#cb45-827" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-828"><a href="#cb45-828" aria-hidden="true" tabindex="-1"></a><span class="fu">## Events {#sec-package-events}</span></span>
<span id="cb45-829"><a href="#cb45-829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-830"><a href="#cb45-830" aria-hidden="true" tabindex="-1"></a>The most important step of the model creation is the events creation. The call to the function creating an event is of form</span>
<span id="cb45-833"><a href="#cb45-833" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb45-834"><a href="#cb45-834" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false </span></span>
<span id="cb45-835"><a href="#cb45-835" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_CLASS</span>(<span class="at">type=</span><span class="st">"TYPE"</span>, <span class="at">name=</span><span class="st">"NAME"</span>, ...)</span>
<span id="cb45-836"><a href="#cb45-836" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-837"><a href="#cb45-837" aria-hidden="true" tabindex="-1"></a>where <span class="in">`CLASS`</span> is replaced by the class of the event intensity, described in @sec-event-intensity , and <span class="in">`type`</span> corresponds to the event type, described in @sec-events.</span>
<span id="cb45-838"><a href="#cb45-838" aria-hidden="true" tabindex="-1"></a>@tbl-intensity-classes and @tbl-event-types summarize the different possible choices for intensity classes and types of event. The optional argument <span class="in">`name`</span> gives a name to the event. If not specified, the name of the event is its type, for instance <span class="in">`death`</span>. However, a name must be specified if the model is composed of several events with the same type (for instance when there are multiple death events corresponding to different causes of death). The other arguments depend on the intensity class and on the event type.</span>
<span id="cb45-839"><a href="#cb45-839" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-840"><a href="#cb45-840" aria-hidden="true" tabindex="-1"></a>::: {#tbl-panel layout-ncol=2}</span>
<span id="cb45-841"><a href="#cb45-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-842"><a href="#cb45-842" aria-hidden="true" tabindex="-1"></a>Intensity class         Set               <span class="in">`CLASS`</span></span>
<span id="cb45-843"><a href="#cb45-843" aria-hidden="true" tabindex="-1"></a>----------------------- ----------------- -------------------------</span>
<span id="cb45-844"><a href="#cb45-844" aria-hidden="true" tabindex="-1"></a>Individual              $\mathcal{E}$     <span class="in">`individual`</span></span>
<span id="cb45-845"><a href="#cb45-845" aria-hidden="true" tabindex="-1"></a>Interaction             $\mathcal{E}_W$   <span class="in">`interaction`</span></span>
<span id="cb45-846"><a href="#cb45-846" aria-hidden="true" tabindex="-1"></a>Poisson                 $\mathcal{P}$     <span class="in">`poisson`</span></span>
<span id="cb45-847"><a href="#cb45-847" aria-hidden="true" tabindex="-1"></a>Inhomogeneous Poisson   $\mathcal{P}$     <span class="in">`inhomogeneous_poisson`</span></span>
<span id="cb45-848"><a href="#cb45-848" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-849"><a href="#cb45-849" aria-hidden="true" tabindex="-1"></a>: Intensity Classes {#tbl-intensity-classes}</span>
<span id="cb45-850"><a href="#cb45-850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-851"><a href="#cb45-851" aria-hidden="true" tabindex="-1"></a>Event type   <span class="in">`TYPE`</span></span>
<span id="cb45-852"><a href="#cb45-852" aria-hidden="true" tabindex="-1"></a>------------ ---------</span>
<span id="cb45-853"><a href="#cb45-853" aria-hidden="true" tabindex="-1"></a>Birth        <span class="in">`birth`</span></span>
<span id="cb45-854"><a href="#cb45-854" aria-hidden="true" tabindex="-1"></a>Death        <span class="in">`death`</span></span>
<span id="cb45-855"><a href="#cb45-855" aria-hidden="true" tabindex="-1"></a>Entry        <span class="in">`entry`</span></span>
<span id="cb45-856"><a href="#cb45-856" aria-hidden="true" tabindex="-1"></a>Exit         <span class="in">`exit`</span></span>
<span id="cb45-857"><a href="#cb45-857" aria-hidden="true" tabindex="-1"></a>Swap         <span class="in">`swap`</span></span>
<span id="cb45-858"><a href="#cb45-858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-859"><a href="#cb45-859" aria-hidden="true" tabindex="-1"></a>: Event Types {#tbl-event-types}</span>
<span id="cb45-860"><a href="#cb45-860" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-861"><a href="#cb45-861" aria-hidden="true" tabindex="-1"></a>Choices of <span class="in">`CLASS`</span> and <span class="in">`TYPE`</span> arguments for an event creation.</span>
<span id="cb45-862"><a href="#cb45-862" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-863"><a href="#cb45-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-864"><a href="#cb45-864" aria-hidden="true" tabindex="-1"></a>The intensity function and the kernel of an event are defined through arguments of the function <span class="in">`mk_event_CLASS`</span>. These arguments are strings composed of few lines of code. Since the model is compiled using <span class="in">`Rcpp`</span>, the code should be written in <span class="in">`C++`</span>. However, thanks to the functions/variables of the package, even the non-experienced <span class="in">`C++`</span> user can define a model quite easily. </span>
<span id="cb45-865"><a href="#cb45-865" aria-hidden="true" tabindex="-1"></a>To facilitate the implementation, the user can also define a list of **model parameters**, which can be used in the event and intensity definitions. These parameters are stored in a named list and can be of various types: atomic type, numeric vector or matrix, predefined function of one variable (<span class="in">`stepfun`</span>, <span class="in">`linfun`</span>, <span class="in">`gompertz`</span>, <span class="in">`weibull`</span>, <span class="in">`piecewise_x`</span>), piecewise functions of two variables (<span class="in">`piecewise_xy`</span>). </span>
<span id="cb45-866"><a href="#cb45-866" aria-hidden="true" tabindex="-1"></a>We refer to the <span class="in">`vignette(IBMPopSim_cpp)`</span> for more details on parameters types and basic <span class="in">`C++`</span> tools. Another advantage of the model parameters is that their value can be modified from a simulation to another without changing the model.</span>
<span id="cb45-867"><a href="#cb45-867" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-868"><a href="#cb45-868" aria-hidden="true" tabindex="-1"></a><span class="fu">### Intensities</span></span>
<span id="cb45-869"><a href="#cb45-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-870"><a href="#cb45-870" aria-hidden="true" tabindex="-1"></a>In <span class="in">`IBMPopSim`</span>, the intensity of an event can belong to three classes @sec-event-intensity: individual intensities without interaction between individuals, corresponding to events $e\in\mathcal{E}$, individual intensities with interaction, corresponding to events $e\in\mathcal{E}_W$, and Poisson intensities (homogeneous and inhomogeneous), corresponding to events $e\in\mathcal{P}$.</span>
<span id="cb45-871"><a href="#cb45-871" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-872"><a href="#cb45-872" aria-hidden="true" tabindex="-1"></a>_Event creation with individual intensity_  </span>
<span id="cb45-873"><a href="#cb45-873" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-874"><a href="#cb45-874" aria-hidden="true" tabindex="-1"></a>An event $e\in \mathcal{E}$ (see @eq-intensity-no-interaction) has an intensity of the form $\lambda^e(t, I)$ which depends only on the individual <span class="in">`I`</span> and time. Events with such intensity are created using the function</span>
<span id="cb45-877"><a href="#cb45-877" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb45-878"><a href="#cb45-878" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb45-879"><a href="#cb45-879" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_individual</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>, </span>
<span id="cb45-880"><a href="#cb45-880" aria-hidden="true" tabindex="-1"></a>                    <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb45-881"><a href="#cb45-881" aria-hidden="true" tabindex="-1"></a>                    <span class="at">intensity_code =</span> <span class="st">"INTENSITY"</span>, ...)</span>
<span id="cb45-882"><a href="#cb45-882" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-883"><a href="#cb45-883" aria-hidden="true" tabindex="-1"></a>The <span class="in">`intensity_code`</span> argument is a character string containing few lines of <span class="in">`C++`</span> code describing the intensity function $\lambda^e(t, I)$. The intensity value has to be stored in a variable called <span class="in">`result`</span> and the available variables for the intensity code are given in @tbl-intensity-variables.</span>
<span id="cb45-884"><a href="#cb45-884" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-885"><a href="#cb45-885" aria-hidden="true" tabindex="-1"></a>::: {#tbl-intensity-variables}</span>
<span id="cb45-886"><a href="#cb45-886" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-887"><a href="#cb45-887" aria-hidden="true" tabindex="-1"></a>Variable           Description</span>
<span id="cb45-888"><a href="#cb45-888" aria-hidden="true" tabindex="-1"></a>------------------ -------------------------------------------------------------</span>
<span id="cb45-889"><a href="#cb45-889" aria-hidden="true" tabindex="-1"></a>Variable           Description</span>
<span id="cb45-890"><a href="#cb45-890" aria-hidden="true" tabindex="-1"></a><span class="in">`I`</span>                Current individual</span>
<span id="cb45-891"><a href="#cb45-891" aria-hidden="true" tabindex="-1"></a><span class="in">`J`</span>                Another individual in the population (only for interaction)</span>
<span id="cb45-892"><a href="#cb45-892" aria-hidden="true" tabindex="-1"></a><span class="in">`t`</span>                Current time</span>
<span id="cb45-893"><a href="#cb45-893" aria-hidden="true" tabindex="-1"></a>Model parameters   Depends on the model</span>
<span id="cb45-894"><a href="#cb45-894" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-895"><a href="#cb45-895" aria-hidden="true" tabindex="-1"></a><span class="in">`C++`</span> variables available for intensity code</span>
<span id="cb45-896"><a href="#cb45-896" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb45-897"><a href="#cb45-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-898"><a href="#cb45-898" aria-hidden="true" tabindex="-1"></a>For instance, the intensity code below corresponds to an individual death intensity $\lambda^d(t,I)$ equal to $d_1(a(I,t)) = \alpha_1 \exp(\beta_1 a(I,t))$ for males and $d_2(a(I,t)) = \alpha_2 \exp(\beta_2 a(I,t))$ for females, where $a(I,t)=t-\tau^b$ is the age of the individual $I=(\tau^b, \tau^d,x)$ at time $t$. </span>
<span id="cb45-899"><a href="#cb45-899" aria-hidden="true" tabindex="-1"></a>In this case, the intensity function depends on the individuals' age, gender, and on the model parameters $\alpha = (\alpha_1, \alpha_2)$ and $\beta = (\beta_1, \beta_2)$.</span>
<span id="cb45-902"><a href="#cb45-902" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb45-903"><a href="#cb45-903" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb45-904"><a href="#cb45-904" aria-hidden="true" tabindex="-1"></a>death_intensity <span class="ot">&lt;-</span> <span class="st">"</span></span>
<span id="cb45-905"><a href="#cb45-905" aria-hidden="true" tabindex="-1"></a><span class="st">    if (I.male) result = alpha_1 * exp(beta_1 * I.age(t));</span></span>
<span id="cb45-906"><a href="#cb45-906" aria-hidden="true" tabindex="-1"></a><span class="st">    else result = alpha_2 * exp(beta_2 * I.age(t));</span></span>
<span id="cb45-907"><a href="#cb45-907" aria-hidden="true" tabindex="-1"></a><span class="st">"</span></span>
<span id="cb45-908"><a href="#cb45-908" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-909"><a href="#cb45-909" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-910"><a href="#cb45-910" aria-hidden="true" tabindex="-1"></a>_Event creation with interaction intensity_  </span>
<span id="cb45-911"><a href="#cb45-911" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb45-912"><a href="#cb45-912" aria-hidden="true" tabindex="-1"></a>An event $e\in \mathcal{E}_W$ is an event which occurs to an individual at a frequency which is the result of interactions with other members of the population (see @eq-intensity-interaction), and which can be written as $\lambda^e_t(I, Z_t)=\sum_{J\in Z_t} W^e(t, I, J)$ where $W^e(t, I, J)$ is the intensity of the interaction between individual $I$ and individual $J$.</span>
<span id="cb45-913"><a href="#cb45-913" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-914"><a href="#cb45-914" aria-hidden="true" tabindex="-1"></a>An event $e\in \mathcal{E}_W$ with such intensity is created by calling the function</span>
<span id="cb45-917"><a href="#cb45-917" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb45-918"><a href="#cb45-918" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb45-919"><a href="#cb45-919" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_interaction</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>,</span>
<span id="cb45-920"><a href="#cb45-920" aria-hidden="true" tabindex="-1"></a>                     <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb45-921"><a href="#cb45-921" aria-hidden="true" tabindex="-1"></a>                     <span class="at">interaction_code =</span> <span class="st">"INTERACTION_CODE"</span>,</span>
<span id="cb45-922"><a href="#cb45-922" aria-hidden="true" tabindex="-1"></a>                     <span class="at">interaction_type =</span> <span class="st">"random"</span>, ...)</span>
<span id="cb45-923"><a href="#cb45-923" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-924"><a href="#cb45-924" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-925"><a href="#cb45-925" aria-hidden="true" tabindex="-1"></a>The <span class="in">`interaction_code`</span> argument contains few lines of <span class="in">`C++`</span> code describing the interaction function $W^e(t, I, J)$. The interaction function value has to be stored in a variable called <span class="in">`result`</span> and the available variables for the intensity code are given in @tbl-intensity-variables. For example, if we set</span>
<span id="cb45-928"><a href="#cb45-928" aria-hidden="true" tabindex="-1"></a><span class="in">```{R}</span></span>
<span id="cb45-929"><a href="#cb45-929" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb45-930"><a href="#cb45-930" aria-hidden="true" tabindex="-1"></a>death_interaction_code <span class="ot">&lt;-</span> <span class="st">"result = max(J.size - I.size, 0.);"</span></span>
<span id="cb45-931"><a href="#cb45-931" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-932"><a href="#cb45-932" aria-hidden="true" tabindex="-1"></a>the death intensity of an individual <span class="in">`I`</span> is the result of the competition between individuals, depending on a characteristic named <span class="in">`size`</span>, as defined in @eq-ex-interaction. </span>
<span id="cb45-933"><a href="#cb45-933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-934"><a href="#cb45-934" aria-hidden="true" tabindex="-1"></a>The argument <span class="in">`interaction_type`</span>, set by default at <span class="in">`random`</span>, is the algorithm choice for simulating the model. When <span class="in">`interaction_type=full`</span>, the simulation follows @alg-interaction, <span class="in">`interaction_type=random`</span> it follows @alg-randomized.</span>
<span id="cb45-935"><a href="#cb45-935" aria-hidden="true" tabindex="-1"></a>In most cases, the <span class="in">`random`</span> algorithm is much faster than the <span class="in">`full`</span> algorithm. For instance in the example of @sec-example-interaction the <span class="in">`random`</span> algorithm is 40 times faster on average than the <span class="in">`full`</span> algorithm, on a set of standard parameters. This allows in particular to explore larger parameter sets and population sizes, while avoiding the explosion of computation time.</span>
<span id="cb45-936"><a href="#cb45-936" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-937"><a href="#cb45-937" aria-hidden="true" tabindex="-1"></a>_Events creation with Poisson and Inhomogeneous Poisson intensity_  </span>
<span id="cb45-938"><a href="#cb45-938" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-939"><a href="#cb45-939" aria-hidden="true" tabindex="-1"></a>For events $e\in \mathcal{P}\,$ with an intensity $\mu^e(t)$ which does not depend on the population, the event intensity is of class <span class="in">`inhomogeneous_poisson`</span> or <span class="in">`poisson`</span> depending on whether or not the intensity depends on time (in the second case the intensity is constant).</span>
<span id="cb45-940"><a href="#cb45-940" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-941"><a href="#cb45-941" aria-hidden="true" tabindex="-1"></a>For Poisson (constant) intensities the events are created with the function</span>
<span id="cb45-944"><a href="#cb45-944" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-945"><a href="#cb45-945" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb45-946"><a href="#cb45-946" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_poisson</span>(<span class="at">type =</span> <span class="st">"TYPE"</span>,</span>
<span id="cb45-947"><a href="#cb45-947" aria-hidden="true" tabindex="-1"></a>                 <span class="at">name =</span> <span class="st">"NAME"</span>,</span>
<span id="cb45-948"><a href="#cb45-948" aria-hidden="true" tabindex="-1"></a>                 <span class="at">intensity =</span> <span class="st">"CONSTANT"</span>, ...)</span>
<span id="cb45-949"><a href="#cb45-949" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb45-950"><a href="#cb45-950" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-951"><a href="#cb45-951" aria-hidden="true" tabindex="-1"></a>The following example creates a death event, where individuals die at a constant intensity <span class="in">`lambda`</span> (which has to be in the list of model parameters):</span>
<span id="cb45-954"><a href="#cb45-954" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-955"><a href="#cb45-955" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb45-956"><a href="#cb45-956" aria-hidden="true" tabindex="-1"></a><span class="fu">mk_event_poisson</span>(<span class="at">type =</span> <span class="st">"death,</span></span>
<span id="cb45-957"><a href="#cb45-957" aria-hidden="true" tabindex="-1"></a><span class="st">                 intensity = "</span>lambda<span class="st">")</span></span>
<span id="cb45-958"><a href="#cb45-958" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-959"><a href="#cb45-959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-960"><a href="#cb45-960" aria-hidden="true" tabindex="-1"></a><span class="st">When the intensity $(\mu^e(t))$ depends on time, the event can be created similarly by using the function</span></span>
<span id="cb45-963"><a href="#cb45-963" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-964"><a href="#cb45-964" aria-hidden="true" tabindex="-1"></a><span class="st">#| eval: false</span></span>
<span id="cb45-965"><a href="#cb45-965" aria-hidden="true" tabindex="-1"></a><span class="st">mk_event_inhomogeneous_poisson(type = "</span>TYPE<span class="st">",</span></span>
<span id="cb45-966"><a href="#cb45-966" aria-hidden="true" tabindex="-1"></a><span class="st">                               name = "</span>NAME<span class="st">",</span></span>
<span id="cb45-967"><a href="#cb45-967" aria-hidden="true" tabindex="-1"></a><span class="st">                               intensity = "</span>INTENSITY<span class="st">", ...)</span></span>
<span id="cb45-968"><a href="#cb45-968" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-969"><a href="#cb45-969" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-970"><a href="#cb45-970" aria-hidden="true" tabindex="-1"></a><span class="st">### Event kernel code {#sec-event-kernel-code}</span></span>
<span id="cb45-971"><a href="#cb45-971" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-972"><a href="#cb45-972" aria-hidden="true" tabindex="-1"></a><span class="st">When an event occurs, the events kernels $k^e$ specify how the event modifies the population. The events kernels are defined in the `kernel_code` parameter of the `mk_event_CLASS(type = "</span>TYPE<span class="st">", name ="</span>NAME<span class="st">", ...)` function. The `kernel_code` is `NULL` by default and doesn't have to be specified for death, exit events and birth events, but mandatory for entry and swap events. Recall that the `kernel_code` argument is a string composed of a few lines of `C++` code, characterizing the individual characteristics following the event.</span></span>
<span id="cb45-973"><a href="#cb45-973" aria-hidden="true" tabindex="-1"></a><span class="st">@tbl-events-variables summarizes the list of available variables that can be used in the `kernel_code`.</span></span>
<span id="cb45-974"><a href="#cb45-974" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-975"><a href="#cb45-975" aria-hidden="true" tabindex="-1"></a><span class="st">- **Death/Exit event** If the user defines a death event, the death date of the current individual `I` is set automatically to the current time `t`. Similarly, when an individual `I` exits the population, `I.out` is set automatically to `TRUE` and his exit time is recorded as a *death* date. For these events types, the `kernel_code` doesn't have to be specified by the user.</span></span>
<span id="cb45-976"><a href="#cb45-976" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-977"><a href="#cb45-977" aria-hidden="true" tabindex="-1"></a><span class="st">- **Birth event** The default generated event kernel is that an individual `I` gives birth to a new individual `newI` of age 0 at the current time `t`, with same characteristics than the parent `I`. If no kernel is specified, the default generated `C++` code for a birth event is:</span></span>
<span id="cb45-980"><a href="#cb45-980" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-981"><a href="#cb45-981" aria-hidden="true" tabindex="-1"></a><span class="st">#| eval: false</span></span>
<span id="cb45-982"><a href="#cb45-982" aria-hidden="true" tabindex="-1"></a><span class="st">individual newI = I;</span></span>
<span id="cb45-983"><a href="#cb45-983" aria-hidden="true" tabindex="-1"></a><span class="st">newI.birth_date = t;</span></span>
<span id="cb45-984"><a href="#cb45-984" aria-hidden="true" tabindex="-1"></a><span class="st">pop.add(newI);</span></span>
<span id="cb45-985"><a href="#cb45-985" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-986"><a href="#cb45-986" aria-hidden="true" tabindex="-1"></a><span class="st">The user can modify the birth kernel, by specifying the argument `kernel_code` of `mk_event_CLASS`. In this case, the generated code is</span></span>
<span id="cb45-989"><a href="#cb45-989" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-990"><a href="#cb45-990" aria-hidden="true" tabindex="-1"></a><span class="st">#| eval: false</span></span>
<span id="cb45-991"><a href="#cb45-991" aria-hidden="true" tabindex="-1"></a><span class="st">individual newI = I;</span></span>
<span id="cb45-992"><a href="#cb45-992" aria-hidden="true" tabindex="-1"></a><span class="st">newI.birth_date = t;</span></span>
<span id="cb45-993"><a href="#cb45-993" aria-hidden="true" tabindex="-1"></a><span class="st">_KERNEL_CODE_</span></span>
<span id="cb45-994"><a href="#cb45-994" aria-hidden="true" tabindex="-1"></a><span class="st">pop.add(newI);</span></span>
<span id="cb45-995"><a href="#cb45-995" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-996"><a href="#cb45-996" aria-hidden="true" tabindex="-1"></a><span class="st">where `_KERNEL_CODE_` is replaced by the content of the `kernel_code` argument.</span></span>
<span id="cb45-997"><a href="#cb45-997" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-998"><a href="#cb45-998" aria-hidden="true" tabindex="-1"></a><span class="st">- **Entry event** When an individual `I` enters the population, `I.entry` is set automatically as the date at which the individual enters the population. When an entry occurs the individual entering the population is not of age $0$. In this case, the user must specify the `kernel_code` argument indicating how the age and characteristics of the new individual are chosen. For instance, the code below creates an event of type `entry`, named `ev_example`, where individuals enter the population at a Poisson constant intensity. When an individual `newI` enters the population at time `t`, its age is chosen as a normally distributed random variable, with mean 20 and variance 4.</span></span>
<span id="cb45-1001"><a href="#cb45-1001" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1002"><a href="#cb45-1002" aria-hidden="true" tabindex="-1"></a><span class="st">#| eval: false</span></span>
<span id="cb45-1003"><a href="#cb45-1003" aria-hidden="true" tabindex="-1"></a><span class="st">mk_event_poisson(</span></span>
<span id="cb45-1004"><a href="#cb45-1004" aria-hidden="true" tabindex="-1"></a><span class="st">    type = "</span>entry<span class="st">", </span></span>
<span id="cb45-1005"><a href="#cb45-1005" aria-hidden="true" tabindex="-1"></a><span class="st">    name = "</span>ev_example<span class="st">", </span></span>
<span id="cb45-1006"><a href="#cb45-1006" aria-hidden="true" tabindex="-1"></a><span class="st">    intensity = "</span>lambda<span class="st">", </span></span>
<span id="cb45-1007"><a href="#cb45-1007" aria-hidden="true" tabindex="-1"></a><span class="st">    kernel_code = "</span></span>
<span id="cb45-1008"><a href="#cb45-1008" aria-hidden="true" tabindex="-1"></a>        double <span class="at">a_I =</span> <span class="fu">max</span>(<span class="fu">CNorm</span>(<span class="dv">20</span>, <span class="dv">2</span>), <span class="fl">0.</span>); </span>
<span id="cb45-1009"><a href="#cb45-1009" aria-hidden="true" tabindex="-1"></a>        <span class="fu">newI.set_age</span>(a_I, t);</span>
<span id="cb45-1010"><a href="#cb45-1010" aria-hidden="true" tabindex="-1"></a>    <span class="st">")</span></span>
<span id="cb45-1011"><a href="#cb45-1011" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1012"><a href="#cb45-1012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1013"><a href="#cb45-1013" aria-hidden="true" tabindex="-1"></a><span class="st">- **Swap event** The user must specify the `kernel_code` argument indicating how the characteristics of an individual are modified following a swap.</span></span>
<span id="cb45-1014"><a href="#cb45-1014" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1015"><a href="#cb45-1015" aria-hidden="true" tabindex="-1"></a><span class="st">::: {#tbl-events-variables}</span></span>
<span id="cb45-1016"><a href="#cb45-1016" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1017"><a href="#cb45-1017" aria-hidden="true" tabindex="-1"></a><span class="st">Variable           Description</span></span>
<span id="cb45-1018"><a href="#cb45-1018" aria-hidden="true" tabindex="-1"></a><span class="st">------------------ -------------------------------------------------------------</span></span>
<span id="cb45-1019"><a href="#cb45-1019" aria-hidden="true" tabindex="-1"></a><span class="st">Variable           Description</span></span>
<span id="cb45-1020"><a href="#cb45-1020" aria-hidden="true" tabindex="-1"></a><span class="st">`I`                Current individual</span></span>
<span id="cb45-1021"><a href="#cb45-1021" aria-hidden="true" tabindex="-1"></a><span class="st">`J`                Another individual in the population (only for interaction)</span></span>
<span id="cb45-1022"><a href="#cb45-1022" aria-hidden="true" tabindex="-1"></a><span class="st">`t`                Current time</span></span>
<span id="cb45-1023"><a href="#cb45-1023" aria-hidden="true" tabindex="-1"></a><span class="st">`pop`              Current population (vector)</span></span>
<span id="cb45-1024"><a href="#cb45-1024" aria-hidden="true" tabindex="-1"></a><span class="st">`newI`             Available only for birth and entry events.   </span></span>
<span id="cb45-1025"><a href="#cb45-1025" aria-hidden="true" tabindex="-1"></a><span class="st">Model parameters   Depends on the model</span></span>
<span id="cb45-1026"><a href="#cb45-1026" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1027"><a href="#cb45-1027" aria-hidden="true" tabindex="-1"></a><span class="st">`C++` variables available for events kernel code</span></span>
<span id="cb45-1028"><a href="#cb45-1028" aria-hidden="true" tabindex="-1"></a><span class="st">:::</span></span>
<span id="cb45-1029"><a href="#cb45-1029" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1030"><a href="#cb45-1030" aria-hidden="true" tabindex="-1"></a><span class="st">::: {#rem}</span></span>
<span id="cb45-1031"><a href="#cb45-1031" aria-hidden="true" tabindex="-1"></a><span class="st">When there are several events of the same type, the user can identify which events generated a particular event by adding a characteristic to the population recording the event name/id when it occurs. See e.g.&nbsp;`vignette(IBMPopSim_human_pop)` for an example with different causes of death.</span></span>
<span id="cb45-1032"><a href="#cb45-1032" aria-hidden="true" tabindex="-1"></a><span class="st">:::</span></span>
<span id="cb45-1033"><a href="#cb45-1033" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1034"><a href="#cb45-1034" aria-hidden="true" tabindex="-1"></a><span class="st">## Model creation {#sec-model-creation}</span></span>
<span id="cb45-1035"><a href="#cb45-1035" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1036"><a href="#cb45-1036" aria-hidden="true" tabindex="-1"></a><span class="st">Once the population, the events, and model parameters are defined, the IBM model is created using the function `mk_model`.</span></span>
<span id="cb45-1037"><a href="#cb45-1037" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1040"><a href="#cb45-1040" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1041"><a href="#cb45-1041" aria-hidden="true" tabindex="-1"></a><span class="st">#| eval: false</span></span>
<span id="cb45-1042"><a href="#cb45-1042" aria-hidden="true" tabindex="-1"></a><span class="st">model &lt;- mk_model(characteristics = get_characteristics(pop_init),</span></span>
<span id="cb45-1043"><a href="#cb45-1043" aria-hidden="true" tabindex="-1"></a><span class="st">                  event = events_list,</span></span>
<span id="cb45-1044"><a href="#cb45-1044" aria-hidden="true" tabindex="-1"></a><span class="st">                  parameters = model_params)</span></span>
<span id="cb45-1045"><a href="#cb45-1045" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1046"><a href="#cb45-1046" aria-hidden="true" tabindex="-1"></a><span class="st">During this step which can take a few seconds, the model is created and compiled using the `Rcpp` package. The model structure in `IBMPopSim` is that the model depends only on the population characteristics' and parameters names and types, rather than their values. This means that once the model has been created, various simulations can be done with different initial populations and different parameters values.</span></span>
<span id="cb45-1047"><a href="#cb45-1047" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1048"><a href="#cb45-1048" aria-hidden="true" tabindex="-1"></a><span class="st">::: {#exm-model-creation}</span></span>
<span id="cb45-1049"><a href="#cb45-1049" aria-hidden="true" tabindex="-1"></a><span class="st">Here is an example of model with a population structured by age and gender, with birth and death events. The death intensity of an individual of age $a$ is $d(a) = </span><span class="sc">\a</span><span class="st">lpha </span><span class="sc">\e</span><span class="st">xp(</span><span class="sc">\b</span><span class="st">eta a),$ and females between 15 and 40 can give birth with birth intensity $b(a) = </span><span class="sc">\b</span><span class="st">ar \lambda^b \mathbf{1}_{[15,40]}.$ The newborn is a male with probability $p_{male}$.</span></span>
<span id="cb45-1052"><a href="#cb45-1052" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1053"><a href="#cb45-1053" aria-hidden="true" tabindex="-1"></a><span class="st">#| eval: false</span></span>
<span id="cb45-1054"><a href="#cb45-1054" aria-hidden="true" tabindex="-1"></a><span class="st">params &lt;- list("</span>p_male<span class="st">"= 0.51,</span></span>
<span id="cb45-1055"><a href="#cb45-1055" aria-hidden="true" tabindex="-1"></a><span class="st">               "</span>birth_rate<span class="st">" = stepfun(c(15,40),c(0,0.05,0)),</span></span>
<span id="cb45-1056"><a href="#cb45-1056" aria-hidden="true" tabindex="-1"></a><span class="st">               "</span>death_rate<span class="st">" = gompertz(0.008,0.02))</span></span>
<span id="cb45-1057"><a href="#cb45-1057" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1058"><a href="#cb45-1058" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1059"><a href="#cb45-1059" aria-hidden="true" tabindex="-1"></a><span class="st">death_event &lt;- mk_event_individual(type = "</span>death<span class="st">", name= "</span>my_death_event<span class="st">",</span></span>
<span id="cb45-1060"><a href="#cb45-1060" aria-hidden="true" tabindex="-1"></a><span class="st">                  intensity_code = "</span><span class="at">result =</span> <span class="fu">death_rate</span>(<span class="fu">age</span>(I,t));<span class="st">")</span></span>
<span id="cb45-1061"><a href="#cb45-1061" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1062"><a href="#cb45-1062" aria-hidden="true" tabindex="-1"></a><span class="st">birth_event &lt;- mk_event_individual( type = "</span>birth<span class="st">",</span></span>
<span id="cb45-1063"><a href="#cb45-1063" aria-hidden="true" tabindex="-1"></a><span class="st">                  intensity_code = "</span><span class="fu">if</span> (I.male)</span>
<span id="cb45-1064"><a href="#cb45-1064" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">result =</span> <span class="dv">0</span>;</span>
<span id="cb45-1065"><a href="#cb45-1065" aria-hidden="true" tabindex="-1"></a>                                    <span class="cf">else</span></span>
<span id="cb45-1066"><a href="#cb45-1066" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">result=</span><span class="fu">birth_rate</span>(<span class="fu">age</span>(I,t));<span class="st">",</span></span>
<span id="cb45-1067"><a href="#cb45-1067" aria-hidden="true" tabindex="-1"></a><span class="st">                  kernel_code = "</span><span class="at">newI.male =</span> <span class="fu">CUnif</span>(<span class="dv">0</span>, <span class="dv">1</span>) <span class="sc">&lt;</span> p_male;<span class="st">")</span></span>
<span id="cb45-1068"><a href="#cb45-1068" aria-hidden="true" tabindex="-1"></a><span class="st">pop &lt;- population(EW_pop_14$sample)</span></span>
<span id="cb45-1069"><a href="#cb45-1069" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1070"><a href="#cb45-1070" aria-hidden="true" tabindex="-1"></a><span class="st">model &lt;- mk_model(characteristics = get_characteristics(pop),</span></span>
<span id="cb45-1071"><a href="#cb45-1071" aria-hidden="true" tabindex="-1"></a><span class="st">                  events = list(death_event,birth_event),</span></span>
<span id="cb45-1072"><a href="#cb45-1072" aria-hidden="true" tabindex="-1"></a><span class="st">                  parameters = params)</span></span>
<span id="cb45-1073"><a href="#cb45-1073" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1074"><a href="#cb45-1074" aria-hidden="true" tabindex="-1"></a><span class="st">:::</span></span>
<span id="cb45-1075"><a href="#cb45-1075" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1076"><a href="#cb45-1076" aria-hidden="true" tabindex="-1"></a><span class="st">## Simulation {#sec-package-simulation}</span></span>
<span id="cb45-1077"><a href="#cb45-1077" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1078"><a href="#cb45-1078" aria-hidden="true" tabindex="-1"></a><span class="st">The simulation of the IBM is based on the algorithms presented in @sec-simulation-algo and @sec-simulation-randomized.</span></span>
<span id="cb45-1079"><a href="#cb45-1079" aria-hidden="true" tabindex="-1"></a><span class="st">The user has first to specify bounds for the intensity or interaction functions of each event type. The random evolution of the population can then be simulated over a period of time $[0,T]$ by calling the function `popsim`.</span></span>
<span id="cb45-1080"><a href="#cb45-1080" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1081"><a href="#cb45-1081" aria-hidden="true" tabindex="-1"></a><span class="st">_Events bounds_</span></span>
<span id="cb45-1082"><a href="#cb45-1082" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1083"><a href="#cb45-1083" aria-hidden="true" tabindex="-1"></a><span class="st">Since the IBM simulation algorithm is based on an acceptance-rejection method for simulating random times, the user has to specify bounds for the intensity (or interaction) functions of each event (see @cnj-intensity1 and @cnj-intensity2).</span></span>
<span id="cb45-1084"><a href="#cb45-1084" aria-hidden="true" tabindex="-1"></a><span class="st">These bounds should be stored in a named vector, where for event $e$, the name corresponding to the event bound $</span><span class="sc">\b</span><span class="st">ar{\mu}^e$, $</span><span class="sc">\b</span><span class="st">ar{\lambda}^e$ or $</span><span class="sc">\b</span><span class="st">ar{W}^e$ is the event `name` defined during the event creation step.</span></span>
<span id="cb45-1085"><a href="#cb45-1085" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1086"><a href="#cb45-1086" aria-hidden="true" tabindex="-1"></a><span class="st">In @exm-model-creation from previous section the intensity bound for birth events is $</span><span class="sc">\b</span><span class="st">ar\lambda_b$. Since the death intensity function is not bounded, the user will have to specify a maximum age $a_{\max}$ in `popsim` (all individuals above $a_{\max}$ die automatically). Then, the bound for death events is $</span><span class="sc">\b</span><span class="st">ar \lambda_d = </span><span class="sc">\a</span><span class="st">lpha</span><span class="sc">\e</span><span class="st">xp(</span><span class="sc">\b</span><span class="st">eta a_{\max}).$ </span></span>
<span id="cb45-1087"><a href="#cb45-1087" aria-hidden="true" tabindex="-1"></a><span class="st">In the example, the death event has been named `my_death_event`. No name has been specified for the birth event which thus has the default name `birth`. Then,</span></span>
<span id="cb45-1090"><a href="#cb45-1090" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1091"><a href="#cb45-1091" aria-hidden="true" tabindex="-1"></a><span class="st">#| eval: false</span></span>
<span id="cb45-1092"><a href="#cb45-1092" aria-hidden="true" tabindex="-1"></a><span class="st">a_max &lt;- 120 # maximum age</span></span>
<span id="cb45-1093"><a href="#cb45-1093" aria-hidden="true" tabindex="-1"></a><span class="st">events_bounds &lt;- c("</span>my_death_event<span class="st">" = params$death_rate(a_max),</span></span>
<span id="cb45-1094"><a href="#cb45-1094" aria-hidden="true" tabindex="-1"></a><span class="st">                   "</span>birth<span class="st">" = max(params$birth_rate))</span></span>
<span id="cb45-1095"><a href="#cb45-1095" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1096"><a href="#cb45-1096" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1097"><a href="#cb45-1097" aria-hidden="true" tabindex="-1"></a><span class="st">Once the model and events bounds have been defined, a random trajectory of the population can be simulated by calling</span></span>
<span id="cb45-1100"><a href="#cb45-1100" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1101"><a href="#cb45-1101" aria-hidden="true" tabindex="-1"></a><span class="st">#| eval: false</span></span>
<span id="cb45-1102"><a href="#cb45-1102" aria-hidden="true" tabindex="-1"></a><span class="st">sim_out &lt;- popsim(model, pop, events_bounds, params,</span></span>
<span id="cb45-1103"><a href="#cb45-1103" aria-hidden="true" tabindex="-1"></a><span class="st">                  age_max = a_max, time = 30)</span></span>
<span id="cb45-1104"><a href="#cb45-1104" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1105"><a href="#cb45-1105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1106"><a href="#cb45-1106" aria-hidden="true" tabindex="-1"></a><span class="st">_Optional parameters_ </span></span>
<span id="cb45-1107"><a href="#cb45-1107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1108"><a href="#cb45-1108" aria-hidden="true" tabindex="-1"></a><span class="st">If there are no events with intensity of class `interaction`, then the</span></span>
<span id="cb45-1109"><a href="#cb45-1109" aria-hidden="true" tabindex="-1"></a><span class="st">simulation can be parallelized easily by setting the optional parameter</span></span>
<span id="cb45-1110"><a href="#cb45-1110" aria-hidden="true" tabindex="-1"></a><span class="st">`multithreading` (`FALSE` by default) to `TRUE`. By default, the number</span></span>
<span id="cb45-1111"><a href="#cb45-1111" aria-hidden="true" tabindex="-1"></a><span class="st">of threads is the number of concurrent threads supported by the</span></span>
<span id="cb45-1112"><a href="#cb45-1112" aria-hidden="true" tabindex="-1"></a><span class="st">available hardware implementation. The number of threads can be set</span></span>
<span id="cb45-1113"><a href="#cb45-1113" aria-hidden="true" tabindex="-1"></a><span class="st">manually with the optional argument `num_threads`. By default, when the</span></span>
<span id="cb45-1114"><a href="#cb45-1114" aria-hidden="true" tabindex="-1"></a><span class="st">proportion of dead individuals in the population exceeds $10\%$, dead</span></span>
<span id="cb45-1115"><a href="#cb45-1115" aria-hidden="true" tabindex="-1"></a><span class="st">individuals are removed from the current population used in the</span></span>
<span id="cb45-1116"><a href="#cb45-1116" aria-hidden="true" tabindex="-1"></a><span class="st">algorithm (see @rem-remvoval-dead). The user can modify this</span></span>
<span id="cb45-1117"><a href="#cb45-1117" aria-hidden="true" tabindex="-1"></a><span class="st">ratio using the optional argument `clean_ratio`, or by removing dead</span></span>
<span id="cb45-1118"><a href="#cb45-1118" aria-hidden="true" tabindex="-1"></a><span class="st">individuals from the population with a certain frequency, given by the</span></span>
<span id="cb45-1119"><a href="#cb45-1119" aria-hidden="true" tabindex="-1"></a><span class="st">`clean_step` argument. Finally, the user can also define the seed of the</span></span>
<span id="cb45-1120"><a href="#cb45-1120" aria-hidden="true" tabindex="-1"></a><span class="st">random number generator stored in the argument `seed`.</span></span>
<span id="cb45-1121"><a href="#cb45-1121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1122"><a href="#cb45-1122" aria-hidden="true" tabindex="-1"></a><span class="st">_Outputs and treatment of swap events_</span></span>
<span id="cb45-1123"><a href="#cb45-1123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1124"><a href="#cb45-1124" aria-hidden="true" tabindex="-1"></a><span class="st">The output of the `popsim` function is a list containing three elements:</span></span>
<span id="cb45-1125"><a href="#cb45-1125" aria-hidden="true" tabindex="-1"></a><span class="st">a data frame `population` containing the output population $Z_T$ (or a</span></span>
<span id="cb45-1126"><a href="#cb45-1126" aria-hidden="true" tabindex="-1"></a><span class="st">list of populations $(Z_{t_1}, \dots Z_{t_n})$ if `time` is a vector of</span></span>
<span id="cb45-1127"><a href="#cb45-1127" aria-hidden="true" tabindex="-1"></a><span class="st">times), a numeric vector `logs` of variables related to the simulation</span></span>
<span id="cb45-1128"><a href="#cb45-1128" aria-hidden="true" tabindex="-1"></a><span class="st">algorithm (including the simulation time and number of proposed/accepted</span></span>
<span id="cb45-1129"><a href="#cb45-1129" aria-hidden="true" tabindex="-1"></a><span class="st">events), and the list `arguments` of the simulation inputs, including</span></span>
<span id="cb45-1130"><a href="#cb45-1130" aria-hidden="true" tabindex="-1"></a><span class="st">the initial population, parameters and event bounds used for the</span></span>
<span id="cb45-1131"><a href="#cb45-1131" aria-hidden="true" tabindex="-1"></a><span class="st">simulation.</span></span>
<span id="cb45-1132"><a href="#cb45-1132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1133"><a href="#cb45-1133" aria-hidden="true" tabindex="-1"></a><span class="st">When there are no swap events (individuals don't change of</span></span>
<span id="cb45-1134"><a href="#cb45-1134" aria-hidden="true" tabindex="-1"></a><span class="st">characteristics), the evolution of the population over the period</span></span>
<span id="cb45-1135"><a href="#cb45-1135" aria-hidden="true" tabindex="-1"></a><span class="st">$[0,T]$ is recorded in a single data frame `sim_out$population` where</span></span>
<span id="cb45-1136"><a href="#cb45-1136" aria-hidden="true" tabindex="-1"></a><span class="st">each line contains the information of an individual who lived in the</span></span>
<span id="cb45-1137"><a href="#cb45-1137" aria-hidden="true" tabindex="-1"></a><span class="st">population over the period $[0,T]$ (see @rem-popfinale).</span></span>
<span id="cb45-1138"><a href="#cb45-1138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1139"><a href="#cb45-1139" aria-hidden="true" tabindex="-1"></a><span class="st">When there are swap events (individuals can change of characteristics),</span></span>
<span id="cb45-1140"><a href="#cb45-1140" aria-hidden="true" tabindex="-1"></a><span class="st">recording the dates of swap events and changes of characteristics</span></span>
<span id="cb45-1141"><a href="#cb45-1141" aria-hidden="true" tabindex="-1"></a><span class="st">following each swap event and for each individual in the population is a</span></span>
<span id="cb45-1142"><a href="#cb45-1142" aria-hidden="true" tabindex="-1"></a><span class="st">memory intensive and computationally costly process. To maintain</span></span>
<span id="cb45-1143"><a href="#cb45-1143" aria-hidden="true" tabindex="-1"></a><span class="st">efficient simulations in the presence of swap events, the argument</span></span>
<span id="cb45-1144"><a href="#cb45-1144" aria-hidden="true" tabindex="-1"></a><span class="st">`time` of `popsim` can be defined as a vector of dates</span></span>
<span id="cb45-1145"><a href="#cb45-1145" aria-hidden="true" tabindex="-1"></a><span class="st">$(t_0,\dots, t_n)$. In this case, `popsim` returns in the object</span></span>
<span id="cb45-1146"><a href="#cb45-1146" aria-hidden="true" tabindex="-1"></a><span class="st">`population` a list of $n$ populations representing the population at</span></span>
<span id="cb45-1147"><a href="#cb45-1147" aria-hidden="true" tabindex="-1"></a><span class="st">time $t_1,\dots t_n$, simulated from the initial time $t_0$. For</span></span>
<span id="cb45-1148"><a href="#cb45-1148" aria-hidden="true" tabindex="-1"></a><span class="st">$i=1\dots n$, the $i$th data frame is the population $Z_{t_i}$, i.e.</span></span>
<span id="cb45-1149"><a href="#cb45-1149" aria-hidden="true" tabindex="-1"></a><span class="st">individuals who lived in the population during the period $[t_0,t_i]$,</span></span>
<span id="cb45-1150"><a href="#cb45-1150" aria-hidden="true" tabindex="-1"></a><span class="st">with their characteristics at time $t_i$.</span></span>
<span id="cb45-1151"><a href="#cb45-1151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1152"><a href="#cb45-1152" aria-hidden="true" tabindex="-1"></a><span class="st">It is also possible to isolate the individuals' life course, by adding</span></span>
<span id="cb45-1153"><a href="#cb45-1153" aria-hidden="true" tabindex="-1"></a><span class="st">an `id` column to the population, which can be done by setting `id=TRUE`</span></span>
<span id="cb45-1154"><a href="#cb45-1154" aria-hidden="true" tabindex="-1"></a><span class="st">in the population construction, or by calling the `add_characteristic`</span></span>
<span id="cb45-1155"><a href="#cb45-1155" aria-hidden="true" tabindex="-1"></a><span class="st">function to an existing population, in order to identify each individual</span></span>
<span id="cb45-1156"><a href="#cb45-1156" aria-hidden="true" tabindex="-1"></a><span class="st">with a unique integer.</span></span>
<span id="cb45-1157"><a href="#cb45-1157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1158"><a href="#cb45-1158" aria-hidden="true" tabindex="-1"></a><span class="st">Base functions to study the simulation outputs are provided in the</span></span>
<span id="cb45-1159"><a href="#cb45-1159" aria-hidden="true" tabindex="-1"></a><span class="st">package. For instance, the population age pyramid can computed at a given</span></span>
<span id="cb45-1160"><a href="#cb45-1160" aria-hidden="true" tabindex="-1"></a><span class="st">time, as well as death and exposure tables. Several illustrations of the</span></span>
<span id="cb45-1161"><a href="#cb45-1161" aria-hidden="true" tabindex="-1"></a><span class="st">outputs functions are given in the example @sec-insurance-portfolio and</span></span>
<span id="cb45-1162"><a href="#cb45-1162" aria-hidden="true" tabindex="-1"></a><span class="st">@sec-example-interaction.</span></span>
<span id="cb45-1163"><a href="#cb45-1163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1164"><a href="#cb45-1164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1165"><a href="#cb45-1165" aria-hidden="true" tabindex="-1"></a><span class="st"># Insurance portfolio {#sec-insurance-portfolio}</span></span>
<span id="cb45-1166"><a href="#cb45-1166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1167"><a href="#cb45-1167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1168"><a href="#cb45-1168" aria-hidden="true" tabindex="-1"></a><span class="st">This section provides an example of how to use the `IBMPopSim` package to simulate a heterogeneous life insurance portfolio (see also&nbsp;[`vignette(IBMPopSim_insurance_portfolio)`](https://daphnegiorgi.github.io/IBMPopSim/articles/IBMPopSim_insurance_portfolio.html)).</span></span>
<span id="cb45-1169"><a href="#cb45-1169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1170"><a href="#cb45-1170" aria-hidden="true" tabindex="-1"></a><span class="st">We consider an insurance portfolio consisting of male policyholders, of age greater than 65. These policyholders are characterized by their age, assumed to be less than $a_{\max} = 110$, and risk class $x \in \mathcal X = \{1, 2\}$.</span></span>
<span id="cb45-1171"><a href="#cb45-1171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1172"><a href="#cb45-1172" aria-hidden="true" tabindex="-1"></a><span class="st">**Entries in the portfolio** New policyholders enter the population at a constant Poisson rate $\mu^{en}=\lambda$, which means that on average, $\lambda$ individuals enter the portfolio each year. A new individual enters the population at an age a that is uniformly distributed between 65 and 70, and is in risk class 1 with probability $p$.</span></span>
<span id="cb45-1173"><a href="#cb45-1173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1174"><a href="#cb45-1174" aria-hidden="true" tabindex="-1"></a><span class="st">**Death events** A baseline age and time specific death rate is first</span></span>
<span id="cb45-1175"><a href="#cb45-1175" aria-hidden="true" tabindex="-1"></a><span class="st">calibrated on "</span>England and <span class="fu">Wales</span> (EW)<span class="st">" males mortality historic</span></span>
<span id="cb45-1176"><a href="#cb45-1176" aria-hidden="true" tabindex="-1"></a><span class="st">data (source: Human Mortality Database&nbsp;&lt;https://www.mortality.org/&gt;), and projected for 30 years using the Lee-Carter model with the</span></span>
<span id="cb45-1177"><a href="#cb45-1177" aria-hidden="true" tabindex="-1"></a><span class="st">package `StMoMo` (see&nbsp;@stmomo). The forecasted baseline death</span></span>
<span id="cb45-1178"><a href="#cb45-1178" aria-hidden="true" tabindex="-1"></a><span class="st">intensity is denoted by $d(t,a)$, defined by:</span></span>
<span id="cb45-1179"><a href="#cb45-1179" aria-hidden="true" tabindex="-1"></a><span class="st">$$</span></span>
<span id="cb45-1180"><a href="#cb45-1180" aria-hidden="true" tabindex="-1"></a><span class="st">d(t,a) = \sum_{k=0}^{29}\mathbf{1}_{\{k\leq t &lt; k+1\}} d_k(a), \quad </span><span class="sc">\f</span><span class="st">orall \; t\in [0,30] </span><span class="sc">\t</span><span class="st">ext{ and } a \in [65, a_{\max}],</span></span>
<span id="cb45-1181"><a href="#cb45-1181" aria-hidden="true" tabindex="-1"></a><span class="st">$$ {#eq-insurance-baseline}</span></span>
<span id="cb45-1182"><a href="#cb45-1182" aria-hidden="true" tabindex="-1"></a><span class="st">with $d_k(a)$ the point estimate of the forecasted mortality rate for</span></span>
<span id="cb45-1183"><a href="#cb45-1183" aria-hidden="true" tabindex="-1"></a><span class="st">age $a$ and year $k$.\</span></span>
<span id="cb45-1184"><a href="#cb45-1184" aria-hidden="true" tabindex="-1"></a><span class="st">Individuals in risk class 1 are assumed to have mortality rates that are</span></span>
<span id="cb45-1185"><a href="#cb45-1185" aria-hidden="true" tabindex="-1"></a><span class="st">20% higher than the baseline mortality (for instance, the risk class</span></span>
<span id="cb45-1186"><a href="#cb45-1186" aria-hidden="true" tabindex="-1"></a><span class="st">could refer to smokers), while individuals in risk class 2 are assumed</span></span>
<span id="cb45-1187"><a href="#cb45-1187" aria-hidden="true" tabindex="-1"></a><span class="st">to have mortality rates that are 20% lower than the baseline (non</span></span>
<span id="cb45-1188"><a href="#cb45-1188" aria-hidden="true" tabindex="-1"></a><span class="st">smokers). The death intensity of an individual $I= (</span><span class="sc">\t</span><span class="st">au_b, \infty, x)$,</span></span>
<span id="cb45-1189"><a href="#cb45-1189" aria-hidden="true" tabindex="-1"></a><span class="st">of age $a(I,t) = t - </span><span class="sc">\t</span><span class="st">au_b$ at time $t$ and in risk class</span></span>
<span id="cb45-1190"><a href="#cb45-1190" aria-hidden="true" tabindex="-1"></a><span class="st">$x \in \{1, 2\}$ is thus the function $$</span></span>
<span id="cb45-1191"><a href="#cb45-1191" aria-hidden="true" tabindex="-1"></a><span class="st">\lambda^d(t,I) = </span><span class="sc">\a</span><span class="st">lpha_x d(t,a(I,t)), \quad </span><span class="sc">\a</span><span class="st">lpha_1 = 1.2, \quad </span><span class="sc">\a</span><span class="st">lpha_2 = 0.8.</span></span>
<span id="cb45-1192"><a href="#cb45-1192" aria-hidden="true" tabindex="-1"></a><span class="st">$$</span></span>
<span id="cb45-1193"><a href="#cb45-1193" aria-hidden="true" tabindex="-1"></a><span class="st">In particular, the death intensity verifies @cnj-intensity2 since:</span></span>
<span id="cb45-1194"><a href="#cb45-1194" aria-hidden="true" tabindex="-1"></a><span class="st">$$</span></span>
<span id="cb45-1195"><a href="#cb45-1195" aria-hidden="true" tabindex="-1"></a><span class="st">\lambda^d(t,I) \leq </span><span class="sc">\b</span><span class="st">ar d : = </span><span class="sc">\a</span><span class="st">lpha_1 \sup_{t \in [0,30]} d(t,a_{\max}).</span></span>
<span id="cb45-1196"><a href="#cb45-1196" aria-hidden="true" tabindex="-1"></a><span class="st">$$ {#eq-insurance-bound-deathrates}</span></span>
<span id="cb45-1197"><a href="#cb45-1197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1198"><a href="#cb45-1198" aria-hidden="true" tabindex="-1"></a><span class="st">**Exits from the portfolio** Individuals exit the portfolio at a</span></span>
<span id="cb45-1199"><a href="#cb45-1199" aria-hidden="true" tabindex="-1"></a><span class="st">constant (individual) rate $\lambda^{ex}(t,I) = \mu^{i}$ only depending</span></span>
<span id="cb45-1200"><a href="#cb45-1200" aria-hidden="true" tabindex="-1"></a><span class="st">on their risk class $i\in \{1,2\}$.</span></span>
<span id="cb45-1201"><a href="#cb45-1201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1202"><a href="#cb45-1202" aria-hidden="true" tabindex="-1"></a><span class="st">## Population {#insurance-population}</span></span>
<span id="cb45-1203"><a href="#cb45-1203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1204"><a href="#cb45-1204" aria-hidden="true" tabindex="-1"></a><span class="st">We start with an initial population of $30\,000$ males of age 65,</span></span>
<span id="cb45-1205"><a href="#cb45-1205" aria-hidden="true" tabindex="-1"></a><span class="st">distributed uniformly in each risk class. The population data frame has</span></span>
<span id="cb45-1206"><a href="#cb45-1206" aria-hidden="true" tabindex="-1"></a><span class="st">thus the two (mandatory) columns `birth` (here the initial time is</span></span>
<span id="cb45-1207"><a href="#cb45-1207" aria-hidden="true" tabindex="-1"></a><span class="st">$t_0=0$) and `death` (`NA` if alive), and an additional column</span></span>
<span id="cb45-1208"><a href="#cb45-1208" aria-hidden="true" tabindex="-1"></a><span class="st">`risk_cls` corresponding to the policyholders risk class. Since there</span></span>
<span id="cb45-1209"><a href="#cb45-1209" aria-hidden="true" tabindex="-1"></a><span class="st">are entry and exit events, the `entry` and `out` flags of the population</span></span>
<span id="cb45-1210"><a href="#cb45-1210" aria-hidden="true" tabindex="-1"></a><span class="st">constructor are set to `TRUE`.</span></span>
<span id="cb45-1211"><a href="#cb45-1211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1214"><a href="#cb45-1214" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1215"><a href="#cb45-1215" aria-hidden="true" tabindex="-1"></a><span class="st">N &lt;- 30000</span></span>
<span id="cb45-1216"><a href="#cb45-1216" aria-hidden="true" tabindex="-1"></a><span class="st">pop_df &lt;- data.frame("</span>birth<span class="st">" = rep(-65,N), "</span>death<span class="st">" = rep(NA,N),</span></span>
<span id="cb45-1217"><a href="#cb45-1217" aria-hidden="true" tabindex="-1"></a><span class="st">                     "</span>risk_cls<span class="st">" = rep(1:2,each=N/2))</span></span>
<span id="cb45-1218"><a href="#cb45-1218" aria-hidden="true" tabindex="-1"></a><span class="st">pop_init &lt;- population(pop_df, entry=TRUE, out=TRUE)</span></span>
<span id="cb45-1219"><a href="#cb45-1219" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1220"><a href="#cb45-1220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1221"><a href="#cb45-1221" aria-hidden="true" tabindex="-1"></a><span class="st">## Events {#insurance-events}</span></span>
<span id="cb45-1222"><a href="#cb45-1222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1223"><a href="#cb45-1223" aria-hidden="true" tabindex="-1"></a><span class="st">**Entry events** The age of the new individual is determined by the `kernel_code`</span></span>
<span id="cb45-1224"><a href="#cb45-1224" aria-hidden="true" tabindex="-1"></a><span class="st">argument in the `mk_event_poisson` function.</span></span>
<span id="cb45-1225"><a href="#cb45-1225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1228"><a href="#cb45-1228" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1229"><a href="#cb45-1229" aria-hidden="true" tabindex="-1"></a><span class="st">entry_params &lt;- list("</span>lambda<span class="st">" = 30000, "</span>p<span class="st">" = 0.5)</span></span>
<span id="cb45-1230"><a href="#cb45-1230" aria-hidden="true" tabindex="-1"></a><span class="st">entry_event &lt;- mk_event_poisson(</span></span>
<span id="cb45-1231"><a href="#cb45-1231" aria-hidden="true" tabindex="-1"></a><span class="st">    type = "</span>entry<span class="st">",</span></span>
<span id="cb45-1232"><a href="#cb45-1232" aria-hidden="true" tabindex="-1"></a><span class="st">    intensity = "</span>lambda<span class="st">",</span></span>
<span id="cb45-1233"><a href="#cb45-1233" aria-hidden="true" tabindex="-1"></a><span class="st">    kernel_code = "</span><span class="fu">if</span> (<span class="fu">CUnif</span>() <span class="sc">&lt;</span> p) <span class="at">newI.risk_cls =</span><span class="dv">1</span>;</span>
<span id="cb45-1234"><a href="#cb45-1234" aria-hidden="true" tabindex="-1"></a>                   <span class="cf">else</span> <span class="at">newI.risk_cls=</span> <span class="dv">2</span>;</span>
<span id="cb45-1235"><a href="#cb45-1235" aria-hidden="true" tabindex="-1"></a>                   double <span class="at">a =</span> <span class="fu">CUnif</span>(<span class="dv">65</span>, <span class="dv">70</span>);</span>
<span id="cb45-1236"><a href="#cb45-1236" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">newI.set_age</span>(a, t);<span class="st">")</span></span>
<span id="cb45-1237"><a href="#cb45-1237" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1238"><a href="#cb45-1238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1239"><a href="#cb45-1239" aria-hidden="true" tabindex="-1"></a><span class="st">Note that the variables `newI` and `t`, as well as the function</span></span>
<span id="cb45-1240"><a href="#cb45-1240" aria-hidden="true" tabindex="-1"></a><span class="st">`CUnif()`, are implicitly defined and usable in the `kernel_code`. The</span></span>
<span id="cb45-1241"><a href="#cb45-1241" aria-hidden="true" tabindex="-1"></a><span class="st">field `risk_cls` comes from the names of characteristics of individuals</span></span>
<span id="cb45-1242"><a href="#cb45-1242" aria-hidden="true" tabindex="-1"></a><span class="st">in the population. The names `lambda` and `p` are parameter names that</span></span>
<span id="cb45-1243"><a href="#cb45-1243" aria-hidden="true" tabindex="-1"></a><span class="st">will be specified in the `R` named list `params`.</span></span>
<span id="cb45-1244"><a href="#cb45-1244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1245"><a href="#cb45-1245" aria-hidden="true" tabindex="-1"></a><span class="st">Here we use a constant $\lambda$ as the event intensity, but we could</span></span>
<span id="cb45-1246"><a href="#cb45-1246" aria-hidden="true" tabindex="-1"></a><span class="st">also use a rate $\lambda(t)$ that depends on time, using the function</span></span>
<span id="cb45-1247"><a href="#cb45-1247" aria-hidden="true" tabindex="-1"></a><span class="st">`mk_event_poisson_inhomogeneous`.</span></span>
<span id="cb45-1248"><a href="#cb45-1248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1249"><a href="#cb45-1249" aria-hidden="true" tabindex="-1"></a><span class="st">**Death and exit events** The baseline death intensity defined</span></span>
<span id="cb45-1250"><a href="#cb45-1250" aria-hidden="true" tabindex="-1"></a><span class="st">in @eq-insurance-baseline and obtained with the package</span></span>
<span id="cb45-1251"><a href="#cb45-1251" aria-hidden="true" tabindex="-1"></a><span class="st">`StMoMo` is stored in the variable `death_male`.</span></span>
<span id="cb45-1252"><a href="#cb45-1252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1253"><a href="#cb45-1253" aria-hidden="true" tabindex="-1"></a><span class="st">```{r, results='hide'}</span></span>
<span id="cb45-1254"><a href="#cb45-1254" aria-hidden="true" tabindex="-1"></a><span class="st"># StMoMo death rates</span></span>
<span id="cb45-1255"><a href="#cb45-1255" aria-hidden="true" tabindex="-1"></a><span class="st">library('StMoMo')</span></span>
<span id="cb45-1256"><a href="#cb45-1256" aria-hidden="true" tabindex="-1"></a><span class="st">library('reshape2')</span></span>
<span id="cb45-1257"><a href="#cb45-1257" aria-hidden="true" tabindex="-1"></a><span class="st">EWStMoMoMale &lt;- StMoMoData(EWdata_hmd, series = "</span>male<span class="st">")</span></span>
<span id="cb45-1258"><a href="#cb45-1258" aria-hidden="true" tabindex="-1"></a><span class="st">LC &lt;- lc()</span></span>
<span id="cb45-1259"><a href="#cb45-1259" aria-hidden="true" tabindex="-1"></a><span class="st">ages.fit &lt;- 65:100</span></span>
<span id="cb45-1260"><a href="#cb45-1260" aria-hidden="true" tabindex="-1"></a><span class="st">years.fit &lt;- 1950:2016</span></span>
<span id="cb45-1261"><a href="#cb45-1261" aria-hidden="true" tabindex="-1"></a><span class="st">LCfitMale &lt;- fit(LC, data = EWStMoMoMale, ages.fit = ages.fit, years.fit = years.fit)</span></span>
<span id="cb45-1262"><a href="#cb45-1262" aria-hidden="true" tabindex="-1"></a><span class="st">t &lt;- 30</span></span>
<span id="cb45-1263"><a href="#cb45-1263" aria-hidden="true" tabindex="-1"></a><span class="st">LCforecastMale &lt;- forecast(LCfitMale, h = t)</span></span>
<span id="cb45-1264"><a href="#cb45-1264" aria-hidden="true" tabindex="-1"></a><span class="st">d_k &lt;- apply(LCforecastMale$rates, 2, function(x) stepfun(66:100, x))</span></span>
<span id="cb45-1265"><a href="#cb45-1265" aria-hidden="true" tabindex="-1"></a><span class="st">breaks &lt;- 1:29</span></span>
<span id="cb45-1266"><a href="#cb45-1266" aria-hidden="true" tabindex="-1"></a><span class="st">death_male &lt;- piecewise_xy(breaks,d_k)</span></span>
<span id="cb45-1267"><a href="#cb45-1267" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1268"><a href="#cb45-1268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1269"><a href="#cb45-1269" aria-hidden="true" tabindex="-1"></a><span class="st">The death and exit intensities are of class `individual` (see</span></span>
<span id="cb45-1270"><a href="#cb45-1270" aria-hidden="true" tabindex="-1"></a><span class="st">@tbl-intensity-classes). Hence, the death and exit events</span></span>
<span id="cb45-1271"><a href="#cb45-1271" aria-hidden="true" tabindex="-1"></a><span class="st">are created with the `mk_event_individual` function.</span></span>
<span id="cb45-1272"><a href="#cb45-1272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1275"><a href="#cb45-1275" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1276"><a href="#cb45-1276" aria-hidden="true" tabindex="-1"></a><span class="st">death_params &lt;- list("</span>death_male<span class="st">" = death_male, "</span>alpha<span class="st">" = c(1.2, 0.8))</span></span>
<span id="cb45-1277"><a href="#cb45-1277" aria-hidden="true" tabindex="-1"></a><span class="st">death_event &lt;- mk_event_individual(</span></span>
<span id="cb45-1278"><a href="#cb45-1278" aria-hidden="true" tabindex="-1"></a><span class="st">    type = "</span>death<span class="st">",</span></span>
<span id="cb45-1279"><a href="#cb45-1279" aria-hidden="true" tabindex="-1"></a><span class="st">    intensity_code = "</span><span class="at">result =</span> alpha[I.risk_cls<span class="dv">-1</span>] <span class="sc">*</span> <span class="fu">death_male</span>(t, <span class="fu">I.age</span>(t));<span class="st">")</span></span>
<span id="cb45-1280"><a href="#cb45-1280" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1281"><a href="#cb45-1281" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb45-1284"><a href="#cb45-1284" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1285"><a href="#cb45-1285" aria-hidden="true" tabindex="-1"></a><span class="st">exit_params = list("</span>mu<span class="st">" = c(0.001, 0.06))</span></span>
<span id="cb45-1286"><a href="#cb45-1286" aria-hidden="true" tabindex="-1"></a><span class="st">exit_event &lt;- mk_event_individual(</span></span>
<span id="cb45-1287"><a href="#cb45-1287" aria-hidden="true" tabindex="-1"></a><span class="st">    type = "</span>exit<span class="st">",</span></span>
<span id="cb45-1288"><a href="#cb45-1288" aria-hidden="true" tabindex="-1"></a><span class="st">    intensity_code = "</span><span class="at">result =</span> mu[I.risk_cls<span class="dv">-1</span>]; <span class="st">")</span></span>
<span id="cb45-1289"><a href="#cb45-1289" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1290"><a href="#cb45-1290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1291"><a href="#cb45-1291" aria-hidden="true" tabindex="-1"></a><span class="st">## Model creation and simulation {#insurance-simulation}</span></span>
<span id="cb45-1292"><a href="#cb45-1292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1293"><a href="#cb45-1293" aria-hidden="true" tabindex="-1"></a><span class="st">The model is created from all the previously defined building blocks, by</span></span>
<span id="cb45-1294"><a href="#cb45-1294" aria-hidden="true" tabindex="-1"></a><span class="st">calling the `mk_model`.</span></span>
<span id="cb45-1295"><a href="#cb45-1295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1298"><a href="#cb45-1298" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1299"><a href="#cb45-1299" aria-hidden="true" tabindex="-1"></a><span class="st">model &lt;- mk_model(</span></span>
<span id="cb45-1300"><a href="#cb45-1300" aria-hidden="true" tabindex="-1"></a><span class="st">    characteristics = get_characteristics(pop_init),</span></span>
<span id="cb45-1301"><a href="#cb45-1301" aria-hidden="true" tabindex="-1"></a><span class="st">    events = list(entry_event, death_event, exit_event),</span></span>
<span id="cb45-1302"><a href="#cb45-1302" aria-hidden="true" tabindex="-1"></a><span class="st">    parameters = c(entry_params, death_params, exit_params))</span></span>
<span id="cb45-1303"><a href="#cb45-1303" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1304"><a href="#cb45-1304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1305"><a href="#cb45-1305" aria-hidden="true" tabindex="-1"></a><span class="st">Once the model is compiled, it can be used with different parameters and</span></span>
<span id="cb45-1306"><a href="#cb45-1306" aria-hidden="true" tabindex="-1"></a><span class="st">run simulations for various scenarios. Similarly, the initial population</span></span>
<span id="cb45-1307"><a href="#cb45-1307" aria-hidden="true" tabindex="-1"></a><span class="st">(here `pop_df`) can be modified without rerunning the `mk_model`</span></span>
<span id="cb45-1308"><a href="#cb45-1308" aria-hidden="true" tabindex="-1"></a><span class="st">function. The bounds for entry events is simply the intensity $\lambda$.</span></span>
<span id="cb45-1309"><a href="#cb45-1309" aria-hidden="true" tabindex="-1"></a><span class="st">For death events, the bound is given by $</span><span class="sc">\b</span><span class="st">ar{d}$ defined in</span></span>
<span id="cb45-1310"><a href="#cb45-1310" aria-hidden="true" tabindex="-1"></a><span class="st">@eq-insurance-bound-deathrates, which is stored in the</span></span>
<span id="cb45-1311"><a href="#cb45-1311" aria-hidden="true" tabindex="-1"></a><span class="st">`death_max` variable.</span></span>
<span id="cb45-1312"><a href="#cb45-1312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1315"><a href="#cb45-1315" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1316"><a href="#cb45-1316" aria-hidden="true" tabindex="-1"></a><span class="st">death_max &lt;- max(sapply(d_k, function(x) { max(x) }))</span></span>
<span id="cb45-1317"><a href="#cb45-1317" aria-hidden="true" tabindex="-1"></a><span class="st">bounds &lt;- c("</span>entry<span class="st">" = entry_params$lambda,</span></span>
<span id="cb45-1318"><a href="#cb45-1318" aria-hidden="true" tabindex="-1"></a><span class="st">            "</span>death<span class="st">" = death_max,</span></span>
<span id="cb45-1319"><a href="#cb45-1319" aria-hidden="true" tabindex="-1"></a><span class="st">            "</span>exit<span class="st">" = max(exit_params$mu))</span></span>
<span id="cb45-1320"><a href="#cb45-1320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1321"><a href="#cb45-1321" aria-hidden="true" tabindex="-1"></a><span class="st">sim_out &lt;- popsim(</span></span>
<span id="cb45-1322"><a href="#cb45-1322" aria-hidden="true" tabindex="-1"></a><span class="st">    model = model,</span></span>
<span id="cb45-1323"><a href="#cb45-1323" aria-hidden="true" tabindex="-1"></a><span class="st">    initial_population = pop_init,</span></span>
<span id="cb45-1324"><a href="#cb45-1324" aria-hidden="true" tabindex="-1"></a><span class="st">    events_bounds = bounds,</span></span>
<span id="cb45-1325"><a href="#cb45-1325" aria-hidden="true" tabindex="-1"></a><span class="st">    parameters = c(entry_params, death_params, exit_params),</span></span>
<span id="cb45-1326"><a href="#cb45-1326" aria-hidden="true" tabindex="-1"></a><span class="st">    time = 30,</span></span>
<span id="cb45-1327"><a href="#cb45-1327" aria-hidden="true" tabindex="-1"></a><span class="st">    age_max = 110,</span></span>
<span id="cb45-1328"><a href="#cb45-1328" aria-hidden="true" tabindex="-1"></a><span class="st">    multithreading = TRUE)</span></span>
<span id="cb45-1329"><a href="#cb45-1329" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1330"><a href="#cb45-1330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1331"><a href="#cb45-1331" aria-hidden="true" tabindex="-1"></a><span class="st">## Outputs</span></span>
<span id="cb45-1332"><a href="#cb45-1332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1333"><a href="#cb45-1333" aria-hidden="true" tabindex="-1"></a><span class="st">The data frame `sim_out$population` consists of all individuals present</span></span>
<span id="cb45-1334"><a href="#cb45-1334" aria-hidden="true" tabindex="-1"></a><span class="st">in the portfolio during the period of $[0, 30]$, including the</span></span>
<span id="cb45-1335"><a href="#cb45-1335" aria-hidden="true" tabindex="-1"></a><span class="st">individuals in the initial population and those who entered the</span></span>
<span id="cb45-1336"><a href="#cb45-1336" aria-hidden="true" tabindex="-1"></a><span class="st">portfolio. Each row represents an individual, with their date of birth,</span></span>
<span id="cb45-1337"><a href="#cb45-1337" aria-hidden="true" tabindex="-1"></a><span class="st">date of death (`NA` if still alive at the end of the simulation), risk</span></span>
<span id="cb45-1338"><a href="#cb45-1338" aria-hidden="true" tabindex="-1"></a><span class="st">class, and characteristics `entry` and `out`. Recall that if an</span></span>
<span id="cb45-1339"><a href="#cb45-1339" aria-hidden="true" tabindex="-1"></a><span class="st">individual enters the population at time $t$, his `entry` characteristic</span></span>
<span id="cb45-1340"><a href="#cb45-1340" aria-hidden="true" tabindex="-1"></a><span class="st">is automatically set up to be equal to $t$. The characteristics `out` is</span></span>
<span id="cb45-1341"><a href="#cb45-1341" aria-hidden="true" tabindex="-1"></a><span class="st">set to `TRUE` for individuals who left the portfolio due to an exit</span></span>
<span id="cb45-1342"><a href="#cb45-1342" aria-hidden="true" tabindex="-1"></a><span class="st">event.</span></span>
<span id="cb45-1343"><a href="#cb45-1343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1344"><a href="#cb45-1344" aria-hidden="true" tabindex="-1"></a><span class="st">In this example, the simulation time over 30 years, starting from an</span></span>
<span id="cb45-1345"><a href="#cb45-1345" aria-hidden="true" tabindex="-1"></a><span class="st">initial population of 30 000 individuals is very fast (see below), for an acceptance rate of proposed event of approximately 25%.</span></span>
<span id="cb45-1346"><a href="#cb45-1346" aria-hidden="true" tabindex="-1"></a><span class="st">At the end of the simulation, the number of alive individuals is</span></span>
<span id="cb45-1347"><a href="#cb45-1347" aria-hidden="true" tabindex="-1"></a><span class="st">approximately 430 000.</span></span>
<span id="cb45-1348"><a href="#cb45-1348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1349"><a href="#cb45-1349" aria-hidden="true" tabindex="-1"></a><span class="st">```{r, echo=FALSE}</span></span>
<span id="cb45-1350"><a href="#cb45-1350" aria-hidden="true" tabindex="-1"></a><span class="st">print(paste("</span>Number of alive individuals <span class="cf">in</span> the population at final time <span class="at">T=</span><span class="dv">30</span> <span class="sc">:</span> <span class="st">" ,dim(population_alive(sim_out$population,t = 30))[1], sep="")) </span></span>
<span id="cb45-1351"><a href="#cb45-1351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1352"><a href="#cb45-1352" aria-hidden="true" tabindex="-1"></a><span class="st">print(paste("</span>Execution time <span class="sc">:</span> <span class="st">", format(sim_out$logs[["</span>duration_ns<span class="st">"]]/1e9,digits = 2), "</span>s<span class="st">", sep="")) </span></span>
<span id="cb45-1353"><a href="#cb45-1353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1354"><a href="#cb45-1354" aria-hidden="true" tabindex="-1"></a><span class="st">print(paste("</span>Proportion of effective events and proposed events <span class="sc">:</span> <span class="st">", format(sim_out$logs[["</span>effective_events<span class="st">"]] / sim_out$logs[["</span>proposed_events<span class="st">"]], digits=2), sep="")) </span></span>
<span id="cb45-1355"><a href="#cb45-1355" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1356"><a href="#cb45-1356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1357"><a href="#cb45-1357" aria-hidden="true" tabindex="-1"></a><span class="st">Initially in the portfolio (at $t=0$), there is the same number of 65</span></span>
<span id="cb45-1358"><a href="#cb45-1358" aria-hidden="true" tabindex="-1"></a><span class="st">years old policyholders in each risk class. However, policyholders in</span></span>
<span id="cb45-1359"><a href="#cb45-1359" aria-hidden="true" tabindex="-1"></a><span class="st">the risk class 2 with lower mortality rates leave the portfolio at</span></span>
<span id="cb45-1360"><a href="#cb45-1360" aria-hidden="true" tabindex="-1"></a><span class="st">higher rate than policyholders in the risk class 1 : $\mu^2 &gt; \mu^1$.</span></span>
<span id="cb45-1361"><a href="#cb45-1361" aria-hidden="true" tabindex="-1"></a><span class="st">Therefore, the heterogeneous portfolio composition changes with time,</span></span>
<span id="cb45-1362"><a href="#cb45-1362" aria-hidden="true" tabindex="-1"></a><span class="st">including more and more individuals in risk class 1 with higher</span></span>
<span id="cb45-1363"><a href="#cb45-1363" aria-hidden="true" tabindex="-1"></a><span class="st">mortality rates, but with variations across age classes. To illustrate</span></span>
<span id="cb45-1364"><a href="#cb45-1364" aria-hidden="true" tabindex="-1"></a><span class="st">the composition of the total population at the end of the simulation</span></span>
<span id="cb45-1365"><a href="#cb45-1365" aria-hidden="true" tabindex="-1"></a><span class="st">($t=30$), we present in @fig-insur-a the age pyramid of the final composition of</span></span>
<span id="cb45-1366"><a href="#cb45-1366" aria-hidden="true" tabindex="-1"></a><span class="st">the portfolio obtained with the `age_pyramid` and `plot` functions of the</span></span>
<span id="cb45-1367"><a href="#cb45-1367" aria-hidden="true" tabindex="-1"></a><span class="st">`pyramid` class.</span></span>
<span id="cb45-1368"><a href="#cb45-1368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1369"><a href="#cb45-1369" aria-hidden="true" tabindex="-1"></a><span class="st">```{r, echo=FALSE, fig.width=8}</span></span>
<span id="cb45-1370"><a href="#cb45-1370" aria-hidden="true" tabindex="-1"></a><span class="st">#| label: fig-insur-a</span></span>
<span id="cb45-1371"><a href="#cb45-1371" aria-hidden="true" tabindex="-1"></a><span class="st">#| fig-cap: "</span>Portfolio age pyramid at <span class="at">t =</span> <span class="dv">30</span> <span class="cf">for</span> individuals <span class="cf">in</span> risk class <span class="dv">1</span> (blue) and <span class="dv">2</span> (red).<span class="st">"</span></span>
<span id="cb45-1372"><a href="#cb45-1372" aria-hidden="true" tabindex="-1"></a><span class="st">#| fig-pos: 'H'</span></span>
<span id="cb45-1373"><a href="#cb45-1373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1374"><a href="#cb45-1374" aria-hidden="true" tabindex="-1"></a><span class="st"># Age pyramid (Figure 2(a))</span></span>
<span id="cb45-1375"><a href="#cb45-1375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1376"><a href="#cb45-1376" aria-hidden="true" tabindex="-1"></a><span class="st">age_grp &lt;- 65:98</span></span>
<span id="cb45-1377"><a href="#cb45-1377" aria-hidden="true" tabindex="-1"></a><span class="st">pyr = age_pyramid(sim_out$population, time = 30, ages=age_grp)</span></span>
<span id="cb45-1378"><a href="#cb45-1378" aria-hidden="true" tabindex="-1"></a><span class="st">colnames(pyr)[2]&lt;- "</span>group_name<span class="st">"</span></span>
<span id="cb45-1379"><a href="#cb45-1379" aria-hidden="true" tabindex="-1"></a><span class="st">pyr$group_name &lt;- as.character(pyr$group_name)</span></span>
<span id="cb45-1380"><a href="#cb45-1380" aria-hidden="true" tabindex="-1"></a><span class="st">colors &lt;- c("</span><span class="dv">1</span><span class="st">"="</span><span class="co">#00AFBB","2"="#FC4E07")</span></span>
<span id="cb45-1381"><a href="#cb45-1381" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(pyr,colors,<span class="at">age_breaks =</span> <span class="fu">as.integer</span>(<span class="fu">seq</span>(<span class="dv">1</span>,<span class="fu">length</span>(age_grp)<span class="sc">-</span><span class="dv">1</span>,<span class="at">by=</span><span class="dv">2</span>)))</span>
<span id="cb45-1382"><a href="#cb45-1382" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1383"><a href="#cb45-1383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1384"><a href="#cb45-1384" aria-hidden="true" tabindex="-1"></a><span class="st">`</span>IBMPopSim<span class="st">`</span><span class="at"> also allows the fast computation of exact life tables from</span></span>
<span id="cb45-1385"><a href="#cb45-1385" aria-hidden="true" tabindex="-1"></a><span class="at">truncated and censored individual data (due to entry and exit events),</span></span>
<span id="cb45-1386"><a href="#cb45-1386" aria-hidden="true" tabindex="-1"></a><span class="at">using the functions </span><span class="st">`</span>death_table<span class="st">`</span><span class="at"> and </span><span class="st">`</span>exposure_table<span class="st">`</span><span class="at">. These function</span></span>
<span id="cb45-1387"><a href="#cb45-1387" aria-hidden="true" tabindex="-1"></a><span class="at">are particularly efficient, since the computations are made using the</span></span>
<span id="cb45-1388"><a href="#cb45-1388" aria-hidden="true" tabindex="-1"></a><span class="st">`</span>Rccp<span class="st">`</span><span class="at"> library.</span></span>
<span id="cb45-1389"><a href="#cb45-1389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1392"><a href="#cb45-1392" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1393"><a href="#cb45-1393" aria-hidden="true" tabindex="-1"></a>age_grp <span class="ot">&lt;-</span> <span class="dv">65</span><span class="sc">:</span><span class="dv">95</span></span>
<span id="cb45-1394"><a href="#cb45-1394" aria-hidden="true" tabindex="-1"></a>Dx_pop <span class="ot">&lt;-</span> <span class="fu">death_table</span>(sim_out<span class="sc">$</span>population, <span class="at">ages =</span> age_grp, <span class="at">period =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">30</span>)</span>
<span id="cb45-1395"><a href="#cb45-1395" aria-hidden="true" tabindex="-1"></a>Ex_pop <span class="ot">&lt;-</span> <span class="fu">exposure_table</span>(sim_out<span class="sc">$</span>population, <span class="at">ages =</span> age_grp, <span class="at">period =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">30</span>)</span>
<span id="cb45-1396"><a href="#cb45-1396" aria-hidden="true" tabindex="-1"></a>mx_pop <span class="ot">&lt;-</span> Dx_pop<span class="sc">/</span>Ex_pop</span>
<span id="cb45-1397"><a href="#cb45-1397" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1398"><a href="#cb45-1398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1399"><a href="#cb45-1399" aria-hidden="true" tabindex="-1"></a><span class="at">In @fig-insur-b, we illustrate the central death rates in the</span></span>
<span id="cb45-1400"><a href="#cb45-1400" aria-hidden="true" tabindex="-1"></a><span class="at">simulated portfolio at final time. Due to the mortality differential</span></span>
<span id="cb45-1401"><a href="#cb45-1401" aria-hidden="true" tabindex="-1"></a><span class="at">between risk class 1 and 2, one would expect to observe more individuals</span></span>
<span id="cb45-1402"><a href="#cb45-1402" aria-hidden="true" tabindex="-1"></a><span class="at">in risk class 2 at higher ages. However, due to exit events, a higher</span></span>
<span id="cb45-1403"><a href="#cb45-1403" aria-hidden="true" tabindex="-1"></a><span class="at">proportion of individuals in risk class 1 exit the portfolio over time,</span></span>
<span id="cb45-1404"><a href="#cb45-1404" aria-hidden="true" tabindex="-1"></a><span class="at">resulting in a greater proportion of individuals in risk class 1 at</span></span>
<span id="cb45-1405"><a href="#cb45-1405" aria-hidden="true" tabindex="-1"></a><span class="at">higher ages than what would be expected in the absence of exit events.</span></span>
<span id="cb45-1406"><a href="#cb45-1406" aria-hidden="true" tabindex="-1"></a><span class="at">Consequently, the mortality rates in the portfolio are more aligned with</span></span>
<span id="cb45-1407"><a href="#cb45-1407" aria-hidden="true" tabindex="-1"></a><span class="at">those of risk class 1 at higher ages. This is a simple example of how</span></span>
<span id="cb45-1408"><a href="#cb45-1408" aria-hidden="true" tabindex="-1"></a><span class="at">composition changes in the portfolio can impact aggregated mortality</span></span>
<span id="cb45-1409"><a href="#cb45-1409" aria-hidden="true" tabindex="-1"></a><span class="at">rates and potentially compensate or reduce an overall mortality</span></span>
<span id="cb45-1410"><a href="#cb45-1410" aria-hidden="true" tabindex="-1"></a><span class="at">reduction (see also [@KAAKAI201916]).</span></span>
<span id="cb45-1411"><a href="#cb45-1411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1412"><a href="#cb45-1412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1413"><a href="#cb45-1413" aria-hidden="true" tabindex="-1"></a><span class="st">```</span>{r, echo<span class="ot">=</span><span class="cn">FALSE</span>, results<span class="ot">=</span><span class="cn">FALSE</span>, fig.width<span class="ot">=</span><span class="dv">8</span>}</span>
<span id="cb45-1414"><a href="#cb45-1414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1415"><a href="#cb45-1415" aria-hidden="true" tabindex="-1"></a><span class="co"># Portofolio death rates</span></span>
<span id="cb45-1416"><a href="#cb45-1416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1417"><a href="#cb45-1417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1418"><a href="#cb45-1418" aria-hidden="true" tabindex="-1"></a>Dx <span class="ot">&lt;-</span> <span class="fu">death_table</span>(sim_out<span class="sc">$</span>population[sim_out<span class="sc">$</span>population<span class="sc">$</span>risk_cls<span class="sc">==</span><span class="dv">1</span>,],</span>
<span id="cb45-1419"><a href="#cb45-1419" aria-hidden="true" tabindex="-1"></a>                  <span class="at">ages =</span> age_grp, <span class="at">period =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">30</span>)</span>
<span id="cb45-1420"><a href="#cb45-1420" aria-hidden="true" tabindex="-1"></a>Ex <span class="ot">&lt;-</span> <span class="fu">exposure_table</span>(sim_out<span class="sc">$</span>population[sim_out<span class="sc">$</span>population<span class="sc">$</span>risk_cls<span class="sc">==</span><span class="dv">1</span>,],</span>
<span id="cb45-1421"><a href="#cb45-1421" aria-hidden="true" tabindex="-1"></a>                     <span class="at">ages =</span> age_grp, <span class="at">period =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">30</span>)</span>
<span id="cb45-1422"><a href="#cb45-1422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1423"><a href="#cb45-1423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1424"><a href="#cb45-1424" aria-hidden="true" tabindex="-1"></a>LC <span class="ot">&lt;-</span> <span class="fu">lc</span>()</span>
<span id="cb45-1425"><a href="#cb45-1425" aria-hidden="true" tabindex="-1"></a>LCfitSim1 <span class="ot">&lt;-</span> <span class="fu">fit</span>(LC, <span class="at">Dxt =</span> Dx , <span class="at">Ext =</span> Ex,<span class="at">ages=</span>age_grp[<span class="sc">-</span><span class="fu">length</span>(age_grp)])</span>
<span id="cb45-1426"><a href="#cb45-1426" aria-hidden="true" tabindex="-1"></a>time <span class="ot">&lt;-</span> <span class="dv">30</span></span>
<span id="cb45-1427"><a href="#cb45-1427" aria-hidden="true" tabindex="-1"></a>age <span class="ot">&lt;-</span> age_grp[<span class="sc">-</span><span class="fu">length</span>(age_grp)]</span>
<span id="cb45-1428"><a href="#cb45-1428" aria-hidden="true" tabindex="-1"></a>estimated <span class="ot">&lt;-</span> LCfitSim1<span class="sc">$</span>ax <span class="sc">+</span> LCfitSim1<span class="sc">$</span>bx<span class="sc">*</span>LCfitSim1<span class="sc">$</span>kt[time]</span>
<span id="cb45-1429"><a href="#cb45-1429" aria-hidden="true" tabindex="-1"></a>forecast_1 <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fl">1.3</span><span class="sc">*</span>LCforecastMale<span class="sc">$</span>rates[<span class="dv">1</span><span class="sc">:</span>(<span class="fu">length</span>(age_grp)<span class="sc">-</span><span class="dv">1</span>),time])</span>
<span id="cb45-1430"><a href="#cb45-1430" aria-hidden="true" tabindex="-1"></a>forecast_2 <span class="ot">&lt;-</span> <span class="fu">log</span>(<span class="fl">0.8</span><span class="sc">*</span>LCforecastMale<span class="sc">$</span>rates[<span class="dv">1</span><span class="sc">:</span>(<span class="fu">length</span>(age_grp)<span class="sc">-</span><span class="dv">1</span>),time])</span>
<span id="cb45-1431"><a href="#cb45-1431" aria-hidden="true" tabindex="-1"></a>portfolio <span class="ot">&lt;-</span> <span class="fu">log</span>((mx_pop)[,time])</span>
<span id="cb45-1432"><a href="#cb45-1432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1433"><a href="#cb45-1433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1434"><a href="#cb45-1434" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">age=</span>age, <span class="at">portfolio=</span>portfolio, <span class="at">forecast_1=</span>forecast_1, <span class="at">forecast_1=</span>forecast_2)</span>
<span id="cb45-1435"><a href="#cb45-1435" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(df) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"Age"</span>, <span class="st">"Portfolio"</span>, <span class="st">"Risk class 1"</span>, <span class="st">"Risk class 2"</span>)</span>
<span id="cb45-1436"><a href="#cb45-1436" aria-hidden="true" tabindex="-1"></a>df_melt <span class="ot">&lt;-</span> <span class="fu">melt</span>(df, <span class="at">id=</span><span class="st">"Age"</span>)</span>
<span id="cb45-1437"><a href="#cb45-1437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1438"><a href="#cb45-1438" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1439"><a href="#cb45-1439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1440"><a href="#cb45-1440" aria-hidden="true" tabindex="-1"></a><span class="st">```</span>{r, echo<span class="ot">=</span><span class="cn">FALSE</span>}</span>
<span id="cb45-1441"><a href="#cb45-1441" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-insur-b</span></span>
<span id="cb45-1442"><a href="#cb45-1442" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Portfolio central death rates at t = 30 (black)."</span></span>
<span id="cb45-1443"><a href="#cb45-1443" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 'h'</span></span>
<span id="cb45-1444"><a href="#cb45-1444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1445"><a href="#cb45-1445" aria-hidden="true" tabindex="-1"></a><span class="co"># Figure 2(b)</span></span>
<span id="cb45-1446"><a href="#cb45-1446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1447"><a href="#cb45-1447" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data=</span>df_melt, <span class="fu">aes</span>(<span class="at">x=</span>Age, <span class="at">y=</span>value)) <span class="sc">+</span></span>
<span id="cb45-1448"><a href="#cb45-1448" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color=</span>variable, <span class="at">shape=</span>variable)) <span class="sc">+</span></span>
<span id="cb45-1449"><a href="#cb45-1449" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">color=</span>variable, <span class="at">linetype=</span>variable)) <span class="sc">+</span></span>
<span id="cb45-1450"><a href="#cb45-1450" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Age"</span>) <span class="sc">+</span></span>
<span id="cb45-1451"><a href="#cb45-1451" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">"Log mortality rates"</span>) <span class="sc">+</span></span>
<span id="cb45-1452"><a href="#cb45-1452" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_color_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">"Portfolio"</span> <span class="ot">=</span> <span class="st">"black"</span>, <span class="st">"Risk class 1"</span> <span class="ot">=</span> <span class="st">"blue"</span>, <span class="st">"Risk class 2"</span> <span class="ot">=</span> <span class="st">"red"</span>)) <span class="sc">+</span></span>
<span id="cb45-1453"><a href="#cb45-1453" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_shape_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">"Portfolio"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"Risk class 1"</span> <span class="ot">=</span> <span class="cn">NA</span>, <span class="st">"Risk class 2"</span> <span class="ot">=</span> <span class="cn">NA</span>)) <span class="sc">+</span></span>
<span id="cb45-1454"><a href="#cb45-1454" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_linetype_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">"Portfolio"</span> <span class="ot">=</span> <span class="dv">0</span>, <span class="st">"Risk class 1"</span> <span class="ot">=</span> <span class="dv">2</span>, <span class="st">"Risk class 2"</span> <span class="ot">=</span> <span class="dv">1</span>)) <span class="sc">+</span></span>
<span id="cb45-1455"><a href="#cb45-1455" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.title =</span> <span class="fu">element_blank</span>(), <span class="at">legend.position =</span> <span class="fu">c</span>(<span class="fl">0.9</span>,<span class="fl">0.2</span>), <span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb45-1456"><a href="#cb45-1456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1457"><a href="#cb45-1457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1458"><a href="#cb45-1458" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1459"><a href="#cb45-1459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1460"><a href="#cb45-1460" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1461"><a href="#cb45-1461" aria-hidden="true" tabindex="-1"></a><span class="at"># Population with genetically variable traits {#sec-example-interaction}</span></span>
<span id="cb45-1462"><a href="#cb45-1462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1463"><a href="#cb45-1463" aria-hidden="true" tabindex="-1"></a><span class="at">This section provides an example of how to use the </span><span class="st">`</span>IBMPopSim<span class="st">`</span><span class="at"> package to simulate an age-structured population with interactions, based on the model proposed in Example 1 of @FerTra09 (see also @meleard2009trait).</span></span>
<span id="cb45-1464"><a href="#cb45-1464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1465"><a href="#cb45-1465" aria-hidden="true" tabindex="-1"></a><span class="at">In this model, individuals are characterized by their body size at birth</span></span>
<span id="cb45-1466"><a href="#cb45-1466" aria-hidden="true" tabindex="-1"></a><span class="at">$x_0 \in [0,4]$ and by their physical age $a \in [0,2]$. The body size</span></span>
<span id="cb45-1467"><a href="#cb45-1467" aria-hidden="true" tabindex="-1"></a><span class="at">of an individual $I=(</span><span class="sc">\t</span><span class="at">au^b,\infty, x_0)$ at time $t$ is a linear</span></span>
<span id="cb45-1468"><a href="#cb45-1468" aria-hidden="true" tabindex="-1"></a><span class="at">function of its age $a(I,t) = t-</span><span class="sc">\t</span><span class="at">au^b$: $$x(t)= x_0 + ga(I,t),$$ where</span></span>
<span id="cb45-1469"><a href="#cb45-1469" aria-hidden="true" tabindex="-1"></a><span class="at">$g$ is a constant growth rate assumed to be identical for all</span></span>
<span id="cb45-1470"><a href="#cb45-1470" aria-hidden="true" tabindex="-1"></a><span class="at">individuals.</span></span>
<span id="cb45-1471"><a href="#cb45-1471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1472"><a href="#cb45-1472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1473"><a href="#cb45-1473" aria-hidden="true" tabindex="-1"></a><span class="at">**Birth events** The birth intensity of each individual</span></span>
<span id="cb45-1474"><a href="#cb45-1474" aria-hidden="true" tabindex="-1"></a><span class="at">$I=(</span><span class="sc">\t</span><span class="at">au^b, \infty, x_0)$ depends on a parameter $</span><span class="sc">\a</span><span class="at">lpha &gt; 0$ and on its</span></span>
<span id="cb45-1475"><a href="#cb45-1475" aria-hidden="true" tabindex="-1"></a><span class="at">initial size, as given by the equation</span></span>
<span id="cb45-1476"><a href="#cb45-1476" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1477"><a href="#cb45-1477" aria-hidden="true" tabindex="-1"></a><span class="at">\lambda^b(t,I) = </span><span class="sc">\a</span><span class="at">lpha (4 - x_0) \leq </span><span class="sc">\b</span><span class="at">ar \lambda^b = 4</span><span class="sc">\a</span><span class="at">lpha.</span></span>
<span id="cb45-1478"><a href="#cb45-1478" aria-hidden="true" tabindex="-1"></a><span class="at">$${#eq-interaction-birth-intensity}</span></span>
<span id="cb45-1479"><a href="#cb45-1479" aria-hidden="true" tabindex="-1"></a><span class="at">Thus,</span></span>
<span id="cb45-1480"><a href="#cb45-1480" aria-hidden="true" tabindex="-1"></a><span class="at">smaller individuals have a higher birth intensity. When a birth occurs,</span></span>
<span id="cb45-1481"><a href="#cb45-1481" aria-hidden="true" tabindex="-1"></a><span class="at">the new individual inherits the same birth size $x_0$ as its parent with</span></span>
<span id="cb45-1482"><a href="#cb45-1482" aria-hidden="true" tabindex="-1"></a><span class="at">high probability $1-p$, or a mutation can occur with probability $p$,</span></span>
<span id="cb45-1483"><a href="#cb45-1483" aria-hidden="true" tabindex="-1"></a><span class="at">resulting in a birth size given by</span></span>
<span id="cb45-1484"><a href="#cb45-1484" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1485"><a href="#cb45-1485" aria-hidden="true" tabindex="-1"></a><span class="at">    x_0' = \min(\max(0, x_0 + G), 4),</span></span>
<span id="cb45-1486"><a href="#cb45-1486" aria-hidden="true" tabindex="-1"></a><span class="at">$${#eq-interaction-birth-kernel}</span></span>
<span id="cb45-1487"><a href="#cb45-1487" aria-hidden="true" tabindex="-1"></a><span class="at">where $G$ is a Gaussian random</span></span>
<span id="cb45-1488"><a href="#cb45-1488" aria-hidden="true" tabindex="-1"></a><span class="at">variable with mean 0 and variance $\sigma^2$.</span></span>
<span id="cb45-1489"><a href="#cb45-1489" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1490"><a href="#cb45-1490" aria-hidden="true" tabindex="-1"></a><span class="at">**Death events** Due to competition between individuals, the death</span></span>
<span id="cb45-1491"><a href="#cb45-1491" aria-hidden="true" tabindex="-1"></a><span class="at">intensity of an individual depends on the size of other individuals in</span></span>
<span id="cb45-1492"><a href="#cb45-1492" aria-hidden="true" tabindex="-1"></a><span class="at">the population. Bigger individuals have a better chance of survival. If</span></span>
<span id="cb45-1493"><a href="#cb45-1493" aria-hidden="true" tabindex="-1"></a><span class="at">an individual $I= (</span><span class="sc">\t</span><span class="at">au^b, \infty, x_0)$ of size $x(t)= x_0 +ga(I,t)$</span></span>
<span id="cb45-1494"><a href="#cb45-1494" aria-hidden="true" tabindex="-1"></a><span class="at">encounters an individual $J= (</span><span class="sc">\t</span><span class="at">au^{b}_J, \infty, x_0')$ of size</span></span>
<span id="cb45-1495"><a href="#cb45-1495" aria-hidden="true" tabindex="-1"></a><span class="at">$x'(t) = x_0'+ ga(J,t)$, then it can die with the intensity</span></span>
<span id="cb45-1496"><a href="#cb45-1496" aria-hidden="true" tabindex="-1"></a><span class="at">$$W(t, I,J) = U(x(t),x'(t)),$$ where the interaction function $U$ is</span></span>
<span id="cb45-1497"><a href="#cb45-1497" aria-hidden="true" tabindex="-1"></a><span class="at">defined by </span></span>
<span id="cb45-1498"><a href="#cb45-1498" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1499"><a href="#cb45-1499" aria-hidden="true" tabindex="-1"></a><span class="at">    U(x,y) = </span><span class="sc">\b</span><span class="at">eta \left(1- </span><span class="sc">\f</span><span class="at">rac{1}{1+ c</span><span class="sc">\e</span><span class="at">xp(-4(x-y))}</span><span class="sc">\r</span><span class="at">ight) \leq </span><span class="sc">\b</span><span class="at">ar W = </span><span class="sc">\b</span><span class="at">eta.</span></span>
<span id="cb45-1500"><a href="#cb45-1500" aria-hidden="true" tabindex="-1"></a><span class="at">$${#eq-interaction-death-intensity}</span></span>
<span id="cb45-1501"><a href="#cb45-1501" aria-hidden="true" tabindex="-1"></a><span class="at">The death intensity of an individual $I$ at time $t$ and in a population</span></span>
<span id="cb45-1502"><a href="#cb45-1502" aria-hidden="true" tabindex="-1"></a><span class="at">$Z$ is the result of interactions with all individuals in the</span></span>
<span id="cb45-1503"><a href="#cb45-1503" aria-hidden="true" tabindex="-1"></a><span class="at">population, including itself, and is given by</span></span>
<span id="cb45-1504"><a href="#cb45-1504" aria-hidden="true" tabindex="-1"></a><span class="at">$$\lambda^d_t(I,Z) = \sum_{J = (</span><span class="sc">\t</span><span class="at">au^b,\infty, x_0') \in Z}  W (x_0 + g a(I,t), x_0' + g a(J,t)),$$</span></span>
<span id="cb45-1505"><a href="#cb45-1505" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1506"><a href="#cb45-1506" aria-hidden="true" tabindex="-1"></a><span class="at">## Population</span></span>
<span id="cb45-1507"><a href="#cb45-1507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1508"><a href="#cb45-1508" aria-hidden="true" tabindex="-1"></a><span class="at">We use an initial population of 900 living individuals, all of whom have</span></span>
<span id="cb45-1509"><a href="#cb45-1509" aria-hidden="true" tabindex="-1"></a><span class="at">the same size and ages uniformly distributed between 0 and 2 years.</span></span>
<span id="cb45-1510"><a href="#cb45-1510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1513"><a href="#cb45-1513" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1514"><a href="#cb45-1514" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">900</span> </span>
<span id="cb45-1515"><a href="#cb45-1515" aria-hidden="true" tabindex="-1"></a>x0 <span class="ot">&lt;-</span> <span class="fl">1.06</span></span>
<span id="cb45-1516"><a href="#cb45-1516" aria-hidden="true" tabindex="-1"></a>agemin <span class="ot">&lt;-</span> <span class="fl">0.</span></span>
<span id="cb45-1517"><a href="#cb45-1517" aria-hidden="true" tabindex="-1"></a>agemax <span class="ot">&lt;-</span> <span class="fl">2.</span></span>
<span id="cb45-1518"><a href="#cb45-1518" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1519"><a href="#cb45-1519" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1522"><a href="#cb45-1522" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1523"><a href="#cb45-1523" aria-hidden="true" tabindex="-1"></a>pop_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb45-1524"><a href="#cb45-1524" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth"</span> <span class="ot">=</span> <span class="sc">-</span><span class="fu">runif</span>(N, agemin, agemax), <span class="co"># Uniform age in [0,2]</span></span>
<span id="cb45-1525"><a href="#cb45-1525" aria-hidden="true" tabindex="-1"></a>  <span class="st">"death"</span> <span class="ot">=</span> <span class="fu">as.double</span>(<span class="cn">NA</span>), <span class="co"># All individuals are alive</span></span>
<span id="cb45-1526"><a href="#cb45-1526" aria-hidden="true" tabindex="-1"></a>  <span class="st">"birth_size"</span> <span class="ot">=</span> x0) <span class="co"># All individuals have the same initial birth size x0</span></span>
<span id="cb45-1527"><a href="#cb45-1527" aria-hidden="true" tabindex="-1"></a>pop_init <span class="ot">&lt;-</span> <span class="fu">population</span>(pop_df)</span>
<span id="cb45-1528"><a href="#cb45-1528" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1529"><a href="#cb45-1529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1530"><a href="#cb45-1530" aria-hidden="true" tabindex="-1"></a><span class="at">## Events </span></span>
<span id="cb45-1531"><a href="#cb45-1531" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1532"><a href="#cb45-1532" aria-hidden="true" tabindex="-1"></a><span class="at">### Birth events</span></span>
<span id="cb45-1533"><a href="#cb45-1533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1534"><a href="#cb45-1534" aria-hidden="true" tabindex="-1"></a><span class="at">The parameters involved in a birth event are the probability of mutation</span></span>
<span id="cb45-1535"><a href="#cb45-1535" aria-hidden="true" tabindex="-1"></a><span class="at">$p$, the variance of the Gaussian random variable and the coefficient</span></span>
<span id="cb45-1536"><a href="#cb45-1536" aria-hidden="true" tabindex="-1"></a><span class="at">$</span><span class="sc">\a</span><span class="at">lpha$ of the intensity.</span></span>
<span id="cb45-1539"><a href="#cb45-1539" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1540"><a href="#cb45-1540" aria-hidden="true" tabindex="-1"></a>params_birth <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"p"</span> <span class="ot">=</span> <span class="fl">0.03</span>, <span class="st">"sigma"</span> <span class="ot">=</span> <span class="fu">sqrt</span>(<span class="fl">0.01</span>), <span class="st">"alpha"</span> <span class="ot">=</span> <span class="dv">1</span>)</span>
<span id="cb45-1541"><a href="#cb45-1541" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1542"><a href="#cb45-1542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1543"><a href="#cb45-1543" aria-hidden="true" tabindex="-1"></a><span class="at">The birth</span></span>
<span id="cb45-1544"><a href="#cb45-1544" aria-hidden="true" tabindex="-1"></a><span class="at">intensity @eq-interaction-birth-intensity is of class </span><span class="st">`</span>individual<span class="st">`</span><span class="at">.</span></span>
<span id="cb45-1545"><a href="#cb45-1545" aria-hidden="true" tabindex="-1"></a><span class="at">Hence, the event is created by calling the </span><span class="st">`</span>mk_event_individual<span class="st">`</span></span>
<span id="cb45-1546"><a href="#cb45-1546" aria-hidden="true" tabindex="-1"></a><span class="at">function. The size of the new individual is given in the kernel</span></span>
<span id="cb45-1547"><a href="#cb45-1547" aria-hidden="true" tabindex="-1"></a><span class="at">following @eq-interaction-birth-kernel.</span></span>
<span id="cb45-1548"><a href="#cb45-1548" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1551"><a href="#cb45-1551" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1552"><a href="#cb45-1552" aria-hidden="true" tabindex="-1"></a>birth_event <span class="ot">&lt;-</span> <span class="fu">mk_event_individual</span>( </span>
<span id="cb45-1553"><a href="#cb45-1553" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"birth"</span>,</span>
<span id="cb45-1554"><a href="#cb45-1554" aria-hidden="true" tabindex="-1"></a>  <span class="at">intensity_code =</span> <span class="st">"result = alpha*(4 - I.birth_size);"</span>,</span>
<span id="cb45-1555"><a href="#cb45-1555" aria-hidden="true" tabindex="-1"></a>  <span class="at">kernel_code =</span> <span class="st">"if (CUnif() &lt; p)</span></span>
<span id="cb45-1556"><a href="#cb45-1556" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.birth_size = min(max(0.,CNorm(I.birth_size,sigma)),4.);</span></span>
<span id="cb45-1557"><a href="#cb45-1557" aria-hidden="true" tabindex="-1"></a><span class="st">                 else</span></span>
<span id="cb45-1558"><a href="#cb45-1558" aria-hidden="true" tabindex="-1"></a><span class="st">                   newI.birth_size = I.birth_size;"</span>)</span>
<span id="cb45-1559"><a href="#cb45-1559" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1560"><a href="#cb45-1560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1561"><a href="#cb45-1561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1562"><a href="#cb45-1562" aria-hidden="true" tabindex="-1"></a><span class="at">### Death events</span></span>
<span id="cb45-1563"><a href="#cb45-1563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1564"><a href="#cb45-1564" aria-hidden="true" tabindex="-1"></a><span class="at">The death</span></span>
<span id="cb45-1565"><a href="#cb45-1565" aria-hidden="true" tabindex="-1"></a><span class="at">intensity @eq-interaction-death-intensity is of class </span><span class="st">`</span>interaction<span class="st">`</span><span class="at">.</span></span>
<span id="cb45-1566"><a href="#cb45-1566" aria-hidden="true" tabindex="-1"></a><span class="at">Hence, the event is created by calling the </span><span class="st">`</span>mk_event_interaction<span class="st">`</span></span>
<span id="cb45-1567"><a href="#cb45-1567" aria-hidden="true" tabindex="-1"></a><span class="at">function. The parameters used for this event are the growth rate $g$,</span></span>
<span id="cb45-1568"><a href="#cb45-1568" aria-hidden="true" tabindex="-1"></a><span class="at">the amplitude of the interaction function $</span><span class="sc">\b</span><span class="at">eta$, and the strength of</span></span>
<span id="cb45-1569"><a href="#cb45-1569" aria-hidden="true" tabindex="-1"></a><span class="at">competition $c$.</span></span>
<span id="cb45-1570"><a href="#cb45-1570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1573"><a href="#cb45-1573" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1574"><a href="#cb45-1574" aria-hidden="true" tabindex="-1"></a>params_death <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"g"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"beta"</span> <span class="ot">=</span> <span class="fl">2.</span><span class="sc">/</span><span class="fl">300.</span>, <span class="st">"c"</span> <span class="ot">=</span> <span class="fl">1.2</span>)</span>
<span id="cb45-1575"><a href="#cb45-1575" aria-hidden="true" tabindex="-1"></a>death_event <span class="ot">&lt;-</span> <span class="fu">mk_event_interaction</span>(</span>
<span id="cb45-1576"><a href="#cb45-1576" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb45-1577"><a href="#cb45-1577" aria-hidden="true" tabindex="-1"></a>  <span class="at">interaction_code =</span> <span class="st">"double x_I = I.birth_size + g * age(I,t);</span></span>
<span id="cb45-1578"><a href="#cb45-1578" aria-hidden="true" tabindex="-1"></a><span class="st">                      double x_J = J.birth_size + g * age(J,t);</span></span>
<span id="cb45-1579"><a href="#cb45-1579" aria-hidden="true" tabindex="-1"></a><span class="st">                      result = beta*(1.-1./(1.+c*exp(-4.*(x_I-x_J))));"</span>)</span>
<span id="cb45-1580"><a href="#cb45-1580" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1581"><a href="#cb45-1581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1582"><a href="#cb45-1582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1583"><a href="#cb45-1583" aria-hidden="true" tabindex="-1"></a><span class="at">## Model creation and simulation</span></span>
<span id="cb45-1584"><a href="#cb45-1584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1585"><a href="#cb45-1585" aria-hidden="true" tabindex="-1"></a><span class="at">The model is created using the </span><span class="st">`</span>mk_model<span class="st">`</span><span class="at"> function.</span></span>
<span id="cb45-1586"><a href="#cb45-1586" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1587"><a href="#cb45-1587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1590"><a href="#cb45-1590" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1591"><a href="#cb45-1591" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(</span>
<span id="cb45-1592"><a href="#cb45-1592" aria-hidden="true" tabindex="-1"></a>    <span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb45-1593"><a href="#cb45-1593" aria-hidden="true" tabindex="-1"></a>    <span class="at">events =</span> <span class="fu">list</span>(birth_event, death_event),</span>
<span id="cb45-1594"><a href="#cb45-1594" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death))</span>
<span id="cb45-1595"><a href="#cb45-1595" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1596"><a href="#cb45-1596" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1597"><a href="#cb45-1597" aria-hidden="true" tabindex="-1"></a><span class="at">The simulation of one scenario can then be launched with the call of the </span><span class="st">`</span>popsim<span class="st">`</span><span class="at"> function, after computing the events bounds $</span><span class="sc">\b</span><span class="at">ar \lambda^b=4 </span><span class="sc">\a</span><span class="at">lpha$ and $</span><span class="sc">\b</span><span class="at">ar W= </span><span class="sc">\b</span><span class="at">eta$.</span></span>
<span id="cb45-1598"><a href="#cb45-1598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1601"><a href="#cb45-1601" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1602"><a href="#cb45-1602" aria-hidden="true" tabindex="-1"></a>sim_out <span class="ot">&lt;-</span> <span class="fu">popsim</span>(<span class="at">model =</span> model,</span>
<span id="cb45-1603"><a href="#cb45-1603" aria-hidden="true" tabindex="-1"></a>    <span class="at">initial_population =</span> pop_init,</span>
<span id="cb45-1604"><a href="#cb45-1604" aria-hidden="true" tabindex="-1"></a>    <span class="at">events_bounds =</span> <span class="fu">c</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="dv">4</span> <span class="sc">*</span> params_birth<span class="sc">$</span>alpha, </span>
<span id="cb45-1605"><a href="#cb45-1605" aria-hidden="true" tabindex="-1"></a>                      <span class="st">"death"</span> <span class="ot">=</span> params_death<span class="sc">$</span>beta),</span>
<span id="cb45-1606"><a href="#cb45-1606" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death),</span>
<span id="cb45-1607"><a href="#cb45-1607" aria-hidden="true" tabindex="-1"></a>    <span class="at">age_max =</span> <span class="dv">2</span>,</span>
<span id="cb45-1608"><a href="#cb45-1608" aria-hidden="true" tabindex="-1"></a>    <span class="at">time =</span> <span class="dv">500</span>)</span>
<span id="cb45-1609"><a href="#cb45-1609" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1610"><a href="#cb45-1610" aria-hidden="true" tabindex="-1"></a><span class="at">Based on the results of a simulation, we can reproduce the numerical results of @FerTra09. In @fig-birth-size, we draw a line for each individual in the population to represent their birth size during their lifetime. </span></span>
<span id="cb45-1611"><a href="#cb45-1611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1612"><a href="#cb45-1612" aria-hidden="true" tabindex="-1"></a><span class="st">```</span>{r, echo<span class="ot">=</span><span class="cn">FALSE</span>, fig.width<span class="ot">=</span><span class="dv">8</span>}</span>
<span id="cb45-1613"><a href="#cb45-1613" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-birth-size</span></span>
<span id="cb45-1614"><a href="#cb45-1614" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Evolution of birth size"</span></span>
<span id="cb45-1615"><a href="#cb45-1615" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-pos: 'h'</span></span>
<span id="cb45-1616"><a href="#cb45-1616" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-format: png</span></span>
<span id="cb45-1617"><a href="#cb45-1617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1618"><a href="#cb45-1618" aria-hidden="true" tabindex="-1"></a>pop_out <span class="ot">&lt;-</span> sim_out<span class="sc">$</span>population</span>
<span id="cb45-1619"><a href="#cb45-1619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1620"><a href="#cb45-1620" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(pop_out) <span class="sc">+</span> <span class="fu">geom_segment</span>(</span>
<span id="cb45-1621"><a href="#cb45-1621" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x=</span>birth, <span class="at">xend=</span>death, <span class="at">y=</span>birth_size, <span class="at">yend=</span>birth_size),</span>
<span id="cb45-1622"><a href="#cb45-1622" aria-hidden="true" tabindex="-1"></a>  <span class="at">na.rm=</span><span class="cn">TRUE</span>, <span class="at">colour=</span><span class="st">"blue"</span>, <span class="at">alpha=</span><span class="fl">0.2</span>) <span class="sc">+</span></span>
<span id="cb45-1623"><a href="#cb45-1623" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlab</span>(<span class="st">"Time"</span>) <span class="sc">+</span></span>
<span id="cb45-1624"><a href="#cb45-1624" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylab</span>(<span class="st">"Birth size"</span>)</span>
<span id="cb45-1625"><a href="#cb45-1625" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1626"><a href="#cb45-1626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1627"><a href="#cb45-1627" aria-hidden="true" tabindex="-1"></a><span class="at">In this example, the randomized</span></span>
<span id="cb45-1628"><a href="#cb45-1628" aria-hidden="true" tabindex="-1"></a><span class="at">@alg-randomized allows for much faster computation</span></span>
<span id="cb45-1629"><a href="#cb45-1629" aria-hidden="true" tabindex="-1"></a><span class="at">times than the model implemented below with</span></span>
<span id="cb45-1630"><a href="#cb45-1630" aria-hidden="true" tabindex="-1"></a><span class="at">@alg-interaction ("full" algorithm):</span></span>
<span id="cb45-1631"><a href="#cb45-1631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1634"><a href="#cb45-1634" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb45-1635"><a href="#cb45-1635" aria-hidden="true" tabindex="-1"></a>death_event_full <span class="ot">&lt;-</span> <span class="fu">mk_event_interaction</span>(<span class="at">type =</span> <span class="st">"death"</span>,</span>
<span id="cb45-1636"><a href="#cb45-1636" aria-hidden="true" tabindex="-1"></a>    <span class="at">interaction_type=</span> <span class="st">"full"</span>,</span>
<span id="cb45-1637"><a href="#cb45-1637" aria-hidden="true" tabindex="-1"></a>    <span class="at">interaction_code =</span> <span class="st">"double x_I = I.birth_size + g * age(I,t);</span></span>
<span id="cb45-1638"><a href="#cb45-1638" aria-hidden="true" tabindex="-1"></a><span class="st">                        double x_J = J.birth_size + g * age(J,t);</span></span>
<span id="cb45-1639"><a href="#cb45-1639" aria-hidden="true" tabindex="-1"></a><span class="st">                        result = beta * ( 1.- 1./(1. + c * exp(-4. * (x_I-x_J))));"</span></span>
<span id="cb45-1640"><a href="#cb45-1640" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb45-1641"><a href="#cb45-1641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1642"><a href="#cb45-1642" aria-hidden="true" tabindex="-1"></a>model_full <span class="ot">&lt;-</span> <span class="fu">mk_model</span>(<span class="at">characteristics =</span> <span class="fu">get_characteristics</span>(pop_init),</span>
<span id="cb45-1643"><a href="#cb45-1643" aria-hidden="true" tabindex="-1"></a>    <span class="at">events =</span> <span class="fu">list</span>(birth_event, death_event_full),</span>
<span id="cb45-1644"><a href="#cb45-1644" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death))</span>
<span id="cb45-1645"><a href="#cb45-1645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1646"><a href="#cb45-1646" aria-hidden="true" tabindex="-1"></a>sim_out_full <span class="ot">&lt;-</span> <span class="fu">popsim</span>(<span class="at">model =</span> model_full,</span>
<span id="cb45-1647"><a href="#cb45-1647" aria-hidden="true" tabindex="-1"></a>    <span class="at">initial_population =</span> pop_init,</span>
<span id="cb45-1648"><a href="#cb45-1648" aria-hidden="true" tabindex="-1"></a>    <span class="at">events_bounds =</span><span class="fu">c</span>(<span class="st">"birth"</span> <span class="ot">=</span> <span class="dv">4</span> <span class="sc">*</span> params_birth<span class="sc">$</span>alpha, <span class="st">"death"</span> <span class="ot">=</span> params_death<span class="sc">$</span>beta),</span>
<span id="cb45-1649"><a href="#cb45-1649" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> <span class="fu">c</span>(params_birth, params_death),</span>
<span id="cb45-1650"><a href="#cb45-1650" aria-hidden="true" tabindex="-1"></a>    <span class="at">age_max =</span> <span class="dv">2</span>,</span>
<span id="cb45-1651"><a href="#cb45-1651" aria-hidden="true" tabindex="-1"></a>    <span class="at">time =</span> <span class="dv">500</span>)</span>
<span id="cb45-1652"><a href="#cb45-1652" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1653"><a href="#cb45-1653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1654"><a href="#cb45-1654" aria-hidden="true" tabindex="-1"></a><span class="st">```</span>{r echo<span class="ot">=</span><span class="cn">FALSE</span>}</span>
<span id="cb45-1655"><a href="#cb45-1655" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"The full algorithm is "</span> ,<span class="fu">format</span>(sim_out_full<span class="sc">$</span>logs[<span class="st">"duration_ns"</span>]<span class="sc">/</span>sim_out<span class="sc">$</span>logs[<span class="st">"duration_ns"</span>], <span class="at">digits=</span><span class="dv">2</span>), <span class="st">" times slower than the randomized version"</span>, <span class="at">sep=</span><span class="st">""</span>))</span>
<span id="cb45-1656"><a href="#cb45-1656" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
<span id="cb45-1657"><a href="#cb45-1657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1658"><a href="#cb45-1658" aria-hidden="true" tabindex="-1"></a><span class="at">In @fig-fullvsrandom, the two algorithms are compared for different population sizes.  We progressively decrease the value of the mortality rate parameter $</span><span class="sc">\b</span><span class="at">eta$ and increase the birth rate parameter $</span><span class="sc">\a</span><span class="at">lpha$. Starting with the values provided in&nbsp;@FerTra09, $</span><span class="sc">\a</span><span class="at">lpha=1$ and $</span><span class="sc">\b</span><span class="at">eta=2/300$, resulting in a stationary population size of approximately $N=360$ individuals for a sample of 50 simulations, we can easily increase the stationary population size to approximately $N=2600$ individuals with $</span><span class="sc">\a</span><span class="at">lpha=2$ and $</span><span class="sc">\b</span><span class="at">eta=1/300$.^[The choices $(</span><span class="sc">\a</span><span class="at">lpha, </span><span class="sc">\b</span><span class="at">eta) \in \{(1,2/300),(1, 1/300), (1.5, 1/300), (2, 1/300)\}$ lead to the stationary population sizes $N \in \{360, 900, 1800, 2600\}$. For each set of parameters, we generated a new initial population, which was used for a benchmark of 50 simulations with both randomized and full algorithm. The simulations run on a Intel Core i7-8550U CPU 1.80GHz × 8 processor, with 15.3 GiB of RAM, under Debian GNU/Linux 11.] </span></span>
<span id="cb45-1659"><a href="#cb45-1659" aria-hidden="true" tabindex="-1"></a><span class="at">In the log-scaled figure, we can observe the trend of computation time as a function of the population size $N$, which is linear for the randomized algorithm and quadratic for the full one ( @alg-interaction). We can also see that the randomized version of the algorithm is between 17 to 100 times faster than the full one in this example, taking only 2 seconds in average for the randomized version versus 211 seconds for @alg-interaction for the biggest population size ($N=2600$) and $T=500$.</span></span>
<span id="cb45-1660"><a href="#cb45-1660" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1661"><a href="#cb45-1661" aria-hidden="true" tabindex="-1"></a><span class="at">![Full vs random algorithm computation time](img/time_pop_size.png){#fig-fullvsrandom width=80%}</span></span>
<span id="cb45-1662"><a href="#cb45-1662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1663"><a href="#cb45-1663" aria-hidden="true" tabindex="-1"></a><span class="at"># Appendix {.appendix}</span></span>
<span id="cb45-1664"><a href="#cb45-1664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1665"><a href="#cb45-1665" aria-hidden="true" tabindex="-1"></a><span class="at">## Recall on Poisson random measures {#sec-recall-poisson .appendix} </span></span>
<span id="cb45-1666"><a href="#cb45-1666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1667"><a href="#cb45-1667" aria-hidden="true" tabindex="-1"></a><span class="at">We recall below some useful properties of Poisson random measures, mainly following Chapter&nbsp;6 of&nbsp;[@Cin11]. We also refer to&nbsp;[@Kal17] for a more comprehensive presentation of random counting measures.</span></span>
<span id="cb45-1668"><a href="#cb45-1668" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1669"><a href="#cb45-1669" aria-hidden="true" tabindex="-1"></a><span class="at">::: {#def-poisson-random-measure} </span></span>
<span id="cb45-1670"><a href="#cb45-1670" aria-hidden="true" tabindex="-1"></a><span class="at">## Poisson Random Measures</span></span>
<span id="cb45-1671"><a href="#cb45-1671" aria-hidden="true" tabindex="-1"></a><span class="at">Let $\mu$ be a $\sigma$-finite diffuse measure on a Borel subspace $(E,\mathcal{E})$ of $({\mathbb{R}}^d, \mathcal{B}({\mathbb{R}}^d))$. A random counting measure $Q= \sum_{k\geq 1} \delta_{X_k}$ is a Poisson (counting) random measure of *mean measure* $\mu$ if</span></span>
<span id="cb45-1672"><a href="#cb45-1672" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1673"><a href="#cb45-1673" aria-hidden="true" tabindex="-1"></a><span class="at">1. $</span><span class="sc">\f</span><span class="at">orall A \in \mathcal{E}$, $Q(A)$ is a Poisson random variable with ${\mathbb{E}}[Q(A)]= \mu(A)$. </span></span>
<span id="cb45-1674"><a href="#cb45-1674" aria-hidden="true" tabindex="-1"></a><span class="at">2. For all disjoints subsets $A_1, \dots, A_n \in \mathcal{E}$, $Q(A_1), \dots, Q(A_n)$ are independent Poisson random variables.</span></span>
<span id="cb45-1675"><a href="#cb45-1675" aria-hidden="true" tabindex="-1"></a><span class="at">:::</span></span>
<span id="cb45-1676"><a href="#cb45-1676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1677"><a href="#cb45-1677" aria-hidden="true" tabindex="-1"></a><span class="at">Let us briefly recall here some simple but useful operations on Poisson measures. In the following, $Q$ is a Poisson measure of mean measure $\mu$, unless stated otherwise.</span></span>
<span id="cb45-1678"><a href="#cb45-1678" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1679"><a href="#cb45-1679" aria-hidden="true" tabindex="-1"></a><span class="at">::: {#prp-restriction-poisson-measure}</span></span>
<span id="cb45-1680"><a href="#cb45-1680" aria-hidden="true" tabindex="-1"></a><span class="at">## Restricted Poisson measure</span></span>
<span id="cb45-1681"><a href="#cb45-1681" aria-hidden="true" tabindex="-1"></a><span class="at">If $B \in \mathcal{E}$, then, the restriction of $Q$ to $B$ defined by </span></span>
<span id="cb45-1682"><a href="#cb45-1682" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1683"><a href="#cb45-1683" aria-hidden="true" tabindex="-1"></a><span class="at">    Q^B = \mathbf{1}_B Q = \sum_{k \ge 1} \mathbf{1}_{B}(X_k) \delta_{X_k}</span></span>
<span id="cb45-1684"><a href="#cb45-1684" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1685"><a href="#cb45-1685" aria-hidden="true" tabindex="-1"></a><span class="at">is also a Poisson random measure, of mean measure $\mu^B = \mu(\cdot \cap B)$.</span></span>
<span id="cb45-1686"><a href="#cb45-1686" aria-hidden="true" tabindex="-1"></a><span class="at">:::</span></span>
<span id="cb45-1687"><a href="#cb45-1687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1688"><a href="#cb45-1688" aria-hidden="true" tabindex="-1"></a><span class="at">::: {#prp-proj-poisson-measure}</span></span>
<span id="cb45-1689"><a href="#cb45-1689" aria-hidden="true" tabindex="-1"></a><span class="at">## Projection of Poisson measure</span></span>
<span id="cb45-1690"><a href="#cb45-1690" aria-hidden="true" tabindex="-1"></a><span class="at">If $E = F_1 </span><span class="sc">\t</span><span class="at">imes F_2$ is a product space, then the projection</span></span>
<span id="cb45-1691"><a href="#cb45-1691" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1692"><a href="#cb45-1692" aria-hidden="true" tabindex="-1"></a><span class="at">    Q_1(\mathrm{d}x) = \int_{F_2} Q(\mathrm{d}x , \mathrm{d}y)</span></span>
<span id="cb45-1693"><a href="#cb45-1693" aria-hidden="true" tabindex="-1"></a><span class="at">$$ </span></span>
<span id="cb45-1694"><a href="#cb45-1694" aria-hidden="true" tabindex="-1"></a><span class="at">is a Poisson random measure of mean measure $\mu_1 (\mathrm{d}x ) = \int_{F_2} \mu(\mathrm{d}x, \mathrm{d}y)$.</span></span>
<span id="cb45-1695"><a href="#cb45-1695" aria-hidden="true" tabindex="-1"></a><span class="at">:::</span></span>
<span id="cb45-1696"><a href="#cb45-1696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1697"><a href="#cb45-1697" aria-hidden="true" tabindex="-1"></a><span class="at">### Link with Poisson processes</span></span>
<span id="cb45-1698"><a href="#cb45-1698" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1699"><a href="#cb45-1699" aria-hidden="true" tabindex="-1"></a><span class="at">Let $Q= \sum_{k\geq 1} \delta_{T_k}$ a Poisson random measure on $E={\mathbb{R}}^+$ with mean measure $\mu(\mathrm{d}t) = \Lambda (t) \mathrm{d}t$ absolutely continuous with respect to the Lebesgue measure, $\mu(A) = \int_A \Lambda(t) \mathrm{d}t$. </span></span>
<span id="cb45-1700"><a href="#cb45-1700" aria-hidden="true" tabindex="-1"></a><span class="at">The counting process</span></span>
<span id="cb45-1701"><a href="#cb45-1701" aria-hidden="true" tabindex="-1"></a><span class="at">$(N_t)_{t \ge 0}$ defined by </span></span>
<span id="cb45-1702"><a href="#cb45-1702" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1703"><a href="#cb45-1703" aria-hidden="true" tabindex="-1"></a><span class="at">    N_t = Q([0,t]) = \sum_{k \geq 1} \mathbf{1}_{\{T_k \leq t\}}, \quad </span><span class="sc">\f</span><span class="at">orall \; t\geq 0,</span></span>
<span id="cb45-1704"><a href="#cb45-1704" aria-hidden="true" tabindex="-1"></a><span class="at">$$ {#eq-inhomogeneous-pp}</span></span>
<span id="cb45-1705"><a href="#cb45-1705" aria-hidden="true" tabindex="-1"></a><span class="at">is an inhomogeneous Poisson process with intensity function (or rate) $t \mapsto \Lambda(t)$. In particular, when $\Lambda(t) </span><span class="sc">\e</span><span class="at">quiv c$ is a constant, $N$ is a homogeneous Poisson process with rate $c$. Assuming that the atoms are ordered $T_1&lt; T_2&lt; \dots$, we recall that the sequence $(T_{k+1}-T_k)_{k\geq 1}$ is a sequence of *i.i.d.* exponential variables of parameter $c$.</span></span>
<span id="cb45-1706"><a href="#cb45-1706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1707"><a href="#cb45-1707" aria-hidden="true" tabindex="-1"></a><span class="at">### Marked Poisson measures on $E = {\mathbb{R}}^+ </span><span class="sc">\t</span><span class="at">imes F$</span></span>
<span id="cb45-1708"><a href="#cb45-1708" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1709"><a href="#cb45-1709" aria-hidden="true" tabindex="-1"></a><span class="at">We are interested in the particular case when $E$ is the product space ${\mathbb{R}}^+ </span><span class="sc">\t</span><span class="at">imes F$, with $(F,\mathcal{F})$ a Borel subspace of ${\mathbb{R}}^d$. Then, a random counting measure is defined by a random set $S =\{ (T_k, \Theta_k ), k \geq 1\}$. The random variables $T_k\geq 0$ can be considered as time variables, and constitute the jump times of the random measure, while the variables $\Theta_k \in F$ represent space variables.</span></span>
<span id="cb45-1710"><a href="#cb45-1710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1711"><a href="#cb45-1711" aria-hidden="true" tabindex="-1"></a><span class="at">We recall in this special case the Theorem&nbsp;VI.3.2 in&nbsp;[@Cin11].</span></span>
<span id="cb45-1712"><a href="#cb45-1712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1713"><a href="#cb45-1713" aria-hidden="true" tabindex="-1"></a><span class="at">::: {#prp-marked-poisson}</span></span>
<span id="cb45-1714"><a href="#cb45-1714" aria-hidden="true" tabindex="-1"></a><span class="at">## Marked Poisson measure </span></span>
<span id="cb45-1715"><a href="#cb45-1715" aria-hidden="true" tabindex="-1"></a><span class="at">Let $m$ be a $\sigma$--finite diffuse measure on ${\mathbb{R}}^+$, and $K$ a transition probability kernel from $({\mathbb{R}}^+,\mathcal{B}({\mathbb{R}}^+))$ into $(F, \mathcal{F})$. </span></span>
<span id="cb45-1716"><a href="#cb45-1716" aria-hidden="true" tabindex="-1"></a><span class="at">Assume that the collection $(T_k)_{k \ge 1}$ forms a Poisson process $(N_t) =(\sum_{k\geq 1} \mathbf{1}_{\{T_k \leq t\}})$ with mean $m(\mathrm{d}t) =\Lambda(t) \mathrm{d}t$, and that given $(T_k)_{k \ge 1}$, the variables $\Theta_k$ are conditionally independent and have the respective distributions $K(T_k, \cdot)$.</span></span>
<span id="cb45-1717"><a href="#cb45-1717" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1718"><a href="#cb45-1718" aria-hidden="true" tabindex="-1"></a><span class="at">1. Then, $\{ (T_k, \Theta_k) ;\; k \ge 1\}$ forms a Poisson random measure $Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}$ on $({\mathbb{R}}^+ </span><span class="sc">\t</span><span class="at">imes F, \mathcal{B}({\mathbb{R}}^+) \otimes \mathcal{F})$, called a *Marked point process* , with mean $\mu$ defined by </span></span>
<span id="cb45-1719"><a href="#cb45-1719" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1720"><a href="#cb45-1720" aria-hidden="true" tabindex="-1"></a><span class="at">    \mu(\mathrm{d}t, \mathrm{d}y) = \Lambda(t) \mathrm{d}t K(t, \mathrm{d}y).</span></span>
<span id="cb45-1721"><a href="#cb45-1721" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1722"><a href="#cb45-1722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1723"><a href="#cb45-1723" aria-hidden="true" tabindex="-1"></a><span class="at">2. Reciprocally let $Q$ be a Poisson random measure of mean measure $\mu(\mathrm{d}t, \mathrm{d}y)$, admitting the following disintegration with respect to the first coordinate: $\mu(\mathrm{d}t , \mathrm{d}y) =</span><span class="sc">\t</span><span class="at">ilde  \Lambda(t) \mathrm{d}t </span><span class="sc">\n</span><span class="at">u(t, \mathrm{d}y)$, with $</span><span class="sc">\n</span><span class="at">u(t, F)&lt;\infty$. </span></span>
<span id="cb45-1724"><a href="#cb45-1724" aria-hidden="true" tabindex="-1"></a><span class="at">Let $K(t, \mathrm{d}y) = \dfrac{</span><span class="sc">\n</span><span class="at">u(t,\mathrm{d}y) }{</span><span class="sc">\n</span><span class="at">u(t, F) }$ and $\Lambda(t) = </span><span class="sc">\n</span><span class="at">u(t, F)</span><span class="sc">\t</span><span class="at">ilde  \Lambda(t)$. Then, $Q = \sum_{k\ge 1} \delta_{(T_k, \Theta_k)}$ is a marked Poisson measure with $(T_k,\Theta_k)_{k\in {\mathbb{N}}^*}$ defined as above. </span></span>
<span id="cb45-1725"><a href="#cb45-1725" aria-hidden="true" tabindex="-1"></a><span class="at">In particular, the projection $N= (N_t)_{t\geq0}$ of the Poisson measure on the first coordinate,</span></span>
<span id="cb45-1726"><a href="#cb45-1726" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1727"><a href="#cb45-1727" aria-hidden="true" tabindex="-1"></a><span class="at">    N_t = Q([0,t] </span><span class="sc">\t</span><span class="at">imes F) = \sum_{k\geq 1} \mathbf{1}_{[0,t] </span><span class="sc">\t</span><span class="at">imes F} (T_k, \Theta_k)  = \sum_{k\geq 1} \mathbf{1}_{\{T_k \leq t\}}, \quad </span><span class="sc">\f</span><span class="at">orall \; t \geq 0,</span></span>
<span id="cb45-1728"><a href="#cb45-1728" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1729"><a href="#cb45-1729" aria-hidden="true" tabindex="-1"></a><span class="at">is an inhomogeneous Poisson process of rate $\Lambda(t)= </span><span class="sc">\n</span><span class="at">u(t, F)</span><span class="sc">\t</span><span class="at">ilde  \Lambda(t)$.</span></span>
<span id="cb45-1730"><a href="#cb45-1730" aria-hidden="true" tabindex="-1"></a><span class="at">:::</span></span>
<span id="cb45-1731"><a href="#cb45-1731" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1732"><a href="#cb45-1732" aria-hidden="true" tabindex="-1"></a><span class="at">::: {#rem}</span></span>
<span id="cb45-1733"><a href="#cb45-1733" aria-hidden="true" tabindex="-1"></a><span class="at">When the transition probability kernel $K$ does not depend on the time: $K(t, A) = </span><span class="sc">\n</span><span class="at">u(A)$ for some probability measure $</span><span class="sc">\n</span><span class="at">u$, then the marks $(\Theta_k)_{k \ge 1}$ form an *i.i.d.* sequence with distribution $</span><span class="sc">\n</span><span class="at">u$, independent of $(T_k)_{k \ge 1}$.</span></span>
<span id="cb45-1734"><a href="#cb45-1734" aria-hidden="true" tabindex="-1"></a><span class="at">:::</span></span>
<span id="cb45-1735"><a href="#cb45-1735" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1736"><a href="#cb45-1736" aria-hidden="true" tabindex="-1"></a><span class="at">The preceding proposition thus yields a straightforward iterative simulation procedure for a Marked Poisson process on $[0,T]</span><span class="sc">\t</span><span class="at">imes F$ with mean measure $\mu(\mathrm{d}t, \mathrm{d}y) = c \mathrm{d}t K(t, \mathrm{d}y)$ and $c&gt;0$. The procedure is described in @alg-marked-poisson.</span></span>
<span id="cb45-1737"><a href="#cb45-1737" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1738"><a href="#cb45-1738" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1739"><a href="#cb45-1739" aria-hidden="true" tabindex="-1"></a><span class="st">```</span>pseudocode</span>
<span id="cb45-1740"><a href="#cb45-1740" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: alg-marked-poisson</span></span>
<span id="cb45-1741"><a href="#cb45-1741" aria-hidden="true" tabindex="-1"></a><span class="co">#| html-indent-size: "1.2em"</span></span>
<span id="cb45-1742"><a href="#cb45-1742" aria-hidden="true" tabindex="-1"></a><span class="co">#| html-comment-delimiter: "//"</span></span>
<span id="cb45-1743"><a href="#cb45-1743" aria-hidden="true" tabindex="-1"></a><span class="co">#| html-line-number: true</span></span>
<span id="cb45-1744"><a href="#cb45-1744" aria-hidden="true" tabindex="-1"></a><span class="co">#| html-line-number-punc: ":"</span></span>
<span id="cb45-1745"><a href="#cb45-1745" aria-hidden="true" tabindex="-1"></a><span class="co">#| html-no-end: false</span></span>
<span id="cb45-1746"><a href="#cb45-1746" aria-hidden="true" tabindex="-1"></a><span class="co">#| pdf-placement: "htb!"</span></span>
<span id="cb45-1747"><a href="#cb45-1747" aria-hidden="true" tabindex="-1"></a><span class="co">#| pdf-line-number: true</span></span>
<span id="cb45-1748"><a href="#cb45-1748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1749"><a href="#cb45-1749" aria-hidden="true" tabindex="-1"></a>\begin{algorithm}</span>
<span id="cb45-1750"><a href="#cb45-1750" aria-hidden="true" tabindex="-1"></a>\caption{Simulation of Marked Poisson measure}</span>
<span id="cb45-1751"><a href="#cb45-1751" aria-hidden="true" tabindex="-1"></a>\begin{algorithmic}</span>
<span id="cb45-1752"><a href="#cb45-1752" aria-hidden="true" tabindex="-1"></a>    \State \textbf{Input<span class="sc">:</span>} Constant <span class="sc">$</span>c<span class="sc">$</span>, simulatable kernel <span class="sc">$</span>K<span class="sc">$</span> and final time <span class="sc">$</span>T<span class="sc">$</span> </span>
<span id="cb45-1753"><a href="#cb45-1753" aria-hidden="true" tabindex="-1"></a>    \State \textbf{Output<span class="sc">:</span>} Times <span class="sc">$</span>(T_1,\dots,T_n)<span class="sc">$</span>  and Marks <span class="sc">$</span>(Y_1, \dots, Y_n)<span class="sc">$</span> of the Marked Poisson measure of mean <span class="sc">$</span>\<span class="fu">mu</span>(\mathrm{d} t, \mathrm{d} y) <span class="ot">=</span> c \mathrm{d} t <span class="fu">K</span>(t, \mathrm{d} y)<span class="sc">$</span> <span class="cf">in</span> <span class="sc">$</span>[<span class="dv">0</span>,T]\times F<span class="sc">$</span>.</span>
<span id="cb45-1754"><a href="#cb45-1754" aria-hidden="true" tabindex="-1"></a>    \State Initialization draw <span class="sc">$</span>T_1 \sim \mathcal{E}(c)<span class="sc">$</span> and draw <span class="sc">$</span>Y_1 \sim <span class="fu">K</span>(T_1, \mathrm{d} y)<span class="sc">$</span> </span>
<span id="cb45-1755"><a href="#cb45-1755" aria-hidden="true" tabindex="-1"></a>    \While{condition}</span>
<span id="cb45-1756"><a href="#cb45-1756" aria-hidden="true" tabindex="-1"></a>        \State increment iterative variable <span class="sc">$</span>k \longleftarrow k<span class="sc">+</span><span class="dv">1</span><span class="sc">$</span></span>
<span id="cb45-1757"><a href="#cb45-1757" aria-hidden="true" tabindex="-1"></a>        \State compute <span class="cf">next</span> jump time compute <span class="cf">next</span> jump time <span class="sc">$</span>T_k \longleftarrow T_{k<span class="dv">-1</span>} <span class="sc">+</span> \mathcal{E}(c)<span class="sc">$</span></span>
<span id="cb45-1758"><a href="#cb45-1758" aria-hidden="true" tabindex="-1"></a>        \State draw a conditional mark <span class="sc">$</span>Y_k \sim <span class="fu">K</span>(T_k, \mathrm{d} y)<span class="sc">$</span>    </span>
<span id="cb45-1759"><a href="#cb45-1759" aria-hidden="true" tabindex="-1"></a>    \EndWhile</span>
<span id="cb45-1760"><a href="#cb45-1760" aria-hidden="true" tabindex="-1"></a>\end{algorithmic}</span>
<span id="cb45-1761"><a href="#cb45-1761" aria-hidden="true" tabindex="-1"></a>\end{algorithm}</span>
<span id="cb45-1762"><a href="#cb45-1762" aria-hidden="true" tabindex="-1"></a><span class="st">```</span><span class="at"> </span></span>
<span id="cb45-1763"><a href="#cb45-1763" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1764"><a href="#cb45-1764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1765"><a href="#cb45-1765" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1766"><a href="#cb45-1766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1767"><a href="#cb45-1767" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1768"><a href="#cb45-1768" aria-hidden="true" tabindex="-1"></a><span class="at">![Example of Marked Poisson measure on $[0,T]$ with $m(\mathrm{d} t) = L \mathrm{d} t$ (jump times occur at Poisson arrival times of rate $L$) and with $</span><span class="sc">\n</span><span class="at">u(\mathrm{d} y) = </span><span class="sc">\f</span><span class="at">rac{1}{L} \mathbf{1}_{[0, L]}(y) \mathrm{d} y$ (marks are drawn uniformly on $[0,L]$).</span></span>
<span id="cb45-1769"><a href="#cb45-1769" aria-hidden="true" tabindex="-1"></a><span class="at">The mean measure is then $\mu(\mathrm{d} t, \mathrm{d} y) = \mathrm{d} t {1}_{[0,L]}(y) \mathrm{d} y$.](img/plot_poisson.tex){#fig-poisson}</span></span>
<span id="cb45-1770"><a href="#cb45-1770" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1771"><a href="#cb45-1771" aria-hidden="true" tabindex="-1"></a><span class="at">## Pathwise representation of IBMs {#sec-pathwise-representation}</span></span>
<span id="cb45-1772"><a href="#cb45-1772" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1773"><a href="#cb45-1773" aria-hidden="true" tabindex="-1"></a><span class="at">**Notation reminder** The population's evolution is described by the measure valued process $(Z_t)_{t\geq 0}$. Several types of events $e$ can occur to individuals denoted by $I$. If an event of type $e$ occur to the individual $I$ at time $t$, then the population state $Z_{t^-}$ is modified by $\phi^e(t,I)$. </span></span>
<span id="cb45-1774"><a href="#cb45-1774" aria-hidden="true" tabindex="-1"></a><span class="at">If $e\in \mathcal{E} \cup \mathcal{E}_W$, then events of type $e$ occur with an intensity $\sum_{k=1}^{N_t} \lambda_t^e(I,Z_t)$, with $\lambda_t^e(I,Z_t)$ defined by @eq-individual-intensity. </span></span>
<span id="cb45-1775"><a href="#cb45-1775" aria-hidden="true" tabindex="-1"></a><span class="at">If $e \in \mathcal{P}$, then events of type $e$ occur in the population at a Poisson intensity of $(\mu^e_t)$.</span></span>
<span id="cb45-1776"><a href="#cb45-1776" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1777"><a href="#cb45-1777" aria-hidden="true" tabindex="-1"></a><span class="at">### Proof of @thm-eq-Z {#sec-prf-thm-eq-Z} </span></span>
<span id="cb45-1778"><a href="#cb45-1778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1779"><a href="#cb45-1779" aria-hidden="true" tabindex="-1"></a><span class="at">::: {.proof}</span></span>
<span id="cb45-1780"><a href="#cb45-1780" aria-hidden="true" tabindex="-1"></a><span class="at">For ease of notation, we prove the case when $\mathcal{P} =</span><span class="sc">\e</span><span class="at">mptyset$ (there are no events with Poisson intensity).</span></span>
<span id="cb45-1781"><a href="#cb45-1781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1782"><a href="#cb45-1782" aria-hidden="true" tabindex="-1"></a><span class="at">- Step 1. The existence of a solution to @eq-sde-eq-Z is obtained by induction. Let $Z^1$ be the unique solution the thinning equation:</span></span>
<span id="cb45-1783"><a href="#cb45-1783" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1784"><a href="#cb45-1784" aria-hidden="true" tabindex="-1"></a><span class="at">    Z_t^1 = Z_0 + \int_0^t \int_{ \mathcal{J}</span><span class="sc">\t</span><span class="at">imes \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{0}\} }\mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_s^e(I_k, Z_{0})\}} Q (\mathrm{d}s,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ), \quad </span><span class="sc">\f</span><span class="at">orall  0 \leq t \leq T.</span></span>
<span id="cb45-1785"><a href="#cb45-1785" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1786"><a href="#cb45-1786" aria-hidden="true" tabindex="-1"></a><span class="at">Let $T_1$ be the first jump time of $Z^1$. Since $Z_{s^-}^1 = Z_{0}$ and $N_{s^-}=N_{0}$ on $[0, T_1]$, $Z^1$ is solution of @eq-sde-eq-Z on $[0,T_1]$.</span></span>
<span id="cb45-1787"><a href="#cb45-1787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1788"><a href="#cb45-1788" aria-hidden="true" tabindex="-1"></a><span class="at">Let us now assume that @eq-sde-eq-Z admits a solution $Z^n$ on $[0,T_n]$, with $T_n$ the $n$--th event time in the population. Let $Z^{n+1}$ be the unique solution of the thinning equation:</span></span>
<span id="cb45-1789"><a href="#cb45-1789" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1790"><a href="#cb45-1790" aria-hidden="true" tabindex="-1"></a><span class="at">    Z^{n+1}_t  =  Z_{t\wedge T_n}^n + \int_{t\wedge T_n}^{t} \int_{ \mathcal{J}</span><span class="sc">\t</span><span class="at">imes \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_s^e(I_k, Z_{T_n}^n)\}} \mathbf{1}_{\{k \leq N_{T_n}^n \} }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ).</span></span>
<span id="cb45-1791"><a href="#cb45-1791" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1792"><a href="#cb45-1792" aria-hidden="true" tabindex="-1"></a><span class="at">First, observe that $Z^{n+1}$ coincides with $Z^n$ on $[0,T_n]$. Let $T_{n+1}$ be the $(n+1)$--th jump of $Z^{n+1}$. Furthermore, $Z_{s^-}^{n+1} = Z_{T_n}^n$ and $N_{s^-}^{n+1}=N_{T_n}^{n}$ on $[T_n, T_{n+1}]$ (nothing happens between two successive event times), $Z^{n+1}$ verifies for all $t\leq T_{n+1}$: </span></span>
<span id="cb45-1793"><a href="#cb45-1793" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1794"><a href="#cb45-1794" aria-hidden="true" tabindex="-1"></a><span class="sc">\b</span><span class="at">egin{aligned}</span></span>
<span id="cb45-1795"><a href="#cb45-1795" aria-hidden="true" tabindex="-1"></a><span class="at">    Z^{n+1}_t  =  Z_{t\wedge T_n}^n +\int_{t\wedge T_n}^{t} \int_{ \mathcal{J}</span><span class="sc">\t</span><span class="at">imes \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_s^e(I_k, Z_{s^-}^{n+1} )\}} \mathbf{1}_{\{k \leq N_{s^-}^{n+1} \} }Q (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ).</span></span>
<span id="cb45-1796"><a href="#cb45-1796" aria-hidden="true" tabindex="-1"></a><span class="sc">\e</span><span class="at">nd{aligned}</span></span>
<span id="cb45-1797"><a href="#cb45-1797" aria-hidden="true" tabindex="-1"></a><span class="at">$$ </span></span>
<span id="cb45-1798"><a href="#cb45-1798" aria-hidden="true" tabindex="-1"></a><span class="at">Since, $Z^n$ is a solution of @eq-sde-eq-Z on $[0,T_n]$ coinciding with $Z^{n+1}$ this achieves to prove that $Z^{n+1}$ is solution of @eq-sde-eq-Z on $[0,T_{n+1}]$.</span></span>
<span id="cb45-1799"><a href="#cb45-1799" aria-hidden="true" tabindex="-1"></a><span class="at">Finally, let $Z =\lim_{n</span><span class="sc">\t</span><span class="at">o \infty } Z^n$. For all $n\geq 1$, $T_n$ is the $n$--th event time of $Z$, and $Z$ is solution of @eq-sde-eq-Z on all time intervals $[0,T_n\wedge T]$ by construction.</span></span>
<span id="cb45-1800"><a href="#cb45-1800" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1801"><a href="#cb45-1801" aria-hidden="true" tabindex="-1"></a><span class="at">By @lem-non-explosion $T_n \underset{n</span><span class="sc">\t</span><span class="at">o \infty}{\longrightarrow} \infty$. Thus, by letting $n</span><span class="sc">\t</span><span class="at">o \infty$ we can conclude that $Z$ is a solution of @eq-sde-eq-Z on $[0,T]$.</span></span>
<span id="cb45-1802"><a href="#cb45-1802" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1803"><a href="#cb45-1803" aria-hidden="true" tabindex="-1"></a><span class="at">- Step 2. Let $</span><span class="sc">\t</span><span class="at">ilde Z$ be a solution of @eq-sde-eq-Z. Using the same arguments than in Step 1, it is straightforward to show that $</span><span class="sc">\t</span><span class="at">ilde Z$ coincides with $Z^n$ on $[0,T_n]$, for all $n \geq 1$. Thus, $</span><span class="sc">\t</span><span class="at">ilde{Z} = Z$, with achieves to prove uniqueness.</span></span>
<span id="cb45-1804"><a href="#cb45-1804" aria-hidden="true" tabindex="-1"></a><span class="at">:::</span></span>
<span id="cb45-1805"><a href="#cb45-1805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1806"><a href="#cb45-1806" aria-hidden="true" tabindex="-1"></a><span class="at">### Proof of @lem-non-explosion {#sec-prf-lem-non-explosion} </span></span>
<span id="cb45-1807"><a href="#cb45-1807" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1808"><a href="#cb45-1808" aria-hidden="true" tabindex="-1"></a><span class="at">The proof is obtained using pathwise comparison result, generalizing those obtained in [@KaaElK20].</span></span>
<span id="cb45-1809"><a href="#cb45-1809" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1810"><a href="#cb45-1810" aria-hidden="true" tabindex="-1"></a><span class="at">::: {.proof}</span></span>
<span id="cb45-1811"><a href="#cb45-1811" aria-hidden="true" tabindex="-1"></a><span class="at">Let $Z$ be a solution of @eq-sde-eq-Z. For</span></span>
<span id="cb45-1812"><a href="#cb45-1812" aria-hidden="true" tabindex="-1"></a><span class="at">all $e \in \mathcal{P} \cup \mathcal{E} \cup  \mathcal{E}_W$, let $N^e$</span></span>
<span id="cb45-1813"><a href="#cb45-1813" aria-hidden="true" tabindex="-1"></a><span class="at">be the process counting the occurrence of events of type $e$ in the</span></span>
<span id="cb45-1814"><a href="#cb45-1814" aria-hidden="true" tabindex="-1"></a><span class="at">population. $N^e$ is a counting process of $\{\mathcal{F}_t\}$-intensity</span></span>
<span id="cb45-1815"><a href="#cb45-1815" aria-hidden="true" tabindex="-1"></a><span class="at">$(\Lambda_t^e(Z_{t^-}))$, solution of </span></span>
<span id="cb45-1816"><a href="#cb45-1816" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1817"><a href="#cb45-1817" aria-hidden="true" tabindex="-1"></a><span class="sc">\b</span><span class="at">egin{aligned}</span></span>
<span id="cb45-1818"><a href="#cb45-1818" aria-hidden="true" tabindex="-1"></a><span class="at">  &amp; N_t^e = \int_0^t \int_{{\mathbb{N}}</span><span class="sc">\t</span><span class="at">imes {\mathbb{R}}^+} \mathbf{1}_{\{k\leq N_{s^-}\}}  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_s^e(I_k, Z_{s^-})\}} Q(\mathrm{d}s, \mathrm{d}k, \{e\}, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta), &amp; \quad  </span><span class="sc">\t</span><span class="at">extit{ if } e \in \mathcal{E}\cup \mathcal{E}_W, </span><span class="sc">\\</span></span>
<span id="cb45-1819"><a href="#cb45-1819" aria-hidden="true" tabindex="-1"></a><span class="at">&amp; N_t^e = \int_0^t \int_{{\mathbb{R}}^+} \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \mu^e_s \}} Q^{\mathcal{P}}(\mathrm{d}s, \{e\}, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta), &amp; \quad  </span><span class="sc">\t</span><span class="at">extit{ if } e \in \cal P. </span><span class="sc">\\</span></span>
<span id="cb45-1820"><a href="#cb45-1820" aria-hidden="true" tabindex="-1"></a><span class="sc">\e</span><span class="at">nd{aligned}</span></span>
<span id="cb45-1821"><a href="#cb45-1821" aria-hidden="true" tabindex="-1"></a><span class="at">$$ {#eq-Ne} </span></span>
<span id="cb45-1822"><a href="#cb45-1822" aria-hidden="true" tabindex="-1"></a><span class="at">By definition, the jump times of the multivariate</span></span>
<span id="cb45-1823"><a href="#cb45-1823" aria-hidden="true" tabindex="-1"></a><span class="at">counting process</span></span>
<span id="cb45-1824"><a href="#cb45-1824" aria-hidden="true" tabindex="-1"></a><span class="at">$(N^e)_{e \in \mathcal{P} \cup \mathcal{E}\cup \mathcal{E}_W}$ are the</span></span>
<span id="cb45-1825"><a href="#cb45-1825" aria-hidden="true" tabindex="-1"></a><span class="at">population event times $(T_n)_{n\geq 0}$. The idea of the proof is to</span></span>
<span id="cb45-1826"><a href="#cb45-1826" aria-hidden="true" tabindex="-1"></a><span class="at">show that $(N^e)_{e \in \mathcal{P} \cup \mathcal{E}\cup \mathcal{E}_W}$</span></span>
<span id="cb45-1827"><a href="#cb45-1827" aria-hidden="true" tabindex="-1"></a><span class="at">does not explode in finite time, by pathwise domination with a simpler</span></span>
<span id="cb45-1828"><a href="#cb45-1828" aria-hidden="true" tabindex="-1"></a><span class="at">multivariate counting process. The first steps are to control the</span></span>
<span id="cb45-1829"><a href="#cb45-1829" aria-hidden="true" tabindex="-1"></a><span class="at">population size $N_t = N_0 + N^b_t + N^{en}_t$.\</span></span>
<span id="cb45-1830"><a href="#cb45-1830" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1831"><a href="#cb45-1831" aria-hidden="true" tabindex="-1"></a><span class="at">**Step 1** Let $(</span><span class="sc">\b</span><span class="at">ar N^b, </span><span class="sc">\b</span><span class="at">ar N^{en})$ be the 2-dimensional counting</span></span>
<span id="cb45-1832"><a href="#cb45-1832" aria-hidden="true" tabindex="-1"></a><span class="at">process defined as follows: for $e \in \{b,en\}$, $</span><span class="sc">\b</span><span class="at">ar N^e_0 = 0$ and</span></span>
<span id="cb45-1833"><a href="#cb45-1833" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1834"><a href="#cb45-1834" aria-hidden="true" tabindex="-1"></a><span class="sc">\b</span><span class="at">egin{aligned}</span></span>
<span id="cb45-1835"><a href="#cb45-1835" aria-hidden="true" tabindex="-1"></a><span class="at">&amp; </span><span class="sc">\b</span><span class="at">ar N_t^e = \int_0^t \int_{{\mathbb{N}}</span><span class="sc">\t</span><span class="at">imes {\mathbb{R}}^+} \mathbf{1}_{\{k\leq N_0 + </span><span class="sc">\b</span><span class="at">ar N_{s^-} \}}  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq f^e(N_0 + </span><span class="sc">\b</span><span class="at">ar N_{s^-})\}} Q(\mathrm{d}s, \mathrm{d}k, \{e\}, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta),  \quad  </span><span class="sc">\t</span><span class="at">extit{ if } e \in \mathcal{E}\cup \mathcal{E}_W, </span><span class="sc">\\</span></span>
<span id="cb45-1836"><a href="#cb45-1836" aria-hidden="true" tabindex="-1"></a><span class="at">&amp;   </span><span class="sc">\b</span><span class="at">ar N_t^e = \int_0^t \int_{{\mathbb{R}}^+} \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq </span><span class="sc">\b</span><span class="at">ar \mu^e\}} Q^{\mathcal{P}}(\mathrm{d}s, \{e\}, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta)  \quad  </span><span class="sc">\t</span><span class="at">extit{ if } e \in \cal P,</span></span>
<span id="cb45-1837"><a href="#cb45-1837" aria-hidden="true" tabindex="-1"></a><span class="sc">\e</span><span class="at">nd{aligned}</span></span>
<span id="cb45-1838"><a href="#cb45-1838" aria-hidden="true" tabindex="-1"></a><span class="at">$$ {#eq-dominatingprocess}</span></span>
<span id="cb45-1839"><a href="#cb45-1839" aria-hidden="true" tabindex="-1"></a><span class="at">with $</span><span class="sc">\b</span><span class="at">ar N := </span><span class="sc">\b</span><span class="at">ar N^b + </span><span class="sc">\b</span><span class="at">ar N^{en}$ and $f^e$ the</span></span>
<span id="cb45-1840"><a href="#cb45-1840" aria-hidden="true" tabindex="-1"></a><span class="at">function introduced in @cnj-non-explosion.\</span></span>
<span id="cb45-1841"><a href="#cb45-1841" aria-hidden="true" tabindex="-1"></a><span class="at">- If $b,en \in \cal P$, then $</span><span class="sc">\b</span><span class="at">ar N$ is a inhomogeneous Poisson</span></span>
<span id="cb45-1842"><a href="#cb45-1842" aria-hidden="true" tabindex="-1"></a><span class="at">process.\</span></span>
<span id="cb45-1843"><a href="#cb45-1843" aria-hidden="true" tabindex="-1"></a><span class="at">- If $b,en \in \mathcal{E}\cup \mathcal{E}_W$, then it is</span></span>
<span id="cb45-1844"><a href="#cb45-1844" aria-hidden="true" tabindex="-1"></a><span class="at">straightforward to show that conditionally to $N_0$, $</span><span class="sc">\b</span><span class="at">ar N$ is a pure</span></span>
<span id="cb45-1845"><a href="#cb45-1845" aria-hidden="true" tabindex="-1"></a><span class="at">birth Markov process with birth intensity function</span></span>
<span id="cb45-1846"><a href="#cb45-1846" aria-hidden="true" tabindex="-1"></a><span class="at">$g(n) = n</span><span class="sc">\b</span><span class="at">ig(f^b(N_0+n) + f^{en}(N_0+n)</span><span class="sc">\b</span><span class="at">ig)$. In particular, by @cnj-non-explosion, </span></span>
<span id="cb45-1847"><a href="#cb45-1847" aria-hidden="true" tabindex="-1"></a><span class="at">$g$ verifies the standard Feller</span></span>
<span id="cb45-1848"><a href="#cb45-1848" aria-hidden="true" tabindex="-1"></a><span class="at">condition for pure birth Markov processes (see e.g. [@BanMel15]):</span></span>
<span id="cb45-1849"><a href="#cb45-1849" aria-hidden="true" tabindex="-1"></a><span class="at">$$\sum_{n=1}^\infty </span><span class="sc">\f</span><span class="at">rac{1}{g(n)}.$$ - Finally, if $b \in \mathcal{E}$</span></span>
<span id="cb45-1850"><a href="#cb45-1850" aria-hidden="true" tabindex="-1"></a><span class="at">and $en \in \cal P$ (or equivalently if $b \in \cal P$ and</span></span>
<span id="cb45-1851"><a href="#cb45-1851" aria-hidden="true" tabindex="-1"></a><span class="at">$en \in \mathcal{E}$), then one can show easily that $</span><span class="sc">\b</span><span class="at">ar N$ is a pure</span></span>
<span id="cb45-1852"><a href="#cb45-1852" aria-hidden="true" tabindex="-1"></a><span class="at">birth Markov process with immigration, of birth intensity function</span></span>
<span id="cb45-1853"><a href="#cb45-1853" aria-hidden="true" tabindex="-1"></a><span class="at">$g(n)= </span><span class="sc">\b</span><span class="at">ar  \mu^{en} + n f^b(N_0 + n)$ (resp.</span></span>
<span id="cb45-1854"><a href="#cb45-1854" aria-hidden="true" tabindex="-1"></a><span class="at">$g(n)= </span><span class="sc">\b</span><span class="at">ar  \mu^b+ n f^{en}(N_0 + n)$), also verifying the Feller</span></span>
<span id="cb45-1855"><a href="#cb45-1855" aria-hidden="true" tabindex="-1"></a><span class="at">condition.</span></span>
<span id="cb45-1856"><a href="#cb45-1856" aria-hidden="true" tabindex="-1"></a><span class="at">Therefore, there exists a non-exploding solution of @eq-dominatingprocess, </span></span>
<span id="cb45-1857"><a href="#cb45-1857" aria-hidden="true" tabindex="-1"></a><span class="at">by Proposition 3.3 in [@KaaElK20].\</span></span>
<span id="cb45-1858"><a href="#cb45-1858" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1859"><a href="#cb45-1859" aria-hidden="true" tabindex="-1"></a><span class="at">**Step 2** The second step consists in showing that $(N^b, N^{en})$ is</span></span>
<span id="cb45-1860"><a href="#cb45-1860" aria-hidden="true" tabindex="-1"></a><span class="at">strongly dominated by $(</span><span class="sc">\b</span><span class="at">ar N^b, </span><span class="sc">\b</span><span class="at">ar N^{en})$, i.e that all jumps of</span></span>
<span id="cb45-1861"><a href="#cb45-1861" aria-hidden="true" tabindex="-1"></a><span class="at">$(N^b, N^{en})$ are jumps of $(</span><span class="sc">\b</span><span class="at">ar N^b, </span><span class="sc">\b</span><span class="at">ar N^{en})$. Without loss of</span></span>
<span id="cb45-1862"><a href="#cb45-1862" aria-hidden="true" tabindex="-1"></a><span class="at">generality, we can assume that $f^e:\mathbb{N} </span><span class="sc">\t</span><span class="at">o (0,+\infty)$ is</span></span>
<span id="cb45-1863"><a href="#cb45-1863" aria-hidden="true" tabindex="-1"></a><span class="at">increasing since $f^e(n)$ can be replaced by</span></span>
<span id="cb45-1864"><a href="#cb45-1864" aria-hidden="true" tabindex="-1"></a><span class="at">$\sup_{\{m\leq n \} } f^e(m)$.\</span></span>
<span id="cb45-1865"><a href="#cb45-1865" aria-hidden="true" tabindex="-1"></a><span class="at">Let $e\in \{b, en\}$. If $e \in \mathcal{P}$, then for all $s\in [0,T]$</span></span>
<span id="cb45-1866"><a href="#cb45-1866" aria-hidden="true" tabindex="-1"></a><span class="at">$$\{</span><span class="sc">\t</span><span class="at">heta \leq \mu_s^e\} \subset \{ </span><span class="sc">\t</span><span class="at">heta \leq </span><span class="sc">\b</span><span class="at">ar \mu^e\},$$ which</span></span>
<span id="cb45-1867"><a href="#cb45-1867" aria-hidden="true" tabindex="-1"></a><span class="at">yields that all jumps of $N^e$ are jumps of $</span><span class="sc">\b</span><span class="at">ar N^e$.\</span></span>
<span id="cb45-1868"><a href="#cb45-1868" aria-hidden="true" tabindex="-1"></a><span class="at">If $e \in  \mathcal{E}\cup \mathcal{E}_W$, the proof by induction is</span></span>
<span id="cb45-1869"><a href="#cb45-1869" aria-hidden="true" tabindex="-1"></a><span class="at">analogous to the proof of Proposition 2.1 in [@KaaElK20]. Let $T_1^e$ be</span></span>
<span id="cb45-1870"><a href="#cb45-1870" aria-hidden="true" tabindex="-1"></a><span class="at">first jump time of $N^e$, associated with the marks $(K_1^e,\Theta_1^e)$</span></span>
<span id="cb45-1871"><a href="#cb45-1871" aria-hidden="true" tabindex="-1"></a><span class="at">of $Q$ (or $Q^{\mathcal{P}}$). Then, by Definition of @eq-Ne, $K_1^e \leq N_0$ and</span></span>
<span id="cb45-1872"><a href="#cb45-1872" aria-hidden="true" tabindex="-1"></a><span class="at">$\Theta_1^e \leq \lambda_{T_1^e}^e (I_{K_1^e}, Z_0)$.\</span></span>
<span id="cb45-1873"><a href="#cb45-1873" aria-hidden="true" tabindex="-1"></a><span class="at">By @cnj-non-explosion, we have also</span></span>
<span id="cb45-1874"><a href="#cb45-1874" aria-hidden="true" tabindex="-1"></a><span class="at">$$\Theta_1^e \leq \lambda_{T_1^e}^e (I_{K_1^e}, Z_0) \leq f^e(N_0) \leq f^e(N_0 +</span><span class="sc">\b</span><span class="at">ar N_{T_1^{e,-}}), \quad K_1^e \leq N_0 +  </span><span class="sc">\b</span><span class="at">ar N_{T_1^{e,-}}.$$</span></span>
<span id="cb45-1875"><a href="#cb45-1875" aria-hidden="true" tabindex="-1"></a><span class="at">Thus, $T_1^e$ is also a jump time of $</span><span class="sc">\b</span><span class="at">ar N^e$. By iterating this</span></span>
<span id="cb45-1876"><a href="#cb45-1876" aria-hidden="true" tabindex="-1"></a><span class="at">argument, we obtain that all jump times of $N^e$ are jump times of</span></span>
<span id="cb45-1877"><a href="#cb45-1877" aria-hidden="true" tabindex="-1"></a><span class="at">$</span><span class="sc">\b</span><span class="at">ar N^e$.\</span></span>
<span id="cb45-1878"><a href="#cb45-1878" aria-hidden="true" tabindex="-1"></a><span class="at">Thus, $(N^b, N^{en})$ does not explode in finite time.\</span></span>
<span id="cb45-1879"><a href="#cb45-1879" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1880"><a href="#cb45-1880" aria-hidden="true" tabindex="-1"></a><span class="at">**Step 3** It remains to show that for $e </span><span class="sc">\n</span><span class="at">otin \{b, en\}$, $N^e$ does</span></span>
<span id="cb45-1881"><a href="#cb45-1881" aria-hidden="true" tabindex="-1"></a><span class="at">not explode.\</span></span>
<span id="cb45-1882"><a href="#cb45-1882" aria-hidden="true" tabindex="-1"></a><span class="at">Let $e </span><span class="sc">\n</span><span class="at">eq b, en$. If $e\in \mathcal P$, the proof is the same than in</span></span>
<span id="cb45-1883"><a href="#cb45-1883" aria-hidden="true" tabindex="-1"></a><span class="at">Step 2. Otherwise, let:</span></span>
<span id="cb45-1884"><a href="#cb45-1884" aria-hidden="true" tabindex="-1"></a><span class="at">$$h^e_t(n) = \sup_{I \in \mathcal{I},  m \leq n } \lambda^e_t </span><span class="sc">\b</span><span class="at">iggl(I, \sum_{k=1}^{m} \delta_{I_k}</span><span class="sc">\b</span><span class="at">iggr), \quad </span><span class="sc">\f</span><span class="at">orall \; t \in [0,T] \;  n \in {\mathbb{N}}^*.$$</span></span>
<span id="cb45-1885"><a href="#cb45-1885" aria-hidden="true" tabindex="-1"></a><span class="at">By @cnj-intensity1 and @cnj-intensity2, $h^e_t(n) &lt;\infty$, and we can</span></span>
<span id="cb45-1886"><a href="#cb45-1886" aria-hidden="true" tabindex="-1"></a><span class="at">introduce the non exploding counting process $</span><span class="sc">\b</span><span class="at">ar{N}^e$, defined by the</span></span>
<span id="cb45-1887"><a href="#cb45-1887" aria-hidden="true" tabindex="-1"></a><span class="at">thinning equation :</span></span>
<span id="cb45-1888"><a href="#cb45-1888" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span><span class="sc">\b</span><span class="at">ar N_t^e = \int_0^t \int_{{\mathbb{N}}</span><span class="sc">\t</span><span class="at">imes {\mathbb{R}}^+} \mathbf{1}_{\{k\leq N_0 + </span><span class="sc">\b</span><span class="at">ar N_{s^-} \}}  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq h^e_s (N_0 + </span><span class="sc">\b</span><span class="at">ar N_{s^-})\}} Q(\mathrm{d}s, \mathrm{d}k, \{e\}, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta),$$</span></span>
<span id="cb45-1889"><a href="#cb45-1889" aria-hidden="true" tabindex="-1"></a><span class="at">with $</span><span class="sc">\b</span><span class="at">ar N_s = </span><span class="sc">\b</span><span class="at">ar N^b_s + </span><span class="sc">\b</span><span class="at">ar N^{en}_s$.\</span></span>
<span id="cb45-1890"><a href="#cb45-1890" aria-hidden="true" tabindex="-1"></a><span class="at">Finally, by Step 2, for $s\in [0,T]$ the population size</span></span>
<span id="cb45-1891"><a href="#cb45-1891" aria-hidden="true" tabindex="-1"></a><span class="at">$N_s = N_0 + N^b_s+ N^{en}_s$ is bounded a.s. by $N_0 + </span><span class="sc">\b</span><span class="at">ar N_s$, since</span></span>
<span id="cb45-1892"><a href="#cb45-1892" aria-hidden="true" tabindex="-1"></a><span class="at">all jumps of $(N^b,N^{en})$ are jumps of $(</span><span class="sc">\b</span><span class="at">ar N^b, </span><span class="sc">\b</span><span class="at">ar N^{en})$.</span></span>
<span id="cb45-1893"><a href="#cb45-1893" aria-hidden="true" tabindex="-1"></a><span class="at">Thus, for all $s\in [0,T]$,</span></span>
<span id="cb45-1894"><a href="#cb45-1894" aria-hidden="true" tabindex="-1"></a><span class="at">$$\{k \leq N_{s^-} \}\subset  \{k\leq N_0 + </span><span class="sc">\b</span><span class="at">ar N_{s^-} \}, </span><span class="sc">\t</span><span class="at">ext{ and }  \{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_s^e(I_k, Z_{s^-})\} \subset \{</span><span class="sc">\t</span><span class="at">heta \leq h_s^e(N_0 + </span><span class="sc">\b</span><span class="at">ar N_{s^-})\}.$$</span></span>
<span id="cb45-1895"><a href="#cb45-1895" aria-hidden="true" tabindex="-1"></a><span class="at">This proves that all jumps of $N^e$ are jumps $</span><span class="sc">\b</span><span class="at">ar N^e$, and thus $N^e$</span></span>
<span id="cb45-1896"><a href="#cb45-1896" aria-hidden="true" tabindex="-1"></a><span class="at">does not explode in finite time.</span></span>
<span id="cb45-1897"><a href="#cb45-1897" aria-hidden="true" tabindex="-1"></a><span class="at">:::</span></span>
<span id="cb45-1898"><a href="#cb45-1898" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1899"><a href="#cb45-1899" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1900"><a href="#cb45-1900" aria-hidden="true" tabindex="-1"></a><span class="at">### Alternative pathwise representation </span></span>
<span id="cb45-1901"><a href="#cb45-1901" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1902"><a href="#cb45-1902" aria-hidden="true" tabindex="-1"></a><span class="at">::: {#thm-EqZrandomized}</span></span>
<span id="cb45-1903"><a href="#cb45-1903" aria-hidden="true" tabindex="-1"></a><span class="at">Let</span></span>
<span id="cb45-1904"><a href="#cb45-1904" aria-hidden="true" tabindex="-1"></a><span class="at">$\mathcal{J}_{\mathcal{E}} = \mathbb N </span><span class="sc">\t</span><span class="at">imes \mathcal{E}$ and</span></span>
<span id="cb45-1905"><a href="#cb45-1905" aria-hidden="true" tabindex="-1"></a><span class="at">$\mathcal{J}_W  = \mathbb N </span><span class="sc">\t</span><span class="at">imes \mathcal{E}_W$.\</span></span>
<span id="cb45-1906"><a href="#cb45-1906" aria-hidden="true" tabindex="-1"></a><span class="at">Let $Q^{\mathcal{E}}$ be a random Poisson measure on</span></span>
<span id="cb45-1907"><a href="#cb45-1907" aria-hidden="true" tabindex="-1"></a><span class="at">$\mathbb R^+ </span><span class="sc">\t</span><span class="at">imes \mathcal{J}_{\mathcal{E}}</span><span class="sc">\t</span><span class="at">imes \mathbb{R}^+$, of</span></span>
<span id="cb45-1908"><a href="#cb45-1908" aria-hidden="true" tabindex="-1"></a><span class="at">intensity</span></span>
<span id="cb45-1909"><a href="#cb45-1909" aria-hidden="true" tabindex="-1"></a><span class="at">$\mathrm{d}t \delta_{\mathcal{J}_{\mathcal{E}}}(\mathrm{d}k, \mathrm{d}e)  \mathbf{1}_{[0,</span><span class="sc">\b</span><span class="at">ar \lambda^e]} (</span><span class="sc">\t</span><span class="at">heta) \mathrm{d}</span><span class="sc">\t</span><span class="at">heta$,</span></span>
<span id="cb45-1910"><a href="#cb45-1910" aria-hidden="true" tabindex="-1"></a><span class="at">and $Q^{W}$ a random Poisson measure on</span></span>
<span id="cb45-1911"><a href="#cb45-1911" aria-hidden="true" tabindex="-1"></a><span class="at">$\mathbb R^+ </span><span class="sc">\t</span><span class="at">imes \mathcal{J}_W </span><span class="sc">\t</span><span class="at">imes \mathbb{N} </span><span class="sc">\t</span><span class="at">imes  \mathbb{R}^+$,</span></span>
<span id="cb45-1912"><a href="#cb45-1912" aria-hidden="true" tabindex="-1"></a><span class="at">of intensity</span></span>
<span id="cb45-1913"><a href="#cb45-1913" aria-hidden="true" tabindex="-1"></a><span class="at">$\mathrm{d}t \delta_{\mathcal{J}_{\mathcal{E}}}(\mathrm{d}k,\mathrm{d}e)) \delta_{\mathbb{N}} (\mathrm{d}j) \mathbf{1}_{[0,</span><span class="sc">\b</span><span class="at">ar W^e]} (</span><span class="sc">\t</span><span class="at">heta)\mathrm{d}</span><span class="sc">\t</span><span class="at">heta$.</span></span>
<span id="cb45-1914"><a href="#cb45-1914" aria-hidden="true" tabindex="-1"></a><span class="at">Finally, let $Q^{\mathcal P}$ be a random Poisson measure on</span></span>
<span id="cb45-1915"><a href="#cb45-1915" aria-hidden="true" tabindex="-1"></a><span class="at">$\mathbb R^+ </span><span class="sc">\t</span><span class="at">imes \mathcal{P}  </span><span class="sc">\t</span><span class="at">imes \mathbb{R}^+$, of intensity</span></span>
<span id="cb45-1916"><a href="#cb45-1916" aria-hidden="true" tabindex="-1"></a><span class="at">$\mathrm{d}t \delta_{\cal P}(\mathrm{d}e)  \mathbf{1}_{[0,</span><span class="sc">\b</span><span class="at">ar \mu^e]} (</span><span class="sc">\t</span><span class="at">heta)\mathrm{d}</span><span class="sc">\t</span><span class="at">heta$.\</span></span>
<span id="cb45-1917"><a href="#cb45-1917" aria-hidden="true" tabindex="-1"></a><span class="at">There exists a unique measure-valued process $Z$, strong solution on the</span></span>
<span id="cb45-1918"><a href="#cb45-1918" aria-hidden="true" tabindex="-1"></a><span class="at">following SDE driven by Poisson measure: $$</span><span class="sc">\b</span><span class="at">egin{aligned}</span></span>
<span id="cb45-1919"><a href="#cb45-1919" aria-hidden="true" tabindex="-1"></a><span class="at">Z_t  = Z_0 &amp;  + \int_0^t \int_{\mathcal{J}_{\mathcal{E}}</span><span class="sc">\t</span><span class="at">imes \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} }\mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_s^e(I_k, Z_{s^-})\}} Q^{\mathcal{E}}(\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ) </span><span class="sc">\\</span></span>
<span id="cb45-1920"><a href="#cb45-1920" aria-hidden="true" tabindex="-1"></a><span class="at">&amp;  + \int_0^t \int_{\mathcal{J}_W  </span><span class="sc">\t</span><span class="at">imes {\mathbb{N}}</span><span class="sc">\t</span><span class="at">imes  \mathbb R^+ }\phi^e (s , I_k)  \mathbf{1}_{\{k \leq N_{s^-}\} } \mathbf{1}_{\{j \leq N_{s^-}\} }\mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq W^e(s, I_k , I_j) \}} Q^W (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e,  \mathrm{d}j ,\mathrm{d}</span><span class="sc">\t</span><span class="at">heta ),</span><span class="sc">\\</span></span>
<span id="cb45-1921"><a href="#cb45-1921" aria-hidden="true" tabindex="-1"></a><span class="at">&amp; +   \int_0^t \int_{\mathcal{P} </span><span class="sc">\t</span><span class="at">imes \mathbb R^+}  \phi^e(s, I_{s^-}) \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \mu_s^e \}} Q^{\mathcal{P}} (\mathrm{d}s ,\mathrm{d}e , \mathrm{d}</span><span class="sc">\t</span><span class="at">heta),</span></span>
<span id="cb45-1922"><a href="#cb45-1922" aria-hidden="true" tabindex="-1"></a><span class="sc">\e</span><span class="at">nd{aligned}$$ {#eq-SDE_pop_randomized}</span></span>
<span id="cb45-1923"><a href="#cb45-1923" aria-hidden="true" tabindex="-1"></a><span class="at">with $I_{s^-}$ an individual taken uniformly in</span></span>
<span id="cb45-1924"><a href="#cb45-1924" aria-hidden="true" tabindex="-1"></a><span class="at">$Z_{s^-}$.\</span></span>
<span id="cb45-1925"><a href="#cb45-1925" aria-hidden="true" tabindex="-1"></a><span class="at">Furthermore, the solution of</span></span>
<span id="cb45-1926"><a href="#cb45-1926" aria-hidden="true" tabindex="-1"></a><span class="at">@eq-SDE_pop_randomized has the same law than the solution of</span></span>
<span id="cb45-1927"><a href="#cb45-1927" aria-hidden="true" tabindex="-1"></a><span class="at">@eq-sde-eq-Z. </span></span>
<span id="cb45-1928"><a href="#cb45-1928" aria-hidden="true" tabindex="-1"></a><span class="at">:::</span></span>
<span id="cb45-1929"><a href="#cb45-1929" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1930"><a href="#cb45-1930" aria-hidden="true" tabindex="-1"></a><span class="at">The proof of @thm-EqZrandomized  follows the same steps than the proof of</span></span>
<span id="cb45-1931"><a href="#cb45-1931" aria-hidden="true" tabindex="-1"></a><span class="at">@thm-eq-Z.</span></span>
<span id="cb45-1932"><a href="#cb45-1932" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1933"><a href="#cb45-1933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1934"><a href="#cb45-1934" aria-hidden="true" tabindex="-1"></a><span class="at">## Proof of @thm-interaction {#sec-prf-thm-interaction}</span></span>
<span id="cb45-1935"><a href="#cb45-1935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1936"><a href="#cb45-1936" aria-hidden="true" tabindex="-1"></a><span class="at">For ease of notation, we prove</span></span>
<span id="cb45-1937"><a href="#cb45-1937" aria-hidden="true" tabindex="-1"></a><span class="at">the case when $\mathcal{P} =</span><span class="sc">\e</span><span class="at">mptyset$ (there are no events with Poisson</span></span>
<span id="cb45-1938"><a href="#cb45-1938" aria-hidden="true" tabindex="-1"></a><span class="at">intensity).\</span></span>
<span id="cb45-1939"><a href="#cb45-1939" aria-hidden="true" tabindex="-1"></a><span class="at">Let $Z$ be the population process obtained by @alg-interaction, and $(T_n)_{n\geq 0}$ the sequence</span></span>
<span id="cb45-1940"><a href="#cb45-1940" aria-hidden="true" tabindex="-1"></a><span class="at">of its jump times ($T_0=0$).\</span></span>
<span id="cb45-1941"><a href="#cb45-1941" aria-hidden="true" tabindex="-1"></a><span class="at">**Step 1** Let $T_1$ be the first event time in the population, with its</span></span>
<span id="cb45-1942"><a href="#cb45-1942" aria-hidden="true" tabindex="-1"></a><span class="at">associated marks defining the type $E_1$ of the event and the individual</span></span>
<span id="cb45-1943"><a href="#cb45-1943" aria-hidden="true" tabindex="-1"></a><span class="at">$I_1$ to which this event occurs. By construction, $(T_1, E_1, I_1)$ is</span></span>
<span id="cb45-1944"><a href="#cb45-1944" aria-hidden="true" tabindex="-1"></a><span class="at">characterized by the first jump of:</span></span>
<span id="cb45-1945"><a href="#cb45-1945" aria-hidden="true" tabindex="-1"></a><span class="at">$$Q^0(\mathrm{d}t, \mathrm{d}k , \mathrm{d}e) = \int_{\mathbb R^+} \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_{t}^e(I_k,Z_0)\}}</span><span class="sc">\b</span><span class="at">ar Q^0 (\mathrm{d}t ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ),$$</span></span>
<span id="cb45-1946"><a href="#cb45-1946" aria-hidden="true" tabindex="-1"></a><span class="at">with $</span><span class="sc">\b</span><span class="at">ar Q^0$ the Poisson measure introduced in the first step of the</span></span>
<span id="cb45-1947"><a href="#cb45-1947" aria-hidden="true" tabindex="-1"></a><span class="at">algorithm described in @sec-simulation-algo.</span></span>
<span id="cb45-1948"><a href="#cb45-1948" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1949"><a href="#cb45-1949" aria-hidden="true" tabindex="-1"></a><span class="at">Since $T_1$ is the first event time, the population composition stays</span></span>
<span id="cb45-1950"><a href="#cb45-1950" aria-hidden="true" tabindex="-1"></a><span class="at">constant, $Z_t=Z_0$, on $\{t&lt;T_1\}$. In addition, recalling that the</span></span>
<span id="cb45-1951"><a href="#cb45-1951" aria-hidden="true" tabindex="-1"></a><span class="at">first event has the action $\phi^{E_1}(T_1, I_1)$ (see @tbl-event-action) on</span></span>
<span id="cb45-1952"><a href="#cb45-1952" aria-hidden="true" tabindex="-1"></a><span class="at">the population $Z$, we obtain that: $$</span><span class="sc">\b</span><span class="at">egin{aligned}</span></span>
<span id="cb45-1953"><a href="#cb45-1953" aria-hidden="true" tabindex="-1"></a><span class="at">Z_{t\wedge T_1} &amp; =  Z_0 + \mathbf{1}_{\{t\geq T_1\}} \phi^{E_1} (T_1 , I_1)  </span><span class="sc">\\</span></span>
<span id="cb45-1954"><a href="#cb45-1954" aria-hidden="true" tabindex="-1"></a><span class="at"> &amp; = Z_0 + \int_0^{t\wedge T_1}  \int_{\mathcal{J}_0} \phi^e (s , I_k)  Q^0 (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e ) </span><span class="sc">\\</span></span>
<span id="cb45-1955"><a href="#cb45-1955" aria-hidden="true" tabindex="-1"></a><span class="at">&amp; = Z_0 + \int_0^{t\wedge T_1} \int_{\mathcal{J}_0}  \int_{\mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_s^e(I_k,Z_0)\}}</span><span class="sc">\b</span><span class="at">ar Q^0 (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ).</span></span>
<span id="cb45-1956"><a href="#cb45-1956" aria-hidden="true" tabindex="-1"></a><span class="sc">\e</span><span class="at">nd{aligned}$$ Since $Z_{s^-} = Z_0$ on $\{s \leq T_1\}$, the last</span></span>
<span id="cb45-1957"><a href="#cb45-1957" aria-hidden="true" tabindex="-1"></a><span class="at">equation can be rewritten as $$</span></span>
<span id="cb45-1958"><a href="#cb45-1958" aria-hidden="true" tabindex="-1"></a><span class="at"> Z_{t\wedge T_1}   = Z_0 + \int_0^{t\wedge T_1} \int_{\mathcal{J}_0}  \int_{\mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_s^e(I_k,Z_{s^-})\}}</span><span class="sc">\b</span><span class="at">ar Q^0 (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ).$$</span></span>
<span id="cb45-1959"><a href="#cb45-1959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1960"><a href="#cb45-1960" aria-hidden="true" tabindex="-1"></a><span class="at">**Step 2** The population size at the $n$--th event time $T_n$ is</span></span>
<span id="cb45-1961"><a href="#cb45-1961" aria-hidden="true" tabindex="-1"></a><span class="at">$N_{T_n}$. The $(n+1)$--th event type and the individual to which this</span></span>
<span id="cb45-1962"><a href="#cb45-1962" aria-hidden="true" tabindex="-1"></a><span class="at">event occur are thus chosen in the set</span></span>
<span id="cb45-1963"><a href="#cb45-1963" aria-hidden="true" tabindex="-1"></a><span class="at">$$\mathcal{J}_n := \{ 1,\dots, N_{T_n}\} </span><span class="sc">\t</span><span class="at">imes (\mathcal{E} \cup \mathcal{E}_W).$$</span></span>
<span id="cb45-1964"><a href="#cb45-1964" aria-hidden="true" tabindex="-1"></a><span class="at">Conditionally to $\mathcal{F}_{T_n}$, let us first introduce the marked</span></span>
<span id="cb45-1965"><a href="#cb45-1965" aria-hidden="true" tabindex="-1"></a><span class="at">Poisson measure $</span><span class="sc">\b</span><span class="at">ar Q^n$ on</span></span>
<span id="cb45-1966"><a href="#cb45-1966" aria-hidden="true" tabindex="-1"></a><span class="at">$[T_n, \infty) </span><span class="sc">\t</span><span class="at">imes \mathcal J_n </span><span class="sc">\t</span><span class="at">imes \mathbb R^+$, of intensity:</span></span>
<span id="cb45-1967"><a href="#cb45-1967" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1968"><a href="#cb45-1968" aria-hidden="true" tabindex="-1"></a><span class="sc">\b</span><span class="at">egin{aligned}</span></span>
<span id="cb45-1969"><a href="#cb45-1969" aria-hidden="true" tabindex="-1"></a><span class="sc">\b</span><span class="at">ar \mu^n(\mathrm{d}t, \mathrm{d}k, \mathrm{d}e , \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ) &amp; := \mathbf{1}_{\{t &gt; T_n \}}</span><span class="sc">\b</span><span class="at">ar \Lambda (N_{T_n})\mathrm{d}t  </span><span class="sc">\f</span><span class="at">rac{</span><span class="sc">\b</span><span class="at">ar \lambda^e_n }{</span><span class="sc">\b</span><span class="at">ar \Lambda(N_{T_n})} \delta_{\mathcal J_n}(\mathrm{d}k, \mathrm{d}e) </span><span class="sc">\f</span><span class="at">rac{1}{</span><span class="sc">\b</span><span class="at">ar \lambda^e_n} \mathbf{1}_{[0,</span><span class="sc">\b</span><span class="at">ar \lambda^e_n]} (</span><span class="sc">\t</span><span class="at">heta)\mathrm{d}</span><span class="sc">\t</span><span class="at">heta,</span><span class="sc">\\</span></span>
<span id="cb45-1970"><a href="#cb45-1970" aria-hidden="true" tabindex="-1"></a><span class="at">&amp;  = \mathbf{1}_{\{t &gt; T_n \}}\mathrm{d}t  \delta_{\mathcal J_n}(\mathrm{d}k, \mathrm{d}e) \mathbf{1}_{[0,</span><span class="sc">\b</span><span class="at">ar \lambda^e_n]}(</span><span class="sc">\t</span><span class="at">heta)\mathrm{d}</span><span class="sc">\t</span><span class="at">heta,</span></span>
<span id="cb45-1971"><a href="#cb45-1971" aria-hidden="true" tabindex="-1"></a><span class="sc">\e</span><span class="at">nd{aligned}</span></span>
<span id="cb45-1972"><a href="#cb45-1972" aria-hidden="true" tabindex="-1"></a><span class="at">$$ {#eq-barmun}</span></span>
<span id="cb45-1973"><a href="#cb45-1973" aria-hidden="true" tabindex="-1"></a><span class="at">with $\lambda^e_n = </span><span class="sc">\b</span><span class="at">ar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + </span><span class="sc">\b</span><span class="at">ar W^e N_{T_n} \mathbf{1}_{e \in \mathcal{E}_W}$.</span></span>
<span id="cb45-1974"><a href="#cb45-1974" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1975"><a href="#cb45-1975" aria-hidden="true" tabindex="-1"></a><span class="at">By definition, $</span><span class="sc">\b</span><span class="at">ar Q^n$ has no jump before $T_n$.\</span></span>
<span id="cb45-1976"><a href="#cb45-1976" aria-hidden="true" tabindex="-1"></a><span class="at">As for the first event, the triplet $(T_{n+1}, E_{n+1}, I_{n+1})$ is</span></span>
<span id="cb45-1977"><a href="#cb45-1977" aria-hidden="true" tabindex="-1"></a><span class="at">determined by the first jump of the measure</span></span>
<span id="cb45-1978"><a href="#cb45-1978" aria-hidden="true" tabindex="-1"></a><span class="at">$Q^n (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e) := \int_{\mathbb R^+} \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta \leq \lambda_s^e(I_k, Z_{T_n})\}}</span><span class="sc">\b</span><span class="at">ar Q^n (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta)$,</span></span>
<span id="cb45-1979"><a href="#cb45-1979" aria-hidden="true" tabindex="-1"></a><span class="at">obtained by thinning of $</span><span class="sc">\b</span><span class="at">ar Q^n$. Finally, since the population</span></span>
<span id="cb45-1980"><a href="#cb45-1980" aria-hidden="true" tabindex="-1"></a><span class="at">composition is constant on $[T_n, T_{n+1}[$, $Z_t = Z_{T_n}$, the</span></span>
<span id="cb45-1981"><a href="#cb45-1981" aria-hidden="true" tabindex="-1"></a><span class="at">population on $[0,T_{n+1}]$ is defined by: </span></span>
<span id="cb45-1982"><a href="#cb45-1982" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span></span>
<span id="cb45-1983"><a href="#cb45-1983" aria-hidden="true" tabindex="-1"></a><span class="sc">\b</span><span class="at">egin{aligned}</span></span>
<span id="cb45-1984"><a href="#cb45-1984" aria-hidden="true" tabindex="-1"></a><span class="at"> Z_{t\wedge T_{n+1}}  &amp;  = Z_{t \wedge T_n }  + \mathbf{1}_{\{t\geq T_{n+1}\}}\phi^{E_{n+1}}(T_{n+1}, I_{n+1}), </span><span class="sc">\\</span></span>
<span id="cb45-1985"><a href="#cb45-1985" aria-hidden="true" tabindex="-1"></a><span class="at">&amp; = Z_{t \wedge T_n } + \int_{t \wedge T_n}^{t \wedge T_{n+1}} \int_{\mathcal{J}_n</span></span>
<span id="cb45-1986"><a href="#cb45-1986" aria-hidden="true" tabindex="-1"></a><span class="sc">\t</span><span class="at">imes \mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta\leq \lambda_s^e(I_k, Z_{s^-})\}}</span><span class="sc">\b</span><span class="at">ar Q^n (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ).</span></span>
<span id="cb45-1987"><a href="#cb45-1987" aria-hidden="true" tabindex="-1"></a><span class="sc">\e</span><span class="at">nd{aligned}</span></span>
<span id="cb45-1988"><a href="#cb45-1988" aria-hidden="true" tabindex="-1"></a><span class="at">$$  {#eq-z-tn} </span></span>
<span id="cb45-1989"><a href="#cb45-1989" aria-hidden="true" tabindex="-1"></a><span class="at">Applying $n$ times @eq-z-tn yields</span></span>
<span id="cb45-1990"><a href="#cb45-1990" aria-hidden="true" tabindex="-1"></a><span class="at">that: </span></span>
<span id="cb45-1991"><a href="#cb45-1991" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span><span class="sc">\b</span><span class="at">egin{aligned}</span></span>
<span id="cb45-1992"><a href="#cb45-1992" aria-hidden="true" tabindex="-1"></a><span class="at">Z_{t\wedge T_{n+1}} = Z_0  + \sum_{l=0}^n \int_{t \wedge T_l}^{t \wedge T_{l+1}}\int_{ \mathcal{J}_l </span><span class="sc">\t</span><span class="at">imes  \mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta\leq \lambda_s^e(I_k, </span><span class="sc">\t</span><span class="at">ilde Z_{s^-})\}}</span><span class="sc">\b</span><span class="at">ar Q^l (\mathrm{d}s ,\mathrm{d}k , \mathrm{d}e, \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ).</span></span>
<span id="cb45-1993"><a href="#cb45-1993" aria-hidden="true" tabindex="-1"></a><span class="sc">\e</span><span class="at">nd{aligned}</span></span>
<span id="cb45-1994"><a href="#cb45-1994" aria-hidden="true" tabindex="-1"></a><span class="at">$$ </span></span>
<span id="cb45-1995"><a href="#cb45-1995" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-1996"><a href="#cb45-1996" aria-hidden="true" tabindex="-1"></a><span class="at">**Step 3** Finally, let $</span><span class="sc">\t</span><span class="at">ilde{Z}$ be the solution of @eq-sde-eq-Z,</span></span>
<span id="cb45-1997"><a href="#cb45-1997" aria-hidden="true" tabindex="-1"></a><span class="at">with $(</span><span class="sc">\t</span><span class="at">ilde T_n)_{n\geq 0}$ the sequence of its event times. Then, we</span></span>
<span id="cb45-1998"><a href="#cb45-1998" aria-hidden="true" tabindex="-1"></a><span class="at">can write similarly for all $n\geq 0$: $$</span><span class="sc">\b</span><span class="at">egin{aligned}</span></span>
<span id="cb45-1999"><a href="#cb45-1999" aria-hidden="true" tabindex="-1"></a><span class="at"> </span><span class="sc">\t</span><span class="at">ilde Z_{t\wedge </span><span class="sc">\t</span><span class="at">ilde T_{n+1}} &amp; = Z_0  + \sum_{l=0}^n \int_{t \wedge </span><span class="sc">\t</span><span class="at">ilde  T_l}^{t \wedge </span><span class="sc">\t</span><span class="at">ilde T_{l+1}} \int_{\mathcal{J}</span><span class="sc">\t</span><span class="at">imes \mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta\leq \lambda_s^e(I_k,  </span><span class="sc">\t</span><span class="at">ilde Z_{s^-})\}}\mathbf{1}_{ \{k \leq </span><span class="sc">\t</span><span class="at">ilde N_{s^-} \}}   Q(\mathrm{d}s, \mathrm{d}k , \mathrm{d}e , \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ), </span><span class="sc">\\</span></span>
<span id="cb45-2000"><a href="#cb45-2000" aria-hidden="true" tabindex="-1"></a><span class="at">&amp; = Z_0  + \sum_{l=0}^n \int_{t \wedge </span><span class="sc">\t</span><span class="at">ilde  T_l}^{t \wedge </span><span class="sc">\t</span><span class="at">ilde T_{l+1}} \int_{\mathcal{J}</span><span class="sc">\t</span><span class="at">imes \mathbb R^+} \phi^e (s , I_k)  \mathbf{1}_{\{</span><span class="sc">\t</span><span class="at">heta\leq \lambda_s^e(I_k,  </span><span class="sc">\t</span><span class="at">ilde Z_{s^-})\}} \mathbf{1}_{ \{</span><span class="sc">\t</span><span class="at">heta \leq </span><span class="sc">\t</span><span class="at">ilde \lambda^e_n \}}\mathbf{1}_{ \{k \leq </span><span class="sc">\t</span><span class="at">ilde N_{</span><span class="sc">\t</span><span class="at">ilde T_l} \}}  Q(\mathrm{d}s, \mathrm{d}k , \mathrm{d}e , \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ),</span></span>
<span id="cb45-2001"><a href="#cb45-2001" aria-hidden="true" tabindex="-1"></a><span class="sc">\e</span><span class="at">nd{aligned}$$ since $</span><span class="sc">\t</span><span class="at">ilde  Z_{s^-} = </span><span class="sc">\t</span><span class="at">ilde Z_{T_l}$ on</span></span>
<span id="cb45-2002"><a href="#cb45-2002" aria-hidden="true" tabindex="-1"></a><span class="at">$</span><span class="sc">\t</span><span class="at">ilde [T_l, </span><span class="sc">\t</span><span class="at">ilde T_{l+1}]$, and </span></span>
<span id="cb45-2003"><a href="#cb45-2003" aria-hidden="true" tabindex="-1"></a><span class="at">$$\lambda_s^e(I_k,  </span><span class="sc">\t</span><span class="at">ilde Z_{s^-}) \leq </span><span class="sc">\t</span><span class="at">ilde \lambda^e_n:=  </span><span class="sc">\b</span><span class="at">ar \lambda^e \mathbf{1}_{e \in \mathcal{E}} + </span><span class="sc">\b</span><span class="at">ar W^e </span><span class="sc">\t</span><span class="at">ilde N_{</span><span class="sc">\t</span><span class="at">ilde T_n} \mathbf{1}_{e \in \mathcal{E}_W}$$</span></span>
<span id="cb45-2004"><a href="#cb45-2004" aria-hidden="true" tabindex="-1"></a><span class="at">For each $l \geq 0$, let</span></span>
<span id="cb45-2005"><a href="#cb45-2005" aria-hidden="true" tabindex="-1"></a><span class="at">$$</span><span class="sc">\t</span><span class="at">ilde Q^l(\mathrm{d}t, \mathrm{d}k , \mathrm{d}e , \mathrm{d}</span><span class="sc">\t</span><span class="at">heta )  = \mathbf{1}_{\{t &gt;  </span><span class="sc">\t</span><span class="at">ilde T_l\}} \mathbf{1}_{ \{1, \dots , </span><span class="sc">\t</span><span class="at">ilde N_{</span><span class="sc">\t</span><span class="at">ilde T_l} \}}(k)  \mathbf{1}_{[0, </span><span class="sc">\t</span><span class="at">ilde \lambda^e_n]}(</span><span class="sc">\t</span><span class="at">heta) Q(\mathrm{d}t, \mathrm{d}k , \mathrm{d}e , \mathrm{d}</span><span class="sc">\t</span><span class="at">heta ).$$</span></span>
<span id="cb45-2006"><a href="#cb45-2006" aria-hidden="true" tabindex="-1"></a><span class="at">By @prp-restriction-poisson-measure, $</span><span class="sc">\t</span><span class="at">ilde Q^l$ is,</span></span>
<span id="cb45-2007"><a href="#cb45-2007" aria-hidden="true" tabindex="-1"></a><span class="at">conditionally to $\mathcal{F}_{T_l}$, a Poisson measure of intensity</span></span>
<span id="cb45-2008"><a href="#cb45-2008" aria-hidden="true" tabindex="-1"></a><span class="at">$$\mathbf{1}_{\{t &gt;  </span><span class="sc">\t</span><span class="at">ilde T_l\}}   \mathrm{d}t \mathbf{1}_{ \{1, \dots , </span><span class="sc">\t</span><span class="at">ilde N_{</span><span class="sc">\t</span><span class="at">ilde T_l} \}}(k) \delta_{\mathcal{J}}(\mathrm{d}k, \mathrm{d}e)\mathbf{1}_{[0, </span><span class="sc">\t</span><span class="at">ilde \lambda^e_n]}(</span><span class="sc">\t</span><span class="at">heta) \mathrm{d}</span><span class="sc">\t</span><span class="at">heta.$$</span></span>
<span id="cb45-2009"><a href="#cb45-2009" aria-hidden="true" tabindex="-1"></a><span class="at">It follows easily by induction that $</span><span class="sc">\t</span><span class="at">ilde{Q}^l$  has thus the same distribution than</span></span>
<span id="cb45-2010"><a href="#cb45-2010" aria-hidden="true" tabindex="-1"></a><span class="at">$</span><span class="sc">\b</span><span class="at">ar Q^l$, the Poisson measure with the conditional intensity $</span><span class="sc">\b</span><span class="at">ar \mu^l$</span></span>
<span id="cb45-2011"><a href="#cb45-2011" aria-hidden="true" tabindex="-1"></a><span class="at">defined in @eq-barmun. Thus, $Z$ is an exact simulation of @eq-sde-eq-Z.</span></span>
<span id="cb45-2012"><a href="#cb45-2012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-2013"><a href="#cb45-2013" aria-hidden="true" tabindex="-1"></a><span class="at">## Acknowledgements {.appendix}</span></span>
<span id="cb45-2014"><a href="#cb45-2014" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-2015"><a href="#cb45-2015" aria-hidden="true" tabindex="-1"></a><span class="at">The research of Sarah Kaakai is funded by the European Union (ERC, SINGER, 101054787). Views and opinions expressed are however those of the author(s) only and do not necessarily reflect those of the European Union or the European Research Council. Neither the European Union nor the granting authority can be held responsible for them.</span></span>
<span id="cb45-2016"><a href="#cb45-2016" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-2017"><a href="#cb45-2017" aria-hidden="true" tabindex="-1"></a><span class="at"># References {.unnumbered}</span></span>
<span id="cb45-2018"><a href="#cb45-2018" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-2019"><a href="#cb45-2019" aria-hidden="true" tabindex="-1"></a><span class="at">::: {#refs}</span></span>
<span id="cb45-2020"><a href="#cb45-2020" aria-hidden="true" tabindex="-1"></a><span class="at">:::</span></span>
<span id="cb45-2021"><a href="#cb45-2021" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-2022"><a href="#cb45-2022" aria-hidden="true" tabindex="-1"></a><span class="at"># Session information {.appendix .unnumbered}</span></span>
<span id="cb45-2023"><a href="#cb45-2023" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-2024"><a href="#cb45-2024" aria-hidden="true" tabindex="-1"></a><span class="st">```</span>{r session<span class="sc">-</span>info}</span>
<span id="cb45-2025"><a href="#cb45-2025" aria-hidden="true" tabindex="-1"></a><span class="fu">sessionInfo</span>()</span>
<span id="cb45-2026"><a href="#cb45-2026" aria-hidden="true" tabindex="-1"></a><span class="st">```</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
    <script type="text/javascript">
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let pseudocodeOptions = {
          indentSize: el.dataset.indentSize || "1.2em",
          commentDelimiter: el.dataset.commentDelimiter || "//",
          lineNumber: el.dataset.lineNumber === "true" ? true : false,
          lineNumberPunc: el.dataset.lineNumberPunc || ":",
          noEnd: el.dataset.noEnd === "true" ? true : false,
          titlePrefix: el.dataset.captionPrefix || "Algorithm"
        };
        pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
      });
    })(document);
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let captionSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
        if (captionSpan !== null) {
          let captionPrefix = el.dataset.captionPrefix + " ";
          let captionNumber = "";
          if (el.dataset.pseudocodeNumber) {
            captionNumber = el.dataset.pseudocodeNumber + " ";
            if (el.dataset.chapterLevel) {
              captionNumber = el.dataset.chapterLevel + "." + captionNumber;
            }
          }
          captionSpan.innerHTML = captionPrefix + captionNumber;
        }
      });
    })(document);
    </script>
  




</body></html>